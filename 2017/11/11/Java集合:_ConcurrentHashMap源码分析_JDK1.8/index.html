<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java集合：ConcurrentHashMap源码分析_JDK1.8.md | 史可的博客</title>
  <meta name="author" content="shike">
  
  <meta name="description" content="转载文章，原博客地址为：  http://blog.csdn.net/u010887744/article/details/50637030

jdk1.8和jdk1.7对于ConcurrentHashMap的实现出现的重大变化，不再采用分段锁的方法，网上这方面的博客较少，这篇文章写得较好，转载扩撒">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java集合：ConcurrentHashMap源码分析_JDK1.8.md"/>
  <meta property="og:site_name" content="史可的博客"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">史可的博客</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> Java集合：ConcurrentHashMap源码分析_JDK1.8.md</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>转载文章，原博客地址为： <a href="http://blog.csdn.net/u010887744/article/details/50637030" target="_blank" rel="noopener"> http://blog.csdn.net/u010887744/article/details/50637030
</a></p>
<p>jdk1.8和jdk1.7对于ConcurrentHashMap的实现出现的重大变化，不再采用分段锁的方法，网上这方面的博客较少，这篇文章写得较好，转载扩撒<br>。</p>
<p>本文首写于有道云笔记，并在小组分享会分享，先整理发布，希望和大家交流探讨。 <a href="http://note.youdao.com/share/?id=dde7a10b98aee57676408bc475ab0680&amp;type=note" target="_blank" rel="noopener"> 云笔记地址
</a></p>
<p>概述：</p>
<p>1、设计首要目的：维护并发可读性（get、迭代相关）；次要目的：使空间消耗比HashMap相同或更好，且支持多线程高效率的初始插入（empty<br>table）。</p>
<p>2、HashTable  线程安全，但采用synchronized，多线程下效率低下。线程1put时，线程2无法put或get。</p>
<p>实现原理：</p>
<p>锁分离：</p>
<p>在HashMap的基础上，将数据分段存储，  ConcurrentHashMap由多个Segment组成，每个Segment都有把锁。<br>Segment下包含很多Node，也就是我们的键值对了。</p>
<p><strong> 如果还停留在锁分离、Segment，那已经out了。  </strong></p>
<p>Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。</p>
<ul>
<li><strong> CAS算法 </strong> ；  unsafe.compareAndSwapInt(this, valueOffset, expect, update);  CAS(Compare And Swap)，意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。 </li>
<li>与Java8的HashMap有相通之处，底层依然由 <strong> “数组”+链表+红黑树 </strong> ； </li>
<li>底层结构存放的是 <strong> TreeBin </strong> 对象，而不是TreeNode对象； </li>
<li>CAS作为知名无锁算法，那ConcurrentHashMap就没用锁了么？当然不是，hash值相同的链表的头结点还是会synchronized上锁。 </li>
</ul>
<p>private  static  final  int  MAXIMUM_CAPACITY  = 1 &lt;&lt; 30; // 2的30次方=1073741824</p>
<p>private  static  final  int  DEFAULT_CAPACITY  = 16;</p>
<p>static  final  int  MAX_ARRAY_SIZE  = Integer.  MAX_VALUE  - 8; //<br>MAX_VALUE=2^31-1=2147483647</p>
<p>private  static  final  int  DEFAULT_CONCURRENCY_LEVEL  = 16;</p>
<p>private  static  final  float  LOAD_FACTOR  = 0.75f;</p>
<p>static  final  int  TREEIFY_THRESHOLD  <strong> = 8; </strong> //  链表转树阀值，大于8时</p>
<p>static  final  int  UNTREEIFY_THRESHOLD  <strong> = 6; </strong> //  树转链表阀值，小于等于6（tranfer时，<br>lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）。【<br>仅在扩容tranfer时  才可能树转链表】</p>
<p>static  final  int  MIN_TREEIFY_CAPACITY  = 64;</p>
<p>private  static  final  int  MIN_TRANSFER_STRIDE  = 16;</p>
<p>private  static  int  RESIZE_STAMP_BITS  = 16;</p>
<p>private  static  final  int  MAX_RESIZERS  <strong> = (1 &lt;&lt; (32 - </strong> <strong><br>RESIZE_STAMP_BITS  </strong> <strong> )) - 1; </strong> // 2^15-1，hel  p resize的最大线程数</p>
<p>private  static  final  int  RESIZE_STAMP_SHIFT  <strong> = 32 - </strong> <strong><br>RESIZE_STAMP_BITS  </strong> <strong> ; </strong> // 32-16=16，sizeCtl  中记录size大小的偏移量</p>
<p>static  final  int  MOVED  <strong> = -1; </strong> // hash for forwarding nodes（for<br>warding nodes的hash值）、标示位</p>
<p>static  final  int  TREEBIN  <strong> = -2; </strong> // hash for roots of tree<br>s（树根节点的hash值）</p>
<p>static  final  int  RESERVED  <strong> = -3; </strong> // hash for transient reservations<br>（ReservationNode的hash值）</p>
<p>static  final  int  HASH_BITS  = 0x7fffffff;  // usable bits of normal node<br>hash</p>
<p>static  final  int  NCPU  <strong> = Runtime.  getRuntime  ().availableProcessors();
</strong> // 可用处理器数量</p>
<p>/**</p>
<ul>
<li><p>Table initialization and resizing control.  When negative, the </p>
</li>
<li><p>table is being initialized or resized:  -  1 for initialization, </p>
</li>
<li><p>else  -  (1 + the number of active resizing threads).  Otherwise, </p>
</li>
<li><p>when table is null, holds the initial table size to use upon </p>
</li>
<li><p>creation, or 0 for default. After initialization, holds the </p>
</li>
<li><p>next element count value upon which to resize the table. </p>
</li>
</ul>
<p>*/ </p>
<p>private  transient  volatile  int  sizeCtl  ;</p>
<p>sizeCtl  是  控制标识符，不同的值表示不同的意义。</p>
<ul>
<li>负数代表正在进行初始化或扩容操作 </li>
<li>-1代表正在初始化 </li>
<li>-N 表示有N-1个线程正在进行扩容操作 </li>
<li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，类似于扩容阈值。它的值  始终是当前ConcurrentHashMap容量的0.75倍  ，这与loadfactor是对应的。  实际容量  &gt;=sizeCtl，则扩容。 </li>
</ul>
<p>部分构造函数：</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  ConcurrentHashMap(  int  initialCapacity, </li>
<li>float  loadFactor,  int  concurrencyLevel) { </li>
<li>if  (!(loadFactor &gt; 0  .0f) || initialCapacity &lt; 0  || concurrencyLevel &lt;=  0  ) </li>
<li>thrownew IllegalArgumentException(); </li>
<li>if  (initialCapacity &lt; concurrencyLevel)  // Use at least as many bins </li>
<li>initialCapacity = concurrencyLevel;  // as estimated threads </li>
<li>long  size = (  long  )(  1.0  + (  long  )initialCapacity / loadFactor); </li>
<li>int  cap = (size &gt;= (  long  )MAXIMUM_CAPACITY) ? </li>
<li>MAXIMUM_CAPACITY : tableSizeFor((  int  )size); </li>
<li>this  .sizeCtl = cap; </li>
<li>} </li>
</ol>
<p>concurrencyLevel  ：</p>
<p>concurrencyLevel，能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，在Java8之前实际上就是ConcurrentH<br>ashMap中的分段锁个数，即Segment[]的数组长度  。<br>正确地估计很重要，当低估，数据结构将根据额外的竞争，从而导致线程试图写入当前锁定的段时阻塞；<br>相反，如果高估了并发级别，你遇到过大的膨胀，由于段的不必要的数量;  这种膨胀可能会导致性能下降，由于高数缓存未命中。</p>
<p>在Java8里，仅仅是为了 <strong> 兼容旧版本而保留 </strong> 。唯一的作用就是保证构造map时初始容量不小于concurrencyLevel。</p>
<p>源码122行：</p>
<p>Also, for compatibility with previous  versions of this class, constructors<br>may optionally specify an  expected {@code concurrencyLevel} as an additional<br>hint for  internal sizing.</p>
<p>源码482行：</p>
<p>Mainly: We  leave untouched but unused constructor arguments refering to<br>concurrencyLevel .……</p>
<p>……</p>
<p>1、重要属性：</p>
<p>1.1 Node：</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>static  class  Node<k,v> implements  Map.Entry<k,v> { </k,v></k,v></li>
<li>final  int  hash; </li>
<li>final  K key; </li>
<li>volatile  V val;  // Java8增加volatile，保证可见性 </li>
<li>volatile  Node<k,v> next; </k,v></li>
<li><ol>
<li>Node(inthash, K key, V val, Node<k,v> next) { </k,v></li>
</ol>
</li>
<li>this  .hash = hash; </li>
<li>this  .key = key; </li>
<li>this  .val = val; </li>
<li>this  .next = next; </li>
<li>} </li>
<li><ol>
<li>public  final  K getKey()       {  return  key; } </li>
</ol>
</li>
<li>public  final  V getValue()     {  return  val; } </li>
<li>// HashMap调用Objects.hashCode()，最终也是调用Object.hashCode()；效果一样 </li>
<li>public  final  int  hashCode()   { returnkey.hashCode() ^ val.hashCode(); } </li>
<li>public  final  String toString(){ returnkey +  “=”  + val; } </li>
<li>public  final  V setValue(V value) {  // 不允许修改value值，HashMap允许 </li>
<li>throw  new  UnsupportedOperationException(); </li>
<li>} </li>
<li>// HashMap使用if (o == this)，且嵌套if；concurrent使用&amp;&amp;</li>
<li>public  final  boolean  equals(Object o) { </li>
<li>Object k, v, u; Map.Entry&lt;?,?&gt; e; </li>
<li>return  ((oinstanceof Map.Entry) &amp;&amp;</li>
<li>(k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) !=  null  &amp;&amp;</li>
<li>(v = e.getValue()) !=  null  &amp;&amp;</li>
<li>(k == key || k.equals(key)) &amp;&amp;</li>
<li>(v == (u = val) || v.equals(u))); </li>
<li>} </li>
<li><ol>
<li>/** </li>
</ol>
</li>
<li><ul>
<li>Virtualized support for map.get(); overridden in subclasses. </li>
</ul>
</li>
<li>*/ </li>
<li>Node<k,v> find(inth, Object k) {  // 增加find方法辅助get方法 </k,v></li>
<li>Node<k,v> e =  this  ; </k,v></li>
<li>if  (k !=  null  ) { </li>
<li>do  { </li>
<li>K ek; </li>
<li>if  (e.hash == h &amp;&amp;</li>
<li>((ek = e.key) == k || (ek !=  null  &amp;&amp; k.equals(ek)))) </li>
<li>returne; </li>
<li>}  while  ((e = e.next) !=  null  ); </li>
<li>} </li>
<li>returnnull; </li>
<li>} </li>
<li>} </li>
</ol>
<p>1.2 TreeNode  </p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// Nodes for use in TreeBins，链表&gt;8，才可能转为TreeNode. </li>
<li>// HashMap的TreeNode继承至LinkedHashMap.Entry；而这里继承至自己实现的Node，将带有next指针，便于treebin访问。 </li>
<li>static  final  class  TreeNode<k,v> extends  Node<k,v> { </k,v></k,v></li>
<li>TreeNode<k,v> parent;  // red-black tree links </k,v></li>
<li>TreeNode<k,v> left; </k,v></li>
<li>TreeNode<k,v> right; </k,v></li>
<li>TreeNode<k,v> prev;  // needed to unlink next upon deletion </k,v></li>
<li>boolean  red; </li>
<li><ol>
<li>TreeNode(inthash, K key, V val, Node<k,v> next, </k,v></li>
</ol>
</li>
<li>TreeNode<k,v> parent) { </k,v></li>
<li>super  (hash, key, val, next); </li>
<li>this  .parent = parent; </li>
<li>} </li>
<li><ol>
<li>Node<k,v> find(inth, Object k) { </k,v></li>
</ol>
</li>
<li>return  findTreeNode(h, k,  null  ); </li>
<li>} </li>
<li><ol>
<li>/** </li>
</ol>
</li>
<li><ul>
<li>Returns the TreeNode (or null if not found) for the given key </li>
</ul>
</li>
<li><ul>
<li>starting at given root. </li>
</ul>
</li>
<li>*/  // 查找hash为h，key为k的节点 </li>
<li>final  TreeNode<k,v> findTreeNode(  int  h, Object k, Class&lt;?&gt; kc) { </k,v></li>
<li>if  (k !=  null  ) {  // 比HMap增加判空 </li>
<li>TreeNode<k,v> p =  this  ; </k,v></li>
<li>do  { </li>
<li>intph, dir; K pk; TreeNode<k,v> q; </k,v></li>
<li>TreeNode<k,v> pl = p.left, pr = p.right; </k,v></li>
<li>if  ((ph = p.hash) &gt; h) </li>
<li>p = pl; </li>
<li>elseif (ph &lt; h) </li>
<li>p = pr; </li>
<li>elseif ((pk = p.key) == k || (pk !=  null  &amp;&amp; k.equals(pk))) </li>
<li>returnp; </li>
<li>elseif (pl ==  null  ) </li>
<li>p = pr; </li>
<li>elseif (pr ==  null  ) </li>
<li>p = pl; </li>
<li>elseif ((kc !=  null  || </li>
<li>(kc = comparableClassFor(k)) !=  null  ) &amp;&amp;</li>
<li>(dir = compareComparables(kc, k, pk)) !=  0  ) </li>
<li>p = (dir &lt; 0  ) ? pl : pr; </li>
<li>elseif ((q = pr.findTreeNode(h, k, kc)) !=  null  ) </li>
<li>returnq; </li>
<li>else </li>
<li>p = pl; </li>
<li>}  while  (p !=  null  ); </li>
<li>} </li>
<li>return  null  ; </li>
<li>} </li>
<li>} </li>
<li>// 和HashMap相比，这里的TreeNode相当简洁；ConcurrentHashMap链表转树时，并不会直接转，正如注释（Nodes for use in TreeBins）所说，只是把这些节点包装成TreeNode放到TreeBin中，再由TreeBin来转化红黑树。 </li>
</ol>
<p>1.3  TreeBin</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// TreeBin用于封装维护TreeNode，包含putTreeVal、lookRoot、UNlookRoot、remove、balanceInsetion、balanceDeletion等方法，这里只分析其构造函数。 </li>
<li>// 当链表转树时，用于封装TreeNode，也就是说，ConcurrentHashMap的红黑树存放的时TreeBin，而不是treeNode。 </li>
<li>TreeBin(TreeNode<k,v> b) { </k,v></li>
<li>super  (TREEBIN,  null  ,  null  ,  null  );  //hash值为常量TREEBIN=-2,表示roots of trees </li>
<li>this  .first = b; </li>
<li>TreeNode<k,v> r =  null  ; </k,v></li>
<li>for  (TreeNode<k,v> x = b, next; x !=  null  ; x = next) { </k,v></li>
<li>next = (TreeNode<k,v>)x.next; </k,v></li>
<li>x.left = x.right =  null  ; </li>
<li>if  (r ==  null  ) { </li>
<li>x.parent =  null  ; </li>
<li>x.red =  false  ; </li>
<li>r = x; </li>
<li>} </li>
<li>else  { </li>
<li>K k = x.key; </li>
<li>inth = x.hash; </li>
<li>Class&lt;?&gt; kc =  null  ; </li>
<li>for  (TreeNode<k,v> p = r;;) { </k,v></li>
<li>intdir, ph; </li>
<li>K pk = p.key; </li>
<li>if  ((ph = p.hash) &gt; h) </li>
<li>dir = -  1  ; </li>
<li>elseif (ph &lt; h) </li>
<li>dir =  1  ; </li>
<li>elseif ((kc ==  null  &amp;&amp;</li>
<li>(kc = comparableClassFor(k)) ==  null  ) || </li>
<li>(dir = compareComparables(kc, k, pk)) ==  0  ) </li>
<li>dir = tieBreakOrder(k, pk); </li>
<li>TreeNode<k,v> xp = p; </k,v></li>
<li>if  ((p = (dir &lt;=  0  ) ? p.left : p.right) ==  null  ) { </li>
<li>x.parent = xp; </li>
<li>if  (dir &lt;=  0  ) </li>
<li>xp.left = x; </li>
<li>else </li>
<li>xp.right = x; </li>
<li>r = balanceInsertion(r, x); </li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>this  .root = r; </li>
<li>assert  checkInvariants(root); </li>
<li>} </li>
</ol>
<p>1.4  treeifyBin</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>/** </li>
<li><ul>
<li>Replaces all linked nodes in bin at given index unless table is </li>
</ul>
</li>
<li><ul>
<li>too small, in which case resizes instead.链表转树 </li>
</ul>
</li>
<li>*/ </li>
<li>private  final  void  treeifyBin(Node<k,v>[] tab,  int  index) { </k,v></li>
<li>Node<k,v> b; intn, sc; </k,v></li>
<li>if  (tab !=  null  ) { </li>
<li>if  ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) </li>
<li>tryPresize(n &lt;&lt; 1  );  // 容量&lt;64，则table两倍扩容，不转树了 </li>
<li>else  if  ((b = tabAt(tab, index)) !=  null  &amp;&amp; b.hash &gt;=  0  ) { </li>
<li>synchronized  (b) {  // 读写锁 </li>
<li>if  (tabAt(tab, index) == b) { </li>
<li>TreeNode<k,v> hd =  null  , tl =  null  ; </k,v></li>
<li>for  (Node<k,v> e = b; e !=  null  ; e = e.next) { </k,v></li>
<li>TreeNode<k,v> p = </k,v></li>
<li>new  TreeNode<k,v>(e.hash, e.key, e.val, </k,v></li>
<li>null  ,  null  ); </li>
<li>if  ((p.prev = tl) ==  null  ) </li>
<li>hd = p; </li>
<li>else </li>
<li>tl.next = p; </li>
<li>tl = p; </li>
<li>} </li>
<li>setTabAt(tab, index,  new  TreeBin<k,v>(hd)); </k,v></li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
</ol>
<p>1.5  ForwardingNode</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// A node inserted at head of bins during transfer operations.连接两个table </li>
<li>// 并不是我们传统的包含key-value的节点，只是一个标志节点，并且指向nextTable，提供find方法而已。生命周期：仅存活于扩容操作且bin不为null时，一定会出现在每个bin的首位。 </li>
<li>static  final  class  ForwardingNode<k,v> extends  Node<k,v> { </k,v></k,v></li>
<li>final  Node<k,v>[] nextTable; </k,v></li>
<li>ForwardingNode(Node<k,v>[] tab) { </k,v></li>
<li>super  (MOVED,  null  ,  null  ,  null  );  // 此节点hash=-1，key、value、next均为null </li>
<li>this  .nextTable = tab; </li>
<li>} </li>
<li><ol>
<li>Node<k,v> find(  int  h, Object k) { </k,v></li>
</ol>
</li>
<li>// 查nextTable节点，outer避免深度递归 </li>
<li>outer:  for  (Node<k,v>[] tab = nextTable;;) { </k,v></li>
<li>Node<k,v> e; intn; </k,v></li>
<li>if  (k ==  null  || tab ==  null  || (n = tab.length) ==  0  || </li>
<li>(e = tabAt(tab, (n -  1  ) &amp; h)) ==  null  ) </li>
<li>returnnull; </li>
<li>for  (;;) {  // CAS算法多和死循环搭配！直到查到或null </li>
<li>int  eh; K ek; </li>
<li>if  ((eh = e.hash) == h &amp;&amp;</li>
<li>((ek = e.key) == k || (ek !=  null  &amp;&amp; k.equals(ek)))) </li>
<li>returne; </li>
<li>if  (eh &lt; 0  ) { </li>
<li>if  (e  instanceof  ForwardingNode) { </li>
<li>tab = ((ForwardingNode<k,v>)e).nextTable; </k,v></li>
<li>continue  outer; </li>
<li>} </li>
<li>else </li>
<li>return  e.find(h, k); </li>
<li>} </li>
<li>if  ((e = e.next) ==  null  ) </li>
<li>return  null  ; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
</ol>
<p>1.6  3个原子操作（调用频率很高）</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>@SuppressWarnings  (  “unchecked”  )  // ASHIFT等均为private static final </li>
<li>static  final  <k,v> Node<k,v> tabAt(Node<k,v>[] tab,  int  i) {  // 获取索引i处Node </k,v></k,v></k,v></li>
<li>return  (Node<k,v>)U.getObjectVolatile(tab, ((  long  )i &lt;&lt; ASHIFT) + ABASE); </k,v></li>
<li>} </li>
<li>// 利用CAS算法设置i位置上的Node节点（将c和table[i]比较，相同则插入v）。 </li>
<li>static  final  <k,v> boolean  casTabAt(Node<k,v>[] tab,  int  i, </k,v></k,v></li>
<li>Node<k,v> c, Node<k,v> v) { </k,v></k,v></li>
<li>return  U.compareAndSwapObject(tab, ((  long  )i &lt;&lt; ASHIFT) + ABASE, c, v); </li>
<li>} </li>
<li>// 设置节点位置的值，仅在上锁区被调用 </li>
<li>static  final  <k,v> void  setTabAt(Node<k,v>[] tab,  int  i, Node<k,v> v) { </k,v></k,v></k,v></li>
<li>U.putObjectVolatile(tab, ((  long  )i &lt;&lt; ASHIFT) + ABASE, v); </li>
<li>} </li>
</ol>
<p>1.7  Unsafe</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>//在源码的6277行到最后，有着ConcurrentHashMap中极为重要的几个属性（SIZECTL），unsafe静态块控制其修改行为。Java8中，大量运用CAS进行变量、属性的无锁修改，大大提高性能。 </li>
<li>// Unsafe mechanics </li>
<li>private  static  final  sun.misc.Unsafe U; </li>
<li>private  static  final  long  SIZECTL; </li>
<li>private  static  final  long  TRANSFERINDEX; </li>
<li>private  static  final  long  BASECOUNT; </li>
<li>private  static  final  long  CELLSBUSY; </li>
<li>private  static  final  long  CELLVALUE; </li>
<li>private  static  final  long  ABASE; </li>
<li>private  static  final  int  ASHIFT; </li>
<li><ol>
<li>static  { </li>
</ol>
</li>
<li>try  { </li>
<li>U = sun.misc.Unsafe.getUnsafe(); </li>
<li>Class&lt;?&gt; k = ConcurrentHashMap.  class  ; </li>
<li>SIZECTL = U.objectFieldOffset (k.getDeclaredField(  “sizeCtl”  )); </li>
<li>TRANSFERINDEX=U.objectFieldOffset(k.getDeclaredField(  “transferIndex”  )); </li>
<li>BASECOUNT = U.objectFieldOffset (k.getDeclaredField(  “baseCount”  )); </li>
<li>CELLSBUSY = U.objectFieldOffset (k.getDeclaredField(  “cellsBusy”  )); </li>
<li>Class&lt;?&gt; ck = CounterCell.  class  ; </li>
<li>CELLVALUE = U.objectFieldOffset (ck.getDeclaredField(  “value”  )); </li>
<li>Class&lt;?&gt; ak = Node[].  class  ; </li>
<li>ABASE = U.arrayBaseOffset(ak); </li>
<li>intscale = U.arrayIndexScale(ak); </li>
<li>if  ((scale &amp; (scale -  1  )) !=  0  ) </li>
<li>thrownew Error(  “data type scale not a power of two”  ); </li>
<li>ASHIFT =  31  - Integer.numberOfLeadingZeros(scale); </li>
<li>}  catch  (Exception e) { </li>
<li>thrownew Error(e); </li>
<li>} </li>
<li>} </li>
</ol>
<p>1.8  扩容相关</p>
<p>tryPresize  在  putAll以及treeifyBin中调用</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>private  final  void  tryPresize(  int  size) { </li>
<li>// 给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容 </li>
<li>int  c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1  )) ? MAXIMUM_CAPACITY : </li>
<li>tableSizeFor(size + (size &gt;&gt;&gt; 1  ) +  1  ); </li>
<li>int  sc; </li>
<li>while  ((sc = sizeCtl) &gt;=  0  ) {  //没有正在初始化或扩容，或者说表还没有被初始化 </li>
<li>Node<k,v>[] tab = table;  int  n; </k,v></li>
<li>if  (tab ==  null  || (n = tab.length) ==  0  ) { </li>
<li>n = (sc &gt; c) ? sc : c;  // 扩容阀值取较大者 </li>
<li>// 期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化 </li>
<li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc, -  1  )) { </li>
<li>try  { </li>
<li>if  (table == tab) { </li>
<li>@SuppressWarnings  (  “unchecked”  ) </li>
<li>Node<k,v>[] nt = (Node<k,v>[])  new  Node&lt;?,?&gt;[n]; </k,v></k,v></li>
<li>table = nt; </li>
<li>sc = n - (n &gt;&gt;&gt; 2  );  //无符号右移2位，此即0.75*n </li>
<li>} </li>
<li>}  finally  { </li>
<li>sizeCtl = sc;  // 更新扩容阀值 </li>
<li>} </li>
<li>} </li>
<li>}  // 若欲扩容值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 </li>
<li>else  if  (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) </li>
<li>break  ; </li>
<li>else  if  (tab == table) {  // table不为空，且在此期间其他线程未修改table </li>
<li>int  rs = resizeStamp(n); </li>
<li>if  (sc &lt; 0  ) { </li>
<li>Node<k,v>[] nt;  //RESIZE_STAMP_SHIFT=16,MAX_RESIZERS=2^15-1 </k,v></li>
<li>if  ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs +  1  || </li>
<li>sc == rs + MAX_RESIZERS || (nt = nextTable) ==  null  || </li>
<li>transferIndex &lt;=  0  ) </li>
<li>break  ; </li>
<li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc, sc +  1  )) </li>
<li>transfer(tab, nt); </li>
<li>} </li>
<li>else  if  (U.compareAndSwapInt(  this  , SIZECTL, sc, </li>
<li>(rs &lt;&lt; RESIZE_STAMP_SHIFT) +  2  )) </li>
<li>transfer(tab,  null  ); </li>
<li>} </li>
<li>} </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>private  static  final  int  tableSizeFor(  int  c){  //和HashMap一样,返回&gt;=n的最小2的自然数幂 </li>
<li>int  n = c -  1  ; </li>
<li>n |= n &gt;&gt;&gt; 1  ; </li>
<li>n |= n &gt;&gt;&gt; 2  ; </li>
<li>n |= n &gt;&gt;&gt; 4  ; </li>
<li>n |= n &gt;&gt;&gt; 8  ; </li>
<li>n |= n &gt;&gt;&gt; 16  ; </li>
<li>return  (n &lt; 0  ) ?  1  : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n +  1  ; </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>/** </li>
<li><ul>
<li>Returns the stamp bits for resizing a table of size n. </li>
</ul>
</li>
<li><ul>
<li>Must be negative when shifted left by RESIZE_STAMP_SHIFT. </li>
</ul>
</li>
<li>*/ </li>
<li>static  final  int  resizeStamp(  int  n) {  // 返回一个标志位 </li>
<li>return  Integer.numberOfLeadingZeros(n) | (  1  &lt;&lt; (RESIZE_STAMP_BITS -  1  )); </li>
<li>}  // numberOfLeadingZeros返回n对应32位二进制数左侧0的个数，如9（1001）返回28 </li>
<li>// RESIZE_STAMP_BITS=16,(左侧0的个数)|(2^15) </li>
</ol>
<p><strong> ConcurrentHashMap无锁多线程扩容，减少扩容时的时间消耗。 </strong></p>
<p><strong> transfer扩容操作 </strong> <strong> ： </strong> 单线程构建两倍容量的nextTable；允许多线程复制原table元素到nextTable。 </p>
<ol>
<li>为每个内核均分任务，并保证其不小于16； </li>
<li>若nextTab为null，则初始化其为原table的2倍； </li>
<li>死循环遍历，直到finishing。 </li>
</ol>
<ul>
<li>节点为空，则插入ForwardingNode； </li>
<li>链表节点（fh&gt;=0），分别插入nextTable的i和i+n的位置；【逆序链表？？】 </li>
<li>TreeBin节点（fh&lt;0），判断是否需要untreefi，分别插入nextTable的i和i+n的位置；【逆序树？？】 </li>
<li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。 </li>
</ul>
<p><strong> 以上说的都是单线程，  多线程  又是如何实现的呢？ </strong></p>
<p>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心  。  由于<br>给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此<br>便完成了多线程的复制工作，也解决了线程安全问题。</p>
<p>private  transient  volatile  Node<k,v>[]  nextTable  ;  //仅仅在扩容使用，并且此时非空</k,v></p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// 将table每一个bin（桶位）的Node移动或复制到nextTable </li>
<li>// 只在addCount(long x, int check)、helpTransfer、tryPresize中调用 </li>
<li>private  final  void  transfer(Node<k,v>[] tab, Node<k,v>[] nextTab) { </k,v></k,v></li>
<li>int  n = tab.length, stride; </li>
<li>// 每核处理的量小于16，则强制赋值16 </li>
<li>if  ((stride = (NCPU &gt; 1  ) ? (n &gt;&gt;&gt; 3  ) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) </li>
<li>stride = MIN_TRANSFER_STRIDE;  // subdivide range </li>
<li>if  (nextTab ==  null  ) {  // initiating </li>
<li>try  { </li>
<li>@SuppressWarnings  (  “unchecked”  ) </li>
<li>Node<k,v>[] nt = (Node<k,v>[])  new  Node&lt;?,?&gt;[n &lt;&lt; 1  ];  //两倍 </k,v></k,v></li>
<li>nextTab = nt; </li>
<li>}  catch  (Throwable ex) {  // try to cope with OOME </li>
<li>sizeCtl = Integer.MAX_VALUE; </li>
<li>return  ; </li>
<li>} </li>
<li>nextTable = nextTab; </li>
<li>transferIndex = n; </li>
<li>} </li>
<li>int  nextn = nextTab.length; </li>
<li>//连节点指针,标志位，fwd的hash值为-1，fwd.nextTable=nextTab。 </li>
<li>ForwardingNode<k,v> fwd=  new  ForwardingNode<k,v>(nextTab); </k,v></k,v></li>
<li>boolean  advance=  true  ;  //并发扩容的关键属性,等于true,说明此节点已经处理过 </li>
<li>boolean  finishing =  false  ;  // to ensure sweep before committing nextTab </li>
<li>for  (  int  i =  0  , bound =  0  ;;) {  // 死循环 </li>
<li>Node<k,v> f;  int  fh; </k,v></li>
<li>while  (advance) {  // 控制–i，遍历原hash表中的节点 </li>
<li>int  nextIndex, nextBound; </li>
<li>if  (–i &gt;= bound || finishing) </li>
<li>advance =  false  ; </li>
<li>else  if  ((nextIndex = transferIndex) &lt;=  0  ) { </li>
<li>i = -  1  ; </li>
<li>advance =  false  ; </li>
<li>}  //TRANSFERINDEX 即用CAS计算得到的transferIndex </li>
<li>else  if  (U.compareAndSwapInt </li>
<li>(  this  , TRANSFERINDEX, nextIndex, </li>
<li>nextBound = (nextIndex &gt; stride ? </li>
<li>nextIndex - stride :  0  ))) { </li>
<li>bound = nextBound; </li>
<li>i = nextIndex -  1  ; </li>
<li>advance =  false  ; </li>
<li>} </li>
<li>} </li>
<li>if  (i &lt; 0  || i &gt;= n || i + n &gt;= nextn) { </li>
<li>int  sc; </li>
<li>if  (finishing) {  // 所有节点复制完毕 </li>
<li>nextTable =  null  ; </li>
<li>table = nextTab; </li>
<li>sizeCtl = (n &lt;&lt; 1  ) - (n &gt;&gt;&gt; 1  );  //扩容阀值设为原来的1.5倍，即现在的0.75倍 </li>
<li>return  ;  // 仅有的2个跳出死循环出口之一 </li>
<li>}  //CAS更新扩容阈值,sc-1表明新加入一个线程参与扩容 </li>
<li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc = sizeCtl, sc -  1  )) { </li>
<li>if  ((sc -  2  ) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) </li>
<li>return  ;  // 仅有的2个跳出死循环出口之一 </li>
<li>finishing = advance =  true  ; </li>
<li>i = n;  // recheck before commit </li>
<li>} </li>
<li>} </li>
<li>else  if  ((f = tabAt(tab, i)) ==  null  )  //该节点为空，则插入ForwardingNode </li>
<li>advance = casTabAt(tab, i,  null  , fwd); </li>
<li>//遍历到ForwardingNode节点，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 </li>
<li>else  if  ((fh = f.hash) == MOVED)  // MOVED=-1，hash for fwd </li>
<li>advance =  true  ;  // already processed </li>
<li>else  { </li>
<li>synchronized  (f) {  //上锁 </li>
<li>if  (tabAt(tab, i) == f) { </li>
<li>Node<k,v> ln, hn;  //ln原位置节点，hn新位置节点 </k,v></li>
<li>if  (fh &gt;=  0  ) {  // 链表 </li>
<li>int  runBit = fh &amp; n;  // f.hash &amp; n </li>
<li>Node<k,v> lastRun = f;  // lastRun和p两个链表，逆序？？ </k,v></li>
<li>for  (Node<k,v> p = f.next; p !=  null  ; p = p.next) { </k,v></li>
<li>int  b = p.hash &amp; n;  // f.next.hash &amp; n </li>
<li>if  (b != runBit) { </li>
<li>runBit = b; </li>
<li>lastRun = p; </li>
<li>} </li>
<li>} </li>
<li>if  (runBit ==  0  ) { </li>
<li>ln = lastRun; </li>
<li>hn =  null  ; </li>
<li>} </li>
<li>else  { </li>
<li>hn = lastRun; </li>
<li>ln =  null  ; </li>
<li>} </li>
<li>for  (Node<k,v> p = f; p != lastRun; p = p.next) { </k,v></li>
<li>int  ph = p.hash; K pk = p.key; V pv = p.val; </li>
<li>if  ((ph &amp; n) ==  0  )  // 和HashMap确定扩容后的节点位置一样 </li>
<li>ln =  new  Node<k,v>(ph, pk, pv, ln); </k,v></li>
<li>else </li>
<li>hn =  new  Node<k,v>(ph, pk, pv, hn);  //新位置节点 </k,v></li>
<li>}  //类似HashMap，为何i+n？参见HashMap的笔记 </li>
<li>setTabAt(nextTab, i, ln);  //在nextTable[i]插入原节点 </li>
<li>setTabAt(nextTab, i + n, hn);  //在nextTable[i+n]插入新节点 </li>
<li>//在nextTable[i]插入forwardNode节点，表示已经处理过该节点 </li>
<li>setTabAt(tab, i, fwd); </li>
<li>//设置advance为true 返回到上面的while循环中 就可以执行–i操作 </li>
<li>advance =  true  ; </li>
<li>} </li>
<li>else  if  (f  instanceof  TreeBin) {  //树 </li>
<li>TreeBin<k,v> t = (TreeBin<k,v>)f; </k,v></k,v></li>
<li>TreeNode<k,v> lo =  null  , loTail =  null  ; </k,v></li>
<li>TreeNode<k,v> hi =  null  , hiTail =  null  ; </k,v></li>
<li>//lc、hc=0两计数器分别++记录原、新bin中TreeNode数量 </li>
<li>int  lc =  0  , hc =  0  ; </li>
<li>for  (Node<k,v> e = t.first; e !=  null  ; e = e.next) { </k,v></li>
<li>int  h = e.hash; </li>
<li>TreeNode<k,v> p =  new  TreeNode<k,v></k,v></k,v></li>
<li>(h, e.key, e.val,  null  ,  null  ); </li>
<li>if  ((h &amp; n) ==  0  ) { </li>
<li>if  ((p.prev = loTail) ==  null  ) </li>
<li>lo = p; </li>
<li>else </li>
<li>loTail.next = p; </li>
<li>loTail = p; </li>
<li>++lc; </li>
<li>} </li>
<li>else  { </li>
<li>if  ((p.prev = hiTail) ==  null  ) </li>
<li>hi = p; </li>
<li>else </li>
<li>hiTail.next = p; </li>
<li>hiTail = p; </li>
<li>++hc; </li>
<li>} </li>
<li>}  //扩容后树节点个数若&lt;=6，将树转链表 </li>
<li>ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : </li>
<li>(hc !=  0  ) ?  new  TreeBin<k,v>(lo) : t; </k,v></li>
<li>hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : </li>
<li>(lc !=  0  ) ?  new  TreeBin<k,v>(hi) : t; </k,v></li>
<li>setTabAt(nextTab, i, ln); </li>
<li>setTabAt(nextTab, i + n, hn); </li>
<li>setTabAt(tab, i, fwd); </li>
<li>advance =  true  ; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// 协助扩容方法。多线程下，当前线程检测到其他线程正进行扩容操作，则协助其一起扩容；（只有这种情况会被调用）从某种程度上说，其“优先级”很高，只要检测到扩容，就会放下其他工作，先扩容。 </li>
<li>// 调用之前，nextTable一定已存在。 </li>
<li>final  Node<k,v>[] helpTransfer(Node<k,v>[] tab, Node<k,v> f) { </k,v></k,v></k,v></li>
<li>Node<k,v>[] nextTab; intsc; </k,v></li>
<li>if  (tab !=  null  &amp;&amp; (finstanceof ForwardingNode) &amp;&amp;</li>
<li>(nextTab = ((ForwardingNode<k,v>)f).nextTable) !=  null  ) { </k,v></li>
<li>intrs = resizeStamp(tab.length);  //标志位 </li>
<li>while  (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</li>
<li>(sc = sizeCtl) &lt; 0  ) { </li>
<li>if  ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs +  1  || </li>
<li>sc == rs + MAX_RESIZERS || transferIndex &lt;=  0  ) </li>
<li>break  ; </li>
<li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc, sc +  1  )) { </li>
<li>transfer(tab, nextTab);  //调用扩容方法，直接进入复制阶段 </li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>return  nextTab; </li>
<li>} </li>
<li>return  table; </li>
<li>} </li>
</ol>
<p>2、 put相关：</p>
<p>理一下put的流程：</p>
<p>① <strong> 判空 </strong> ：null直接抛空指针异常；</p>
<p>② <strong> hash </strong> ：计算h=key.hashcode；调用spread计算hash=  (  h  ^  (  h  &gt;&gt;&gt; 16  ))  &amp;<br>HASH_BITS；</p>
<p>③ <strong> 遍历table </strong></p>
<ul>
<li>若table为空，则初始化，仅设置相关参数； </li>
<li>@@@计算当前key存放位置，即table的下标i=(n - 1) &amp; hash； </li>
<li>若待存放位置为null，casTabAt  无锁  插入； </li>
<li>若是forwarding nodes（检测到正在扩容），则helpTransfer（帮助其扩容）； </li>
<li>else（待插入位置非空且不是forward节点，即碰撞了），将头节点上锁（保证了线程安全）：区分链表节点和树节点，分别插入（遇到hash值与key值都与新节点一致的情况，只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点）； </li>
<li>若链表长度&gt;8，则treeifyBin转树（Note：若length&lt;64,直接tryPresize,两倍table.length;不转树）。 </li>
</ul>
<p>④ <strong> addCount(1L, binCount)。 </strong></p>
<p><strong> Note： </strong></p>
<p>1、put操作共计两次hash操作，再利用“与&amp;”操作计算Node的存放位置。</p>
<p>2、ConcurrentHashMap不允许key或value为null。</p>
<p>3、 <strong> addCount  (  long  x  ,  int  check  )  方法： </strong></p>
<p>①利用CAS快速更新baseCount的值；</p>
<p>②check&gt;=0.则检验是否需要扩容；  if  sizeCtl&lt;0（正在进行初始化或扩容操作）【nexttable<br>null等情况break；如果有线程正在扩容，则协助扩容】；  else if  仅当前线程在扩容，调用协助扩容函数，注其参数nextTable为null。</p>
<p>public  V put(K  key  , V  value  ) {</p>
<p>return  putVal  (  key  ,  value  ,  false  );</p>
<p>}</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>final  V <span style="background-color: rgb(255, 255, 51);">putVal</span>(K key, V value,  boolean  onlyIfAbsent) { </li>
<li>// 不允许key、value为空 </li>
<li>if  (key ==  null  || value ==  null  )  throw  new  NullPointerException(); </li>
<li>int  hash = spread(key.hashCode());  //返回(h^(h&gt;&gt;&gt;16))&amp;HASH_BITS </li>
<li>int  binCount =  0  ; </li>
<li>for  (Node<k,v>[] tab = table;;) {  // 死循环，直到插入成功 </k,v></li>
<li>Node<k,v> f;  int  n, i, fh; </k,v></li>
<li>if  (tab ==  null  || (n = tab.length) ==  0  ) </li>
<li>tab = initTable();  // table为空，初始化table </li>
<li>else  if  ((f = tabAt(tab, i = (n -  1  ) &amp; hash)) ==  null  ) {  // 索引处无值 </li>
<li>if  (casTabAt(tab, i,  null  , </li>
<li>new  Node<k,v>(hash, key, value,  null  ))) </k,v></li>
<li>break  ;  // no lock when adding to empty bin </li>
<li>} </li>
<li>else  if  ((fh = f.hash) == MOVED)  // MOVED=-1;//hash for forwarding nodes </li>
<li>tab = helpTransfer(tab, f);  //检测到正在扩容，则帮助其扩容 </li>
<li>else  { </li>
<li>V oldVal =  null  ; </li>
<li>synchronized  (f) {  // 节点上锁（hash值相同的链表的头节点） </li>
<li>if  (tabAt(tab, i) == f) { </li>
<li>if  (fh &gt;=  0  ) {  // 链表节点 </li>
<li>binCount =  1  ; </li>
<li>for  (Node<k,v> e = f;; ++binCount) { </k,v></li>
<li>K ek;  // hash和key相同，则修改value </li>
<li>if  (e.hash == hash &amp;&amp;</li>
<li>((ek = e.key) == key ||(ek !=  null  &amp;&amp; key.equals(ek)))) { </li>
<li>oldVal = e.val; </li>
<li>if  (!onlyIfAbsent)  //仅putIfAbsent()方法中onlyIfAbsent为true </li>
<li>e.val = value;  //putIfAbsent()包含key则返回get，否则put并返回 </li>
<li>break  ; </li>
<li>} </li>
<li>Node<k,v> pred = e; </k,v></li>
<li>if  ((e = e.next) ==  null  ) {  //已遍历到链表尾部，直接插入 </li>
<li>pred.next =  new  Node<k,v>(hash, key, value,  null  ); </k,v></li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>else  if  (f  instanceof  TreeBin) {  // 树节点 </li>
<li>Node<k,v> p; </k,v></li>
<li>binCount =  2  ; </li>
<li>if  ((p = ((TreeBin<k,v>)f).putTreeVal(hash, key,value)) !=  null  ) { </k,v></li>
<li>oldVal = p.val; </li>
<li>if  (!onlyIfAbsent) </li>
<li>p.val = value; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>if  (binCount !=  0  ) { </li>
<li>if  (binCount &gt;= TREEIFY_THRESHOLD)  //实则是&gt;8,执行else,说明该桶位本就有Node </li>
<li>treeifyBin(tab, i);  //若length&lt;64,直接tryPresize,两倍table.length;不转树 </li>
<li>if  (oldVal !=  null  ) </li>
<li>return  oldVal; </li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>addCount(1L, binCount); </li>
<li>return  null  ; </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// Initializes table, using the size recorded in sizeCtl. </li>
<li>private  final  Node<k,v>[] <span style="background-color: rgb(255, 255, 51);">initTable</span>() {  // 仅仅设置参数，并未实质初始化 </k,v></li>
<li>Node<k,v>[] tab; intsc; </k,v></li>
<li>while  ((tab = table) ==  null  || tab.length ==  0  ) { </li>
<li>if  ((sc = sizeCtl) &lt; 0  )  // 其他线程正在初始化，此线程挂起 </li>
<li>Thread.yield();  // lost initialization race; just spin </li>
<li>//CAS方法把sizectl置为-1，表示本线程正在进行初始化 </li>
<li>elseif (U.compareAndSwapInt(  this  , SIZECTL, sc, -  1  )) { </li>
<li>try  { </li>
<li>if  ((tab = table) ==  null  || tab.length ==  0  ) { </li>
<li>intn = (sc &gt; 0  ) ? sc : DEFAULT_CAPACITY;  //DEFAULT_CAPACITY=16 </li>
<li>@SuppressWarnings  (  “unchecked”  ) </li>
<li>Node<k,v>[] nt = (Node<k,v>[])  new  Node&lt;?,?&gt;[n]; </k,v></k,v></li>
<li>table = tab = nt; </li>
<li>sc = n - (n &gt;&gt;&gt; 2  );  // 扩容阀值，0.75*n </li>
<li>} </li>
<li>}  finally  { </li>
<li>sizeCtl = sc; </li>
<li>} </li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>return  tab; </li>
<li>} </li>
</ol>
<p>3、 get、contains相关</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  V <span style="background-color: rgb(255, 255, 51);">get</span>(Object key) { </li>
<li>Node<k,v>[] tab; Node<k,v> e, p; intn, eh; K ek; </k,v></k,v></li>
<li>inth = spread(key.hashCode()); </li>
<li>if  ((tab = table) !=  null  &amp;&amp; (n = tab.length) &gt; 0  &amp;&amp;</li>
<li>(e = tabAt(tab, (n -  1  ) &amp; h)) !=  null  ) {  //tabAt(i),获取索引i处Node </li>
<li>if  ((eh = e.hash) == h) { </li>
<li>if  ((ek = e.key) == key || (ek !=  null  &amp;&amp; key.equals(ek))) </li>
<li>returne.val; </li>
<li>} </li>
<li>elseif (eh &lt; 0  )  // 树 </li>
<li>return  (p = e.find(h, key)) !=  null  ? p.val :  null  ; </li>
<li>while  ((e = e.next) !=  null  ) {  // 链表 </li>
<li>if  (e.hash == h &amp;&amp;</li>
<li>((ek = e.key) == key || (ek !=  null  &amp;&amp; key.equals(ek)))) </li>
<li>returne.val; </li>
<li>} </li>
<li>} </li>
<li>return  null  ; </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  boolean  containsKey(Object key) {  return  get(key) !=  null  ;} </li>
<li>public  boolean  containsValue(Object value) {} </li>
</ol>
<p>理一下get的流程：</p>
<p>①spread计算hash值；</p>
<p>②table不为空；</p>
<p>③tabAt(i)处桶位不为空；</p>
<p>④check first，是则返回当前Node的value；否则分别根据树、链表查询。</p>
<p>4、 Size相关：</p>
<p>由于ConcurrentHashMap在统计size时  可能正被  多个线程操作，而我们又不可能让他停下来让我们计算，所以只能计量一个估计值。</p>
<p>计数辅助：</p>
<p>//  Table of counter cells. When non-null, size is a power of 2</p>
<p>private  transient  volatile  CounterCell[]  counterCells  ;</p>
<p>@  sun.misc.  Contended  static  final  class  CounterCell  {</p>
<p>volatile  long  value  ;</p>
<p>CounterCell(  long  x  ) {  value  =  x  ; }</p>
<p>}</p>
<p>final  long  sumCount  (){</p>
<p>CounterCell  as  [] =  counterCells  ;</p>
<p>long  sum  =  baseCount  ;</p>
<p>if  (  as  !=  null  ){</p>
<p>for  (  int  i  = 0;  i  &lt; as  .  length  ;  i  ++){</p>
<p>CounterCell  a  ;</p>
<p>if  ((  a  =  as  [  i  ]) !=  null  )</p>
<p>sum  +=  a  .  value  ;</p>
<p>}</p>
<p>}</p>
<p>return  sum  ;</p>
<p>}</p>
<p>private  final  void  full  AddCount  (  long  x  ,  boolean  wasUncontended<br>) {}</p>
<p>public  int  size() {  // 旧版本方法，和推荐的mappingCount返回的值基本无区别</p>
<p>long  n  = sumCount();</p>
<p>return  ((  n  &lt; 0L) ? 0 :</p>
<p>(  n  &gt; (  long  )Integer.  MAX_VALUE  ) ? Integer.  MAX_VALUE  :</p>
<p>(  int  )  n  );</p>
<p>}</p>
<p>// 返回Mappings中的元素个数，官方建议用来  替代size  。此方法返回的是一个估计值；如果sumCount时有线程插入或删除，实际数量是和<br>mappingCount  不同的。since 1.8</p>
<p>public  long  mappingCount  () {</p>
<p>long  n  = sumCount();</p>
<p>return  (  n  &lt; 0L) ? 0L :  n  ;  // ignore transient negative values</p>
<p>}</p>
<p>private  transient  volatile  long  baseCount  ;</p>
<p>//ConcurrentHashMap中元素个数,基于CAS无锁更新,但返回的不一定是当前Map的真实元素个数。</p>
<p>5、remove、clear相关：</p>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  void  clear() {  // 移除所有元素 </li>
<li>long  delta = 0L;  // negative number of deletions </li>
<li>inti =  0  ; </li>
<li>Node<k,v>[] tab = table; </k,v></li>
<li>while  (tab !=  null  &amp;&amp; i &lt; tab.length) { </li>
<li>intfh; </li>
<li>Node<k,v> f = tabAt(tab, i); </k,v></li>
<li>if  (f ==  null  )  // 为空，直接跳过 </li>
<li>++i; </li>
<li>else  if  ((fh = f.hash) == MOVED) {  //检测到其他线程正对其扩容 </li>
<li>//则协助其扩容，然后重置计数器，重新挨个删除元素，避免删除了元素，其他线程又新增元素。 </li>
<li>tab = helpTransfer(tab, f); </li>
<li>i =  0  ;  // restart </li>
<li>} </li>
<li>else  { </li>
<li>synchronized  (f) {  // 上锁 </li>
<li>if  (tabAt(tab, i) == f) {  // 其他线程没有在此期间操作f </li>
<li>Node<k,v> p = (fh &gt;=  0  ? f : </k,v></li>
<li>(finstanceof TreeBin) ? </li>
<li>((TreeBin<k,v>)f).first :  null  ); </k,v></li>
<li>while  (p !=  null  ) {  // 首先删除链、树的末尾元素，避免产生大量垃圾 </li>
<li>--delta; </li>
<li>p = p.next; </li>
<li>} </li>
<li>setTabAt(tab, i++,  null  );  // 利用CAS无锁置null </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>if  (delta != 0L) </li>
<li>addCount(delta, -  1  );  // 无实际意义，参数check&lt;=1，直接return。 </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  V remove(Object key) {  // key为null，将在计算hashCode时报空指针异常 </li>
<li>return  replaceNode(key,  null  ,  null  ); </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  boolean  remove(Object key, Object value) { </li>
<li>if  (key ==  null  ) </li>
<li>thrownew NullPointerException(); </li>
<li>returnvalue !=  null  &amp;&amp; replaceNode(key,  null  , value) !=  null  ; </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>// remove核心方法，注意，这里的cv才是key-value中的value！ </li>
<li>final  V replaceNode(Object key, V value, Object cv) { </li>
<li>inthash = spread(key.hashCode()); </li>
<li>for  (Node<k,v>[] tab = table;;) { </k,v></li>
<li>Node<k,v> f; intn, i, fh; </k,v></li>
<li>if  (tab ==  null  || (n = tab.length) ==  0  || </li>
<li>(f = tabAt(tab, i = (n -  1  ) &amp; hash)) ==  null  ) </li>
<li>break  ;  // 该桶位第一个元素为空，直接跳过 </li>
<li>elseif ((fh = f.hash) == MOVED) </li>
<li>tab = helpTransfer(tab, f);  // 先协助扩容再说 </li>
<li>else  { </li>
<li>V oldVal =  null  ; </li>
<li>booleanvalidated =  false  ; </li>
<li>synchronized  (f) { </li>
<li>if  (tabAt(tab, i) == f) { </li>
<li>if  (fh &gt;=  0  ) { </li>
<li>validated =  true  ; </li>
<li>//pred没看出来有什么用，全是别人赋值给他，他却不影响其他参数 </li>
<li>for  (Node<k,v> e = f, pred =  null  ;;) { </k,v></li>
<li>K ek; </li>
<li>if  (e.hash == hash &amp;&amp;((ek = e.key) == key || </li>
<li>(ek !=  null  &amp;&amp; key.equals(ek)))){  //hash且可以相等 </li>
<li>V ev = e.val; </li>
<li>// value为null或value和查到的值相等 </li>
<li>if  (cv ==  null  || cv == ev || </li>
<li>(ev !=  null  &amp;&amp; cv.equals(ev))) { </li>
<li>oldVal = ev; </li>
<li>if  (value !=  null  )  // replace中调用 </li>
<li>e.val = value; </li>
<li>elseif (pred !=  null  ) </li>
<li>pred.next = e.next; </li>
<li>else </li>
<li>setTabAt(tab, i, e.next); </li>
<li>} </li>
<li>break  ; </li>
<li>} </li>
<li>pred = e; </li>
<li>if  ((e = e.next) ==  null  ) </li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>elseif (finstanceof TreeBin) {  // 以树的方式find、remove </li>
<li>validated =  true  ; </li>
<li>TreeBin<k,v> t = (TreeBin<k,v>)f; </k,v></k,v></li>
<li>TreeNode<k,v> r, p; </k,v></li>
<li>if  ((r = t.root) !=  null  &amp;&amp;</li>
<li>(p = r.findTreeNode(hash, key,  null  )) !=  null  ) { </li>
<li>V pv = p.val; </li>
<li>if  (cv ==  null  || cv == pv || </li>
<li>(pv !=  null  &amp;&amp; cv.equals(pv))) { </li>
<li>oldVal = pv; </li>
<li>if  (value !=  null  ) </li>
<li>p.val = value; </li>
<li>elseif (t.removeTreeNode(p)) </li>
<li>setTabAt(tab, i, untreeify(t.first)); </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>if  (validated) { </li>
<li>if  (oldVal !=  null  ) { </li>
<li>if  (value ==  null  ) </li>
<li>addCount(-1L, -  1  ); </li>
<li>returnoldVal; </li>
<li>} </li>
<li>break  ; </li>
<li>} </li>
<li>} </li>
<li>} </li>
<li>return  null  ; </li>
<li>} </li>
</ol>
<p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p>
<p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片">
</a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片">
</a></p>
<ol>
<li>public  boolean  replace(K key, V oldValue, V newValue) {} </li>
</ol>
<p>6、其他函数：</p>
<p>public  boolean  isEmpty  () {</p>
<p>return  sumCount() &lt;= 0L;  // ignore transient negative values</p>
<p>}</p>
<p>参考资料:</p>
<p><a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener"> http://ifeve.com/concurrenthashmap/  </a></p>
<p><a href="http://ifeve.com/java-
concurrent-hashmap-2/" target="_blank" rel="noopener"> http://ifeve.com/java-concurrent-hashmap-2/ </a></p>
<p>、、、、、、、、、</p>
<p><a href="http://ashkrit.blogspot.com/2014/12/what-is-
new-in-java8-concurrenthashmap.html" target="_blank" rel="noopener"> http://ashkrit.blogspot.com/2014/12/what-is-new-in-<br>java8-concurrenthashmap.html  </a></p>
<p><a href="http://blog.csdn.net/u010723709/article/details/48007881" target="_blank" rel="noopener"> http://blog.csdn.net/u010723709/article/details/48007881
</a></p>
<p><a href="http://yucchi.jp/blog/?p=2048" target="_blank" rel="noopener"> http://yucchi.jp/blog/?p=2048  </a></p>
<p><a href="http://blog.csdn.net/q291611265/article/details/47985145" target="_blank" rel="noopener"> http://blog.csdn.net/q291611265/article/details/47985145
</a></p>
<p>、、、、、、、、、、</p>
<p>SynchronizedMap： <a href="http://blog.sina.com.cn/s/blog_5157093c0100hm3y.html" target="_blank" rel="noopener"> http://blog.sina.com.cn/s/blog_5157093c0100hm3y.html
</a></p>
<p><a href="http://blog.csdn.net/yangfanend/article/details/7165742" target="_blank" rel="noopener"> http://blog.csdn.net/yangfanend/article/details/7165742
</a></p>
<p><a href="http://blog.csdn.net/xuefeng0707/article/details/40797085" target="_blank" rel="noopener"> http://blog.csdn.net/xuefeng0707/article/details/40797085
</a></p>
<pre><code>&lt;a target=_blank id=&quot;L1&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L1&quot; rel=&quot;#L1&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  1&lt;/a&gt;
&lt;a target=_blank id=&quot;L2&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L2&quot; rel=&quot;#L2&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  2&lt;/a&gt;
&lt;a target=_blank id=&quot;L3&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L3&quot; rel=&quot;#L3&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  3&lt;/a&gt;
&lt;a target=_blank id=&quot;L4&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L4&quot; rel=&quot;#L4&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  4&lt;/a&gt;
&lt;a target=_blank id=&quot;L5&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L5&quot; rel=&quot;#L5&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  5&lt;/a&gt;
&lt;a target=_blank id=&quot;L6&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L6&quot; rel=&quot;#L6&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  6&lt;/a&gt;
&lt;a target=_blank id=&quot;L7&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L7&quot; rel=&quot;#L7&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  7&lt;/a&gt;
&lt;a target=_blank id=&quot;L8&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L8&quot; rel=&quot;#L8&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  8&lt;/a&gt;
&lt;a target=_blank id=&quot;L9&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L9&quot; rel=&quot;#L9&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  9&lt;/a&gt;
&lt;a target=_blank id=&quot;L10&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L10&quot; rel=&quot;#L10&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt; 10&lt;/a&gt;
&lt;a target=_blank id=&quot;L11&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L11&quot; rel=&quot;#L11&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt; 11&lt;/a&gt;


ArrayList源码分析（jdk1.8）：http://blog.csdn.net/u010887744/article/details/49496093

HashMap源码分析（jdk1.8）：http://write.blog.csdn.net/postedit/50346257

ConcurrentHashMap源码分析--Java8：http://blog.csdn.net/u010887744/article/details/50637030




每篇文章都包含 有道云笔记地址，可直接保存。




在线查阅JDK源码：

JDK8：https://github.com/zxiaofan/JDK1.8-Src

JDK7：https://github.com/zxiaofan/JDK_Src_1.7




史上最全Java集合关系图：http://blog.csdn.net/u010887744/article/details/50575735
</code></pre><h5 id="来自CODE的代码片"><a href="#来自CODE的代码片" class="headerlink" title=" 来自CODE的代码片 "></a><a href="https://code.csdn.net/snippets/1574871" target="_blank" rel="noopener"> 来自CODE的代码片 </a></h5><p>SourceCode</p>
<pre><code>&lt;a target=_blank id=&quot;L1&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L1&quot; rel=&quot;#L1&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  1&lt;/a&gt;
&lt;a target=_blank id=&quot;L2&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L2&quot; rel=&quot;#L2&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  2&lt;/a&gt;
&lt;a target=_blank id=&quot;L3&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L3&quot; rel=&quot;#L3&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  3&lt;/a&gt;
&lt;a target=_blank id=&quot;L4&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L4&quot; rel=&quot;#L4&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  4&lt;/a&gt;
&lt;a target=_blank id=&quot;L5&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L5&quot; rel=&quot;#L5&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  5&lt;/a&gt;
&lt;a target=_blank id=&quot;L6&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L6&quot; rel=&quot;#L6&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  6&lt;/a&gt;
&lt;a target=_blank id=&quot;L7&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L7&quot; rel=&quot;#L7&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  7&lt;/a&gt;
&lt;a target=_blank id=&quot;L8&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L8&quot; rel=&quot;#L8&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  8&lt;/a&gt;
&lt;a target=_blank id=&quot;L9&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L9&quot; rel=&quot;#L9&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  9&lt;/a&gt;
&lt;a target=_blank id=&quot;L10&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L10&quot; rel=&quot;#L10&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt; 10&lt;/a&gt;


转载请注明出处，谢谢。




【 CSDN 】：csdn.zxiaofan.cn

【GitHub】：github.zxiaofan.cn




域名备案中，上述网址极不稳定，GitHub请直接访问【github.com/zxiaofan】




如有任何问题，欢迎留言。祝君好运！

Life is all about choices！ 

将来的你一定会感激现在拼命的自己！
</code></pre><h5 id="来自CODE的代码片-1"><a href="#来自CODE的代码片-1" class="headerlink" title=" 来自CODE的代码片 "></a><a href="https://code.csdn.net/snippets/637064" target="_blank" rel="noopener"> 来自CODE的代码片 </a></h5><p>txt</p>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2017/11/11/Java集合：HashMap使用详解及源码分析/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2017/11/11/Java集合：集合框架/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2017-11-11 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/分类/Java并发编程/">Java并发编程<span>9</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 shike
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
   </html>
