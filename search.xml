<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java中的自动装箱与拆箱</title>
      <link href="/2018/03/13/Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
      <content type="html"><![CDATA[<p><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">Java 中的自动装箱与拆箱原文</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>JDK 1.5以后提供了自动装箱、拆箱功能，也就是我们在基本类型和包装类型转换的时候不再需要显示调用Integer.valueOf()、Integer.intValue()等方法。</li><li>基本类型和<strong>对应的</strong>包装类型之间在赋值以及方法调用传参时发生自动装箱、拆箱。</li><li>如果有基本类型参数和对应包装类型参数两个重载方法时，参数不发生自动装箱、拆箱。</li><li>循环体内如果使用包装类型作为局部变量，可能会造成产生大量的中间对象。</li><li>包装类型可以和基本类型进行值得比较。</li><li>包装类型“==”操作判断的是两个对象是否为同一个对象，“equals”方法比较的是对象对应的基本类型值是否相等。</li><li>Integer会缓存值-128~127之间的对象。两个Integer对象如果值在-128~127之间，并且值相等，那么这两个对象是同一个对象。Long、Byte、Short对象缓存也是-128~127之间，Character为0-127。</li><li>包装类型没初始化或者为Null的情况下自动拆箱会报NPE。</li></ul>]]></content>
      
      <categories>
          
          <category> 技术文摘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 自动装箱 </tag>
            
            <tag> Integer 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何进行高质量的代码审查-来自LinkedIn的实践提示</title>
      <link href="/2018/03/12/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5-%E6%9D%A5%E8%87%AALinkedIn%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%8F%90%E7%A4%BA/"/>
      <content type="html"><![CDATA[<p><a href="https://thenewstack.io/linkedin-code-review/" target="_blank" rel="noopener">LinkedIn 代码审查实践原文 LinkedIn’s Tips for Highly Effective Code Review</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>LinkedIn将Code Review作为员工日常工作之一，并且是员工晋升的重要考核因素。借此，LinkedIn建立了健康的反馈文化：工程师在各个领域都对提出和接受反馈持开放态度。</li><li>Do I Understand the “Why”?<br>负责审查的同学必须提前了解到代码改动的原因，而不是从代码改动中推测原因。</li><li>Am I Giving Positive Feedback?<br>代码审查不仅要给出代码的问题，更要尽量给出代码写的优秀的地方，这样能给工程师带来鼓励，使其更有动力。</li><li>Is My Code Review Comment Explained Well?<br>提出的Review意见必须是能够使被review的同学清晰理解的。宁可花费大量文字去过度解释review意见，也绝不简单输入可能会造成别人理解困惑的意见。</li><li>Do I Appreciate the Submitter’s Effort?<br>我们需要充分肯定和尊重工程师所做的努力，即使代码有需要改进的地方。这有助于建立起一个强大的、具有很高积极性的团队。</li><li>Would This Review Comment Be Useful to Me?<br>确保我们提出的Review意见都是有用的，如果我们自己都觉得没用，那么只会给被审查人带来额外的负担。例如：代码格式问题，这个需要通过自动化工具来解决而不是通过review来解决。</li><li>Is the “Testing Done” Section Thorough Enough?<br>提交Review的代码必须经过充分的测试，这个充分的测试根据修改的复杂度而不同。</li><li>Am I Too Pedantic in My Review?<br>防止大量不重要的小修改意见淹没重要的review意见</li></ul>]]></content>
      
      <categories>
          
          <category> 技术文摘 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：阻塞队列及实现生产者-消费者模式</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8F%8A%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="1-什么是阻塞队列"><a href="#1-什么是阻塞队列" class="headerlink" title="1 什么是阻塞队列"></a>1 什么是阻塞队列</h2><p>JDK 1.5的java.util.concurrent包提供了多种阻塞队列。阻塞队列相对于PriorityQueue、LinkedList等非阻塞队列的特<br>点是提供了，队列阻塞的操作，优化了队列为空向队列取数据或者队列满向队列加数据时的阻塞操作。 <strong> 以生产者-<br>消费者模式为例，当队列为空时消费者线程会被挂起，等到队列中有数据时会自动的恢复并消费。 </strong><br><!--阅读全文--></p><h3 id="1-1-常见的阻塞队列"><a href="#1-1-常见的阻塞队列" class="headerlink" title="1.1 常见的阻塞队列"></a>1.1 常见的阻塞队列</h3><p>BlockingQueue接口的主要实现有如下几种：<br><strong> ArrayBlockingQueue </strong> ：基于数组的有界阻塞队列，构造时可以指定队列大小，默认为非公平（不保证等待最久的任务最先处理）。<br><strong> LinkedBlockingQueue </strong> ：基于链表的有界阻塞队列，如果不指定大小则默认为Integer.MAX_VALUE，基本可以认为是无界的。<br><strong> PriorityBlockingQueue </strong> ：优先级排序的无界阻塞队列，元素出队列的顺序按照优先级排序。<br><strong> DelayQueue </strong> ：基于优先级队列的无界阻塞队列。队列中的元素只有到达规定的延时才能从队列中取出。<br><strong> SynchronousQueue </strong> ：不存储元素的阻塞队列，只有前一个将队列中的元素取走时才能加入新的元素。 </p><h3 id="1-2-阻塞队列常见的方法"><a href="#1-2-阻塞队列常见的方法" class="headerlink" title="1.2 阻塞队列常见的方法"></a>1.2 阻塞队列常见的方法</h3><p>常见的非阻塞队列的操作列表如下：<br><strong> add(E e) </strong> :将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；<br><strong> remove() </strong> ：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；<br><strong> offer(E e) </strong> ：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；<br><strong> poll() </strong> ：移除并获取队首元素，若成功，则返回队首元素；否则返回null；<br><strong> peek() </strong> ：获取队首元素，若成功，则返回队首元素；否则返回null<br>阻塞队列实现了非阻塞队列的操作方法，为了实现“阻塞”提供了take和put方法。<br><strong> take() </strong> ：获取并移除队首元素，如果队列为空则阻塞直到队列中有元素。<br><strong> put() </strong> ：向队尾添加元素，如果队列满则等待直到可以添加。 </p><h2 id="2-LinkedBlockingQueue源码分析"><a href="#2-LinkedBlockingQueue源码分析" class="headerlink" title="2 LinkedBlockingQueue源码分析"></a>2 LinkedBlockingQueue源码分析</h2><p>LinkedBlockingQueue是阻塞队列中比较常用的，ThreadPoolExecutor类的实现中多是用的这个队列。下面通过源码分下阻塞队列的工作<br>原理。</p><h3 id="2-1-构造方法源码分析"><a href="#2-1-构造方法源码分析" class="headerlink" title="2.1 构造方法源码分析"></a>2.1 构造方法源码分析</h3><p>LinkedBlockingQueue共有三个构造方法，分别功能为默认大小，指定大小以及带初始化的构造方法。</p><pre><code>/**     * Creates a {@code LinkedBlockingQueue} with a capacity of     * {@link Integer#MAX_VALUE}.     */    public LinkedBlockingQueue() {        this(Integer.MAX_VALUE); //无参的构造函数,最大容量为Integer(4字节)的最大表示值    }    /**     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.     *     * @param capacity the capacity of this queue     * @throws IllegalArgumentException if {@code capacity} is not greater     *         than zero     */    public LinkedBlockingQueue(int capacity) { //指定容量的构造函数,大小为capacity        if (capacity &lt;= 0) throw new IllegalArgumentException();        this.capacity = capacity;        last = head = new Node&lt;E&gt;(null);    }    /**     * Creates a {@code LinkedBlockingQueue} with a capacity of     * {@link Integer#MAX_VALUE}, initially containing the elements of the     * given collection,     * added in traversal order of the collection&apos;s iterator.     *     * @param c the collection of elements to initially contain     * @throws NullPointerException if the specified collection or any     *         of its elements are null     */    public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) { //带初始化的构造方法,可以将指定集合中的元素初始化到阻塞队列中        this(Integer.MAX_VALUE);  //最大容量为Integer(4字节)的最大表示值         final ReentrantLock putLock = this.putLock;        putLock.lock(); // Never contended, but necessary for visibility        try {            int n = 0;            for (E e : c) {                if (e == null)                    throw new NullPointerException();                if (n == capacity)                    throw new IllegalStateException(&quot;Queue full&quot;);                enqueue(new Node&lt;E&gt;(e));                ++n;            }            count.set(n);        } finally {            putLock.unlock();        }    }}</code></pre><h3 id="2-2-put方法源码分析"><a href="#2-2-put方法源码分析" class="headerlink" title="2.2 put方法源码分析"></a>2.2 put方法源码分析</h3><p>put方法内部通过Condition的await和signal方法实现了线程之间的同步，和使用线程同步实现生产者消费者的代码逻辑差不多。同步队列采用了两把锁<br>，读锁（takeLock）和写锁（putLock）。</p><pre><code>/** * Inserts the specified element at the tail of this queue, waiting if * necessary for space to become available. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    // Note: convention in all put/take/etc is to preset local var    // holding count negative to indicate failure unless set.    int c = -1;    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock; //定义可重入   写锁    final AtomicInteger count = this.count; //原子类    putLock.lockInterruptibly(); //进入临界区,他和lock的区别是lockInterruptibly不处理中断而是向上层抛出异常    try {        /*         * Note that count is used in wait guard even though it is         * not protected by lock. This works because count can         * only decrease at this point (all other puts are shut         * out by lock), and we (or some other waiting put) are         * signalled if it ever changes from capacity. Similarly         * for all other uses of count in other wait guards.         */        while (count.get() == capacity) { //容量已满,线程进入阻塞状态,交出锁并且交出CPU            notFull.await();  //写锁的Condition        }        enqueue(node); //加入队列        c = count.getAndIncrement();        if (c + 1 &lt; capacity) //队列未满,唤醒一个等待写入的线程            notFull.signal();    } finally {        putLock.unlock();    }    if (c == 0) //队列第一次不为空,唤醒一个等待读取的线程        signalNotEmpty(); }</code></pre><h3 id="2-3-take方法源码分析"><a href="#2-3-take方法源码分析" class="headerlink" title="2.3 take方法源码分析"></a>2.3 take方法源码分析</h3><pre><code>public E take() throws InterruptedException {    E x;    int c = -1;    final AtomicInteger count = this.count;    final ReentrantLock takeLock = this.takeLock; //定义可重入锁  读锁    takeLock.lockInterruptibly(); //进入临界区,他和lock的区别是lockInterruptibly不处理中断而是向上层抛出异常    try {        while (count.get() == 0) { //如果队列为空, 读取线程进入阻塞状态,交出读锁和CPU            notEmpty.await();        }        x = dequeue(); //获取队首元素        c = count.getAndDecrement();        if (c &gt; 1) //如果取完队列中还存在数据,则唤醒其他等待读取的线程            notEmpty.signal();    } finally {        takeLock.unlock();    }    if (c == capacity) //没取之前队列为满的,取完之后要唤醒一个写入线程        signalNotFull();    return x;}</code></pre><h2 id="3-生产者-消费者模式实现"><a href="#3-生产者-消费者模式实现" class="headerlink" title="3 生产者-消费者模式实现"></a>3 生产者-消费者模式实现</h2><p>使用阻塞队列实现生产者-<br>消费者模式不需要我们自己编码控制读写线程的阻塞和唤醒操作，由上节分析的take()、put()方法可知，阻塞队列内部替我们实现了线程的阻塞和唤醒操作。</p><pre><code>public class BlockingQueue {    private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;(); //阻塞队列    public static class Consumer implements Runnable {        @Override        public void run() {            try {                    Integer element = queue.take();                    System.out.println(Thread.currentThread().getName() + &quot;消费了一个产品...&quot;);            } catch (InterruptedException e) {}        }    }    public static class Producer implements Runnable {        @Override        public void run() {            try {                queue.put(1);                System.out.println(Thread.currentThread().getName() + &quot;生产了一个产品...&quot;);            } catch (InterruptedException e) {}        }    }    public static void main(String[] args) {        ExecutorService comsumerPool = Executors.newSingleThreadExecutor();        ExecutorService producerPool = Executors.newSingleThreadExecutor();        Producer producer = new Producer();        Consumer consumer = new Consumer();        int i = 0;        while (true) {            comsumerPool.execute(consumer);            producerPool.execute(producer);            if (i++ &gt; 200) {                break;            }        }        try {            TimeUnit.SECONDS.sleep(10);        } catch (InterruptedException e) {}        comsumerPool.shutdownNow();        producerPool.shutdownNow();    }}</code></pre><p>部分执行结果如下：</p><pre><code>pool-2-thread-1生产了一个产品...pool-2-thread-1生产了一个产品...pool-2-thread-1生产了一个产品...pool-2-thread-1生产了一个产品...pool-2-thread-1生产了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...pool-1-thread-1消费了一个产品...pool-2-thread-1生产了一个产品...</code></pre><p>由执行结果看出，阻塞队列很好的完成了生产者消费者模型，并且代码实现简单。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/dolphin0520/p/3932906.html" target="_blank" rel="noopener"> http://www.cnblogs.com/dolphin0520/p/3932906.html</a><br>[2] <a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="noopener"> http://www.infoq.com/cn/articles/java-blocking-queue</a><br>[3] <a href="http://blog.csdn.net/ghsau/article/details/8108292" target="_blank" rel="noopener"> http://blog.csdn.net/ghsau/article/details/8108292</a><br>[4] <a href="http://blog.csdn.net/ns_code/article/details/17511147" target="_blank" rel="noopener"> http://blog.csdn.net/ns_code/article/details/17511147</a></p>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：ByteArrayInputStream使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9AByteArrayInputStream%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read<br>方法要提供的下一个字节。ByteArrayOutputStream实现了一个输出流，其中的数据被写入一个 byte<br>数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray()和 toString()获取数据。</p><h3 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h3><p>ByteArrayInputStream提供的API如下：</p><pre><code>// 构造函数    ByteArrayInputStream(byte[] buf)    ByteArrayInputStream(byte[] buf, int offset, int length)    synchronized int         available() //能否读取字节流的下一字节    void                     close() //关闭字节流    synchronized void        mark(int readlimit) //保存当前位置    boolean                  markSupported() //是否支持mark    synchronized int         read() //读取下一字节    synchronized int         read(byte[] buffer, int offset, int length) //将字节流写入buffer数组    synchronized void        reset() //重置索引到mark位置    synchronized long        skip(long byteCount) //跳过n个字节}</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public class TestByteArray {    // 对应英文字母“abcddefghijklmnopqrsttuvwxyz”    private final byte[] ArrayLetters = {            0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,            0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A    };    public void testByteArrayInputStream() {        //创建字节流,以ArrayLetters初始化        ByteArrayInputStream inputStream = new ByteArrayInputStream(ArrayLetters);        //读取5个字节        int i = 0;        System.out.print(&quot;前5个字节为: &quot;);        while (i++ &lt; 5) {            //是否可读            if (inputStream.available() &gt;= 0) {                int buf = inputStream.read();                System.out.printf(&quot;0x%s &quot;, Integer.toHexString(buf));            }        }        System.out.println();        //是否支持标记        if (!inputStream.markSupported()) {            System.out.println(&quot;该字节流不支持标记&quot;);        } else {            System.out.println(&quot;该字节流支持标记&quot;);        }        //标记, 已经读取5个字节,标记处为0x66        System.out.println(&quot;标记该字节流为位置为0x66(f)&quot;);        inputStream.mark(0);        //跳过2个字节        inputStream.skip(2);        //读取5个字节到buffer        byte [] buffer = new byte[5];        inputStream.read(buffer, 0, 5);        System.out.println(&quot;buffer: &quot; + new String(buffer));        //重置        inputStream.reset();        inputStream.read(buffer, 0, 5);        System.out.println(&quot;重置后读取5个字符为: &quot; + new String(buffer));    }}</code></pre><p>运行结果如下：</p><pre><code>前5个字节为: 0x61 0x62 0x63 0x64 0x65该字节流支持标记标记该字节流为位置为0x66(f)buffer: hijkl重置后读取5个字符为: fghij</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>ByteArrayInputStream有两个构造函数，区别是初始化内容选择。</p><pre><code>/** * Creates a &lt;code&gt;ByteArrayInputStream&lt;/code&gt; * so that it  uses &lt;code&gt;buf&lt;/code&gt; as its * buffer array. * The buffer array is not copied. * The initial value of &lt;code&gt;pos&lt;/code&gt; * is &lt;code&gt;0&lt;/code&gt; and the initial value * of  &lt;code&gt;count&lt;/code&gt; is the length of * &lt;code&gt;buf&lt;/code&gt;. * * @param   buf   the input buffer. */public ByteArrayInputStream(byte buf[]) {    this.buf = buf; //缓冲数组    this.pos = 0; //当前位置    this.count = buf.length; //输入流字节数}/** * Creates &lt;code&gt;ByteArrayInputStream&lt;/code&gt; * that uses &lt;code&gt;buf&lt;/code&gt; as its * buffer array. The initial value of &lt;code&gt;pos&lt;/code&gt; * is &lt;code&gt;offset&lt;/code&gt; and the initial value * of &lt;code&gt;count&lt;/code&gt; is the minimum of &lt;code&gt;offset+length&lt;/code&gt; * and &lt;code&gt;buf.length&lt;/code&gt;. * The buffer array is not copied. The buffer&apos;s mark is * set to the specified offset. * * @param   buf      the input buffer. * @param   offset   the offset in the buffer of the first byte to read. * @param   length   the maximum number of bytes to read from the buffer. */public ByteArrayInputStream(byte buf[], int offset, int length) {    this.buf = buf; //缓冲数组    this.pos = offset; //当前位置为传入buf的offset    this.count = Math.min(offset + length, buf.length); //输入流字节数    this.mark = offset; //标记}</code></pre><h3 id="2-2-read方法"><a href="#2-2-read方法" class="headerlink" title="2.2 read方法"></a>2.2 read方法</h3><p>read方法有两个，不带参数的read()每次读取字节流中一个字节，带参数的read(byte b[], int off, int<br>len)将字节流从当前位置开始，写入len个字节到b中，写入开始位置为off。</p><pre><code>/** * 读取字节流当前字节 * @return 一个字节 */public synchronized int read() {    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1; //&amp;0xff为限制返回值为一个字节,即8位}/** * 将字节流当前位置开始的len个字节写入到 b从off开始的len个位置 * @param b * @param off * @param len * @return */public synchronized int read(byte b[], int off, int len) {    if (b == null) {        throw new NullPointerException();    } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {        throw new IndexOutOfBoundsException();    }    if (pos &gt;= count) { //超出字节流范围        return -1;    }    int avail = count - pos; //可读取的字节数量    if (len &gt; avail) {        len = avail;    }    if (len &lt;= 0) {        return 0;    }    System.arraycopy(buf, pos, b, off, len); //将buf从pos位置开始的字节复制到b从off开始的位置,共复制len长    pos += len;    return len;}</code></pre><h3 id="2-4-skip方法"><a href="#2-4-skip方法" class="headerlink" title="2.4 skip方法"></a>2.4 skip方法</h3><pre><code>/** * Skips &lt;code&gt;n&lt;/code&gt; bytes of input from this input stream. Fewer * bytes might be skipped if the end of the input stream is reached. * The actual number &lt;code&gt;k&lt;/code&gt; * of bytes to be skipped is equal to the smaller * of &lt;code&gt;n&lt;/code&gt; and  &lt;code&gt;count-pos&lt;/code&gt;. * The value &lt;code&gt;k&lt;/code&gt; is added into &lt;code&gt;pos&lt;/code&gt; * and &lt;code&gt;k&lt;/code&gt; is returned. * * @param   n   the number of bytes to be skipped. * @return  the actual number of bytes skipped. */public synchronized long skip(long n) {    long k = count - pos; //剩余字节数    if (n &lt; k) {        k = n &lt; 0 ? 0 : n;    }    pos += k;    return k;}</code></pre><h3 id="2-5-mark和reset方法"><a href="#2-5-mark和reset方法" class="headerlink" title="2.5 mark和reset方法"></a>2.5 mark和reset方法</h3><pre><code>/** * Set the current marked position in the stream. * ByteArrayInputStream objects are marked at position zero by * default when constructed.  They may be marked at another * position within the buffer by this method. * &lt;p&gt; * If no mark has been set, then the value of the mark is the * offset passed to the constructor (or 0 if the offset was not * supplied). * * &lt;p&gt; Note: The &lt;code&gt;readAheadLimit&lt;/code&gt; for this class *  has no meaning. * * @since   JDK1.1 */public void mark(int readAheadLimit) {    mark = pos;}/** * Resets the buffer to the marked position.  The marked position * is 0 unless another position was marked or an offset was specified * in the constructor. */public synchronized void reset() {    pos = mark;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_02.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_02.html</a><br>[2] <a href="http://www.cnblogs.com/skywang12345/p/io_03.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_03.html</a><br>[3] <a href="http://blog.csdn.net/rcoder/article/details/6118313" target="_blank" rel="noopener"> http://blog.csdn.net/rcoder/article/details/6118313</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：CharArrayWriter使用及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9ACharArrayWriter%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>CharArrayWriter即字符数组输出流，用于向输出流写写入字符，和ByteArrayOutputStream的区别就是前者写入的是字符后者写入的是字<br>节。</p><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>CharArrayWriter提供的API如下：</p><pre><code>//构造方法CharArrayWriter()CharArrayWriter(int initialSize)//追加写CharArrayWriter     append(CharSequence csq, int start, int end)CharArrayWriter     append(char c)CharArrayWriter     append(CharSequence csq)//关闭,未做实现void     close()//未做实现void     flush()//清空输出流void     reset()//输出流大小int     size()//返回char数组char[]     toCharArray()//返回StringString     toString()//写入void     write(char[] buffer, int offset, int len)void     write(int oneChar)void     write(String str, int offset, int count)//写入到其他Writervoid     writeTo(Writer out)</code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code>public void testCharArrayWriter() {    try {        char [] letters = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;};        //创建输出流Writer        CharArrayWriter writer = new CharArrayWriter();        //写入&apos;1&apos;        writer.write(&apos;1&apos;);        System.out.println(&quot;输出流的内容为: &quot; + writer);        //写入字符串&apos;2345&apos;        writer.write(&quot;2345&quot;);        System.out.println(&quot;输出流的内容为: &quot; + writer);        //追加4567        writer.append(&quot;456&quot;).append(&quot;7&quot;);        System.out.println(&quot;输出流的内容为: &quot; + writer);        //写入abc        writer.write(letters, 0, 3);        System.out.println(&quot;输出流的内容为: &quot; + writer);    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>输出流的内容为: 1输出流的内容为: 12345输出流的内容为: 123454567输出流的内容为: 123454567abc</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>CharArrayWriter的构造方法有两个，区别是字符数组大小设置。</p><pre><code>/** * Creates a new CharArrayWriter. */public CharArrayWriter() {    this(32);}/** * Creates a new CharArrayWriter with the specified initial size. * * @param initialSize  an int specifying the initial buffer size. * @exception IllegalArgumentException if initialSize is negative */public CharArrayWriter(int initialSize) {    if (initialSize &lt; 0) {        throw new IllegalArgumentException(&quot;Negative initial size: &quot;                + initialSize);    }    buf = new char[initialSize];}</code></pre><h3 id="write方法"><a href="#write方法" class="headerlink" title="write方法"></a>write方法</h3><p>write有多种重载方法，重点分析其中一种。</p><pre><code>/** * Writes characters to the buffer. * @param c the data to be written * @param off       the start offset in the data * @param len       the number of chars that are written */public void write(char c[], int off, int len) {    if ((off &lt; 0) || (off &gt; c.length) || (len &lt; 0) ||            ((off + len) &gt; c.length) || ((off + len) &lt; 0)) {        throw new IndexOutOfBoundsException();    } else if (len == 0) {        return;    }    synchronized (lock) { //线程安全        int newcount = count + len;        if (newcount &gt; buf.length) {            //数组扩容方案是: 2倍和实际需要大小中的最大值            buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount));        }        System.arraycopy(c, off, buf, count, len); //写入        count = newcount;    }}</code></pre><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>将要追加的字符（串）写在输出流最后。</p><pre><code>/** * Appends the specified character sequence to this writer. * @param  csq *         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is *         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are *         appended to this writer. * * @return  This writer * * @since  1.5 */public CharArrayWriter append(CharSequence csq) {    String s = (csq == null ? &quot;null&quot; : csq.toString());    write(s, 0, s.length()); //写入    return this; //可以拼接追加}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_19.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_19.html</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：CharArrayReader使用及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9ACharArrayReader%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>CharArrayReader即字符数组输入流，用于从输入流读取字符，和ByteArrayInputStream的区别就是前者以字符为单位后者是字节。</p><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>CharArrayReader提供的API如下：</p><pre><code>//构造方法CharArrayReader(char[] buf)CharArrayReader(char[] buf, int offset, int length)//关闭输入流void      close()//markvoid      mark(int readLimit)boolean   markSupported()//读取下一个字符int       read()//读取多个字符int       read(char[] b, int off, int len)//是否可读boolean   ready()//返回mark的位置void      reset()//跳过n个字符long      skip(long n)</code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code>public void testCharArrayReader() {    try {        char [] letters = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;};        //创建输入流        CharArrayReader reader = new CharArrayReader(letters);        //读取第一个字符        System.out.printf(&quot;第一个字符为: %c\n&quot;, reader.read());        //mark        reader.mark(10);        //读取bcd到tmp        char [] tmp = new char[3];        reader.read(tmp, 0, 3);        System.out.println(&quot;读取三个字符到tmp: &quot; + new String(tmp));        //读取reset后的第一个字符(b)        reader.reset();        System.out.printf(&quot;reset后第一个字符为: %c\n&quot;, reader.read());    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>第一个字符为: a读取三个字符到tmp: bcdreset后第一个字符为: b</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>CharArrayReader的构造方法有两个，区别是初始化输入流的内容不同。</p><pre><code>/** * Creates a CharArrayReader from the specified array of chars. * 以buf中所有字符初始化输入流 * @param buf       Input buffer (not copied) */public CharArrayReader(char buf[]) {    this.buf = buf;    this.pos = 0;    this.count = buf.length;}/** * Creates a CharArrayReader from the specified array of chars. * 以buf中部分字符为输入流 * @throws IllegalArgumentException *         If &lt;tt&gt;offset&lt;/tt&gt; is negative or greater than *         &lt;tt&gt;buf.length&lt;/tt&gt;, or if &lt;tt&gt;length&lt;/tt&gt; is negative, or if *         the sum of these two values is negative. * * @param buf       Input buffer (not copied) * @param offset    Offset of the first char to read * @param length    Number of chars to read */public CharArrayReader(char buf[], int offset, int length) {    if ((offset &lt; 0) || (offset &gt; buf.length) || (length &lt; 0) ||            ((offset + length) &lt; 0)) {        throw new IllegalArgumentException();    }    //以buf中从offset开始length长度的字符初始化输入流    this.buf = buf;    this.pos = offset;    this.count = Math.min(offset + length, buf.length);    this.markedPos = offset;}</code></pre><h3 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h3><p>read方法有读取下一个字符和读取多个字符两种重载方法，下面分析读取多个字符的源码。</p><pre><code>/** * Reads characters into a portion of an array. * @param b  Destination buffer * @param off  Offset at which to start storing characters * @param len   Maximum number of characters to read * @return  The actual number of characters read, or -1 if *          the end of the stream has been reached * * @exception   IOException  If an I/O error occurs */public int read(char b[], int off, int len) throws IOException {    synchronized (lock) {        ensureOpen(); //确保输入流正常        if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||                ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {            throw new IndexOutOfBoundsException();        } else if (len == 0) {            return 0;        }        if (pos &gt;= count) { //没有可读字符            return -1;        }        if (pos + len &gt; count) { //可读字符不足len,只读剩下的字符            len = count - pos;        }        if (len &lt;= 0) {            return 0;        }        System.arraycopy(buf, pos, b, off, len); //读取        pos += len;        return len;    }}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_18.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_18.html</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：ByteArrayOutputStream使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9AByteArrayOutputStream%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read<br>方法要提供的下一个字节。ByteArrayOutputStream实现了一个输出流，其中的数据被写入一个 byte<br>数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray()和 toString()获取数据。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>ByteArrayOutputStream提供的API如下：</p><pre><code>// 构造函数    ByteArrayOutputStream()    ByteArrayOutputStream(int size)    void    close() //关闭字节流    synchronized void    reset() //重置计数器    int     size() //获取当前计数    synchronized byte[]  toByteArray() //将字节流转换为字节数组    String  toString(int hibyte) //将字节流转换为String    String  toString(String charsetName)    String  toString()    synchronized void    write(byte[] buffer, int offset, int len) //写入字节数组buffer到字节流, offset是buffer的起始位置    synchronized void    write(int oneByte) //写入一个字节到字节流    synchronized void    writeTo(OutputStream out) //写输出流到其他输出流out}</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public void testByteArrayOutputStream() {    byte [] letter = {&apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;};    //新建字节流    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    //写入abcdefg    int i = &apos;a&apos;; //a    while (i &lt; &apos;h&apos;) {        outputStream.write(i);        i++;    }    System.out.println(&quot;当前字节流中的内容有: &quot; + outputStream.toString());    //写入多个    outputStream.write(letter, 1, 3);    System.out.println(&quot;写入letter数组中的第2,3,4个字母字节流中的内容有: &quot; + outputStream.toString());    System.out.println(&quot;当前output字节流中的字节数为: &quot; + outputStream.size());    byte [] byteArr = outputStream.toByteArray();    i = 0;    System.out.print(&quot;byte数组内容为: &quot;);    while (i &lt; byteArr.length) {        System.out.print(byteArr[i++] + &quot; &quot;);    }    System.out.println();    OutputStream cloneOut = new ByteArrayOutputStream();    try {        outputStream.writeTo(cloneOut);        System.out.println(&quot;cloneOut的内容为: &quot; + cloneOut.toString());    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>当前字节流中的内容有: abcdefg写入letter数组中的第2,3,4个字母字节流中的内容有: abcdefgijk当前output字节流中的字节数为: 10byte数组内容为: 97 98 99 100 101 102 103 105 106 107cloneOut的内容为: abcdefgijk</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>ByteArrayOutputStream有两个构造函数,区别是初始大小不同。</p><pre><code>/** * Creates a new byte array output stream. The buffer capacity is * initially 32 bytes, though its size increases if necessary. */public ByteArrayOutputStream() {    this(32);}/** * Creates a new byte array output stream, with a buffer capacity of * the specified size, in bytes. * * @param   size   the initial size. * @exception  IllegalArgumentException if size is negative. */public ByteArrayOutputStream(int size) {    if (size &lt; 0) {        throw new IllegalArgumentException(&quot;Negative initial size: &quot;                + size);    }    buf = new byte[size];}</code></pre><h3 id="2-2-write方法"><a href="#2-2-write方法" class="headerlink" title="2.2 write方法"></a>2.2 write方法</h3><pre><code>/** * Writes the specified byte to this byte array output stream. * * @param   b   the byte to be written. */public synchronized void write(int b) {    ensureCapacity(count + 1); //增加容量, 容量不够则加倍    buf[count] = (byte) b; //写入字节    count += 1;}/** * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array * starting at offset &lt;code&gt;off&lt;/code&gt; to this byte array output stream. * * @param   b     the data. * @param   off   the start offset in the data. * @param   len   the number of bytes to write. */public synchronized void write(byte b[], int off, int len) {    if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||            ((off + len) - b.length &gt; 0)) {        throw new IndexOutOfBoundsException();    }    ensureCapacity(count + len); //增加容量,容量不够则加倍    System.arraycopy(b, off, buf, count, len); //写入字节数组    count += len;}</code></pre><h3 id="2-3-writeTo方法"><a href="#2-3-writeTo方法" class="headerlink" title="2.3 writeTo方法"></a>2.3 writeTo方法</h3><pre><code>/** * Writes the complete contents of this byte array output stream to * the specified output stream argument, as if by calling the output * stream&apos;s write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt;. * * @param      out   the output stream to which to write the data. * @exception  IOException  if an I/O error occurs. */public synchronized void writeTo(OutputStream out) throws IOException {    out.write(buf, 0, count); //将 当前OutputStream的buf中内容写到out中}</code></pre><h3 id="2-4-toString-toByteArray方法"><a href="#2-4-toString-toByteArray方法" class="headerlink" title="2.4 toString , toByteArray方法"></a>2.4 toString , toByteArray方法</h3><pre><code>/** * Creates a newly allocated byte array. Its size is the current * size of this output stream and the valid contents of the buffer * have been copied into it. * * @return  the current contents of this output stream, as a byte array. * @see     java.io.ByteArrayOutputStream#size() */public synchronized byte toByteArray()[] {    return Arrays.copyOf(buf, count); //返回信得数组}/** * Converts the buffer&apos;s contents into a string decoding bytes using the * platform&apos;s default character set. The length of the new &lt;tt&gt;String&lt;/tt&gt; * is a function of the character set, and hence may not be equal to the * size of the buffer. * * &lt;p&gt; This method always replaces malformed-input and unmappable-character * sequences with the default replacement string for the platform&apos;s * default character set. The {@linkplain java.nio.charset.CharsetDecoder} * class should be used when more control over the decoding process is * required. * * @return String decoded from the buffer&apos;s contents. * @since  JDK1.1 */public synchronized String toString() {    return new String(buf, 0, count); //返回String对象}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_02.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_02.html</a><br>[2] <a href="http://www.cnblogs.com/skywang12345/p/io_03.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_03.html</a><br>[3] <a href="http://blog.csdn.net/rcoder/article/details/6118313" target="_blank" rel="noopener"> http://blog.csdn.net/rcoder/article/details/6118313</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java:_synchronized详解，静态同步方法，普通同步方法，同步代码块</title>
      <link href="/2017/11/11/Java:_synchronized%E8%AF%A6%E8%A7%A3%EF%BC%8C%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E6%99%AE%E9%80%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <content type="html"><![CDATA[<p>摘自： <a href="http://topmanopensource.iteye.com/blog/1738178" target="_blank" rel="noopener"> http://topmanopensource.iteye.com/blog/1738178</a></p><p>对代码进行同步控制我们可以选择同步方法，也可以选择同步块，这两种方式各有优缺点，至于具体选择什么方式，就见仁见智了，同步块不仅可以更加精确的控制对象锁，也就<br>是控制锁的作用域，何谓锁的作用域？锁的作用域就是从锁被获取到其被释放的时间。而且可以选择要获取哪个对象的对象锁。但是如果在使用同步块机制时，如果使用过多的锁<br>也会容易引起死锁问题，同时获取和释放所也有代价，而同步方法，它们所拥有的锁就是该方法所属的类的对象锁，换句话说，也就是this对象，而且锁的作用域也是整个方<br>法，这可能导致其锁的作用域可能太大，也有可能引起死锁，同时因为可能包含了不需要进行同步的代码块在内，也会降低程序的运行效率。而不管是同步方法还是同步块，我们<br>都不应该在他们的代码块内包含无限循环，如果代码内部要是有了无限循环，那么这个同步方法或者同步块在获取锁以后因为代码会一直不停的循环着运行下去，也就没有机会释<br>放它所获取的锁，而其它等待这把锁的线程就永远无法获取这把锁，这就造成了一种死锁现象。</p><p>详细解说一下同步方法的锁，同步方法分为静态同步方法与非静态同步方法。</p><p><strong> 所有的非静态同步方法用的都是同一把锁——实例对象本身 </strong> ，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。 </p><p><strong> 而所有的静态同步方法用的也是同一把锁——类对象本身 </strong> ，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！ </p><p><strong> 而对于同步块，由于其锁是可以选择的 </strong> ，所以只有使用同一把锁的同步块之间才有着竞态条件，这就得具体情况具体分析了，但这里有个需要注意的地方，同步块的锁是可以选择的，但是不是可以任意选择的！！！！这里必须要注意一个物理对象和一个引用对象的实例变量之间的区别！使用一个引用对象的实例变量作为锁并不是一个好的选择，因为同步块在执行过程中可能会改变它的值，其中就包括将其设置为null，而对一个null对象加锁会产生异常，并且对不同的对象加锁也违背了同步的初衷！这看起来是很清楚的，但是一个经常发生的错误就是选用了错误的锁对象，因此必须注意：同步是基于实际对象而不是对象引用的！多个变量可以引用同一个对象，变量也可以改变其值从而指向其他的对象，因此，当选择一个对象锁时，我们要根据实际对象而不是其引用来考虑！作为一个原则，不要选择一个可能会在锁的作用域中改变值的实例变量作为锁对象！！！！ </p><h3 id="一、同步问题提出"><a href="#一、同步问题提出" class="headerlink" title="一、同步问题提出"></a>一、同步问题提出</h3><p>线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。<br>例如：两个线程ThreadA、ThreadB都操作同一个对象Foo对象，并修改Foo对象上的数据。</p><pre><code>public class Foo {     private int x = 100;     public int getX() {         return x;     }     public int fix(int y) {         x = x - y;         return x;     } }public class MyRunnable implements Runnable {     private Foo foo = new Foo();     public static void main(String[] args) {         MyRunnable r = new MyRunnable();         Thread ta = new Thread(r, &quot;Thread-A&quot;);         Thread tb = new Thread(r, &quot;Thread-B&quot;);         ta.start();         tb.start();     }     public void run() {         for (int i = 0; i &lt; 3; i++) {             this.fix(30);             try {                 Thread.sleep(1);             } catch (InterruptedException e) {                 e.printStackTrace();             }             System.out.println(Thread.currentThread().getName() + &quot; : 当前foo对象的x值= &quot; + foo.getX());         }     }     public int fix(int y) {         return foo.fix(y);     } }</code></pre><p>运行结果：</p><pre><code>Thread-A : 当前foo对象的x值= 40 Thread-B : 当前foo对象的x值= 40 Thread-B : 当前foo对象的x值= -20 Thread-A : 当前foo对象的x值= -50 Thread-A : 当前foo对象的x值= -80 Thread-B : 当前foo对象的x值= -80 Process finished with exit code 0</code></pre><p>从结果发现，这样的输出值明显是不合理的。原因是两个线程不加控制的访问Foo对象并修改其数据所致。<br>如果要保持结果的合理性，只需要达到一个目的，就是将对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。</p><p>在具体的Java代码中需要完成一下两个操作：<br>把竞争访问的资源类Foo变量x标识为private；<br>同步哪些修改变量的代码，使用synchronized关键字同步方法或代码。</p><h3 id="二、同步和锁定"><a href="#二、同步和锁定" class="headerlink" title="二、同步和锁定"></a>二、同步和锁定</h3><h4 id="1、锁的原理"><a href="#1、锁的原理" class="headerlink" title="1、锁的原理"></a>1、锁的原理</h4><p>Java中每个对象都有一个内置锁</p><p>当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象<br>、在对象上锁定或在对象上同步。</p><p>当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。</p><p>一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的sync<br>hronized方法或代码块，直到该锁被释放。</p><p>释放锁是指持锁线程退出了synchronized同步方法或代码块。</p><p>关于锁和同步，有以下几个要点：<br>1）、只能同步方法，而不能同步变量和类；<br>2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？<br>3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。<br>4）、如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直<br>到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。<br>5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。<br>6）、线程睡眠时，它所持的任何锁都不会释放。<br>7）、线程可以获得多个重进入（synchronized ）锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。<br>8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。<br>9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：</p><pre><code>public int fix(int y) {    synchronized (this) {        x = x - y;    }    return x;}  当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：public synchronized int getX() {    return x++;}与public int getX() {    synchronized (this) {        return x;    }}</code></pre><p>效果是完全一样的。</p><h3 id="三、静态方法同步"><a href="#三、静态方法同步" class="headerlink" title="三、静态方法同步"></a>三、静态方法同步</h3><p>要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。<br>例如：</p><pre><code>public static synchronized int setName(String name){      Xxx.name = name;}等价于public static int setName(String name){      synchronized(Xxx.class){            Xxx.name = name;      }}</code></pre><h3 id="四、如果线程不能不能获得锁会怎么样"><a href="#四、如果线程不能不能获得锁会怎么样" class="headerlink" title="四、如果线程不能不能获得锁会怎么样"></a>四、如果线程不能不能获得锁会怎么样</h3><p>如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行<br>或运行为止。</p><p>当考虑阻塞时，一定要注意哪个对象正被用于锁定：<br>1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</p><p>2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。</p><p>3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p><p>4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将<br>永远不会彼此阻塞。</p><h3 id="五、何时需要同步"><a href="#五、何时需要同步" class="headerlink" title="五、何时需要同步"></a>五、何时需要同步</h3><p>在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。</p><p>对于非静态字段中可更改的数据，通常使用非静态方法访问。<br>对于静态字段中可更改的数据，通常使用静态方法访问。</p><p>如果需要在非静态方法中使用静态字段，或者在静态字段中调用非静态方法，问题将变得非常复杂。已经超出SJCP考试范围了。</p><h3 id="六、线程安全类"><a href="#六、线程安全类" class="headerlink" title="六、线程安全类"></a>六、线程安全类</h3><p>当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。<br>即使是线程安全类，也应该特别小心，因为操作的线程是间仍然不一定安全。</p><p>举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，删除集合中所有元素的时候。第二个线程也来执行与第一个线<br>程相同的操作，也许在第一个线程查询后，第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。<br>看个代码：</p><pre><code>public class NameList {     private List nameList = Collections.synchronizedList(new LinkedList());     public void add(String name) {         nameList.add(name);     }     public String removeFirst() {         if (nameList.size() &gt; 0) {             return (String) nameList.remove(0);         } else {             return null;         }     } }public class Test {     public static void main(String[] args) {         final NameList nl = new NameList();         nl.add(&quot;aaa&quot;);         class NameDropper extends Thread{             public void run(){                 String name = nl.removeFirst();                 System.out.println(name);             }         }         Thread t1 = new NameDropper();         Thread t2 = new NameDropper();         t1.start();         t2.start();     } }</code></pre><p>虽然集合对象<br>private List nameList = Collections.synchronizedList(new<br>LinkedList());是同步的，但是程序还不是线程安全的。出现这种事件的原因是，上例中一个线程操作列表过程中无法阻止另外一个线程对列表的其他操作。</p><p>解决上面问题的办法是，在操作集合对象的NameList上面做一个同步。改写后的代码如下：</p><pre><code>public class NameList {     private List nameList = Collections.synchronizedList(new LinkedList());     public synchronized void add(String name) {         nameList.add(name);     }     public synchronized String removeFirst() {         if (nameList.size() &gt; 0) {             return (String) nameList.remove(0);         } else {             return null;         }     } }</code></pre><p>这样，当一个线程访问其中一个同步方法时，其他线程只有等待。</p><h3 id="七、线程死锁"><a href="#七、线程死锁" class="headerlink" title="七、线程死锁"></a>七、线程死锁</h3><p>死锁对Java程序来说，是很复杂的，也很难发现问题。当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁。</p><p>还是看一个比较直观的死锁例子：</p><pre><code>public class DeadlockRisk {     private static class Resource {         public int value;     }     private Resource resourceA = new Resource();     private Resource resourceB = new Resource();     public int read() {         synchronized (resourceA) {             synchronized (resourceB) {                 return resourceB.value + resourceA.value;             }         }     }     public void write(int a, int b) {         synchronized (resourceB) {             synchronized (resourceA) {                 resourceA.value = a;                 resourceB.value = b;             }         }     } }</code></pre><p>假设read()方法由一个线程启动，write()方法由另外一个线程启动。读线程将拥有resourceA锁，写线程将拥有resourceB锁，两者都坚持等待<br>的话就出现死锁。</p><p>实际上，上面这个例子发生死锁的概率很小。因为在代码内的某个点，CPU必须从读线程切换到写线程，所以，死锁基本上不能发生。</p><p>但是，无论代码中发生死锁的概率有多小，一旦发生死锁，程序就死掉。有一些设计方法能帮助避免死锁，包括始终按照预定义的顺序获取锁这一策略。已经超出SCJP的考试<br>范围。</p><h3 id="八、线程同步小结"><a href="#八、线程同步小结" class="headerlink" title="八、线程同步小结"></a>八、线程同步小结</h3><p>1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。<br>2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步<br>方法。<br>3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方<br>法时，会获取这两个对象锁。<br>4、对于同步，要时刻清醒在哪个对象上同步，这是关键。<br>5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。<br>6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。<br>7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。</p><pre><code>package com.etrip.concurrent.executor;   import java.util.Collections;   import java.util.HashMap;   import java.util.Iterator;   import java.util.Map;   import java.util.Map.Entry;   import java.util.Set;   /**   * 非静态同步方法，静态同步方法，同步语句块的使用   *    *    * 进行多线程编程，同步控制是非常重要的，而同步控制就涉及到了锁。          对代码进行同步控制我们可以选择同步方法，也可以选择同步块，这两种方式各有优缺点，至于具体选择什么方式，就见仁见智了，同步块不仅可以更加精确的控制对象锁，也就是控制锁的作用域，何谓锁的作用域？锁的作用域就是从锁被获取到其被释放的时间。而且可以选择要获取哪个对象的对象锁。但是如果在使用同步块机制时，如果使用过多的锁也会容易引起死锁问题，同时获取和释放所也有代价，而同步方法，它们所拥有的锁就是该方法所属的类的对象锁，换句话说，也就是this对象，而且锁的作用域也是整个方法，这可能导致其锁的作用域可能太大，也有可能引起死锁，同时因为可能包含了不需要进行同步的代码块在内，也会降低程序的运行效率。而不管是同步方法还是同步块，我们都不应该在他们的代码块内包含无限循环，如果代码内部要是有了无限循环，那么这个同步方法或者同步块在获取锁以后因为代码会一直不停的循环着运行下去，也就没有机会释放它所获取的锁，而其它等待这把锁的线程就永远无法获取这把锁，这就造成了一种死锁现象。    *    * @author longgangbai   */  public class StaticInstanceLock {       private   int count;       private  static  StaticInstanceLock  instance=null;       private StaticInstanceLock(){       }       /**       * 静态方法的锁       *        * @return       */      public static synchronized StaticInstanceLock getInstance(){           if(instance==null){               instance=new  StaticInstanceLock();           }           return instance;       }       /**       * 非静态方法的锁       * @return       */      public synchronized int getCount(){           return count;       }       public synchronized  void setCount(int count){           this.count=count;       }       /**       * 同步语句块的使用       *        */      public void synmethod(){                 //HashMap为非安全性Map                 HashMap&lt;String,String&gt; hashmap = new HashMap&lt;String,String&gt;();                 hashmap.put(&quot;ZH&quot;,&quot;中国&quot;);                 hashmap.put(&quot;EN&quot;,&quot;英国&quot;);                 hashmap.put(&quot;AM&quot;,&quot;美国&quot;);                 hashmap.put(&quot;FR&quot;,&quot;法国&quot;);                 //创建一个同步的对象Map                 Map&lt;String,String&gt; m = Collections.synchronizedMap(hashmap);                 Set&lt;String&gt; s = m.keySet();  // Needn&apos;t be in synchronized block                 //这里同步的对象均为需要使用同步的对象如Map而非Set                 synchronized(m) {  // Synchronizing on m, not s!                     Iterator&lt;String&gt; i = s.iterator(); // Must be in synchronized block                     while (i.hasNext()){                         foo(i.next());                     }                 }       }       public void foo(String entry){           System.out.println(&quot;StaticInstanceLock =&quot;+entry);       }       public static void main(String[] args) {           StaticInstanceLock instance=StaticInstanceLock.getInstance();           instance.setCount(7);           int count = instance.getCount();           instance.synmethod();       }   }  </code></pre>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：FileInputStream和FileOutputStream使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9AFileInputStream%E5%92%8CFileOutputStream%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>FileInputStream即文件输入流，使用它从文件中获得字节流，FileOutputStream即问价输出流，使用它将字节流写入文件。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>FileInputStream提供的API如下：</p><pre><code>FileInputStream(File file)         // 创建“File对象”对应的“文件输入流”FileInputStream(FileDescriptor fd) // 创建“文件描述符”对应的“文件输入流”FileInputStream(String path)       // 创建“文件(路径为path)”对应的“文件输入流”int      available()             // 返回“剩余的可读取的字节数”或者“skip的字节数”void     close()                 // 关闭“文件输入流”FileChannel      getChannel()    // 返回“FileChannel”final FileDescriptor     getFD() // 返回“文件描述符”int      read()                  // 返回“文件输入流”的下一个字节int      read(byte[] buffer, int off, int len) // 读取“文件输入流”的数据并存在到buffer，从off开始存储，存储长度是len。long     skip(long n)    // 跳过n个字节</code></pre><p>FileOutputStream提供的API如下：</p><pre><code>FileOutputStream(File file)                   // 创建“File对象”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。FileOutputStream(File file, boolean append)   // 创建“File对象”对应的“文件输入流”；指定“追加模式”。FileOutputStream(FileDescriptor fd)           // 创建“文件描述符”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。FileOutputStream(String path)                 // 创建“文件(路径为path)”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。FileOutputStream(String path, boolean append) // 创建“文件(路径为path)”对应的“文件输入流”；指定“追加模式”。void                    close()      // 关闭“输出流”FileChannel             getChannel() // 返回“FileChannel”final FileDescriptor    getFD()      // 返回“文件描述符”void                    write(byte[] buffer, int off, int len) // 将buffer写入到“文件输出流”中，从buffer的off开始写，写入长度是len。void                    write(int n)  // 写入字节n到“文件输出流”中</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>/** * 在源码所在目录生成一个test.txt,并写入abcdefghijklmn123456 */public void testFileOutputStream() {    try {        byte [] content = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;};        //床架test.txt文件        File file = new File(&quot;test.txt&quot;);        //创建文件输出流        FileOutputStream outputStream = new FileOutputStream(file);        outputStream.write(content, 0, 14);        //PrintStream写入方便        PrintStream printStream = new PrintStream(outputStream);        printStream.print(&quot;123456&quot;);        printStream.close();    } catch (Exception e) {        e.printStackTrace();    }}/** * 测试文件输入流 */public void testFileInputStream() {    try {        //新建输入流,文件中的内容为abcdefghijklmn123456        FileInputStream inputStream = new FileInputStream(&quot;test.txt&quot;);        //读取一个字节a        System.out.println(&quot;读取一个字节: &quot; + inputStream.read());        //跳过两个字节 b c        inputStream.skip(2);        //读取三个字节到buff中def        byte [] buff = new byte[3];        inputStream.read(buff, 0, 3);        System.out.println(&quot;buff中的内容为: &quot; + new String(buff));        inputStream.close();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>读取一个字节: 97buff中的内容为: def</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1FileInputStream源码分析"><a href="#2-1FileInputStream源码分析" class="headerlink" title="2.1FileInputStream源码分析"></a>2.1FileInputStream源码分析</h3><h4 id="2-1-1-构造方法"><a href="#2-1-1-构造方法" class="headerlink" title="2.1.1 构造方法"></a>2.1.1 构造方法</h4><p>FileInputStream提供三个构造方法，区别是传入的参数类型（文件路径，FIle对象，文件描述符对象）。</p><pre><code>/** * Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by * opening a connection to an actual file, * the file named by the path name &lt;code&gt;name&lt;/code&gt; * in the file system.  A new &lt;code&gt;FileDescriptor&lt;/code&gt; * object is created to represent this file * connection. * &lt;p&gt; * First, if there is a security * manager, its &lt;code&gt;checkRead&lt;/code&gt; method * is called with the &lt;code&gt;name&lt;/code&gt; argument * as its argument. * &lt;p&gt; * If the named file does not exist, is a directory rather than a regular * file, or for some other reason cannot be opened for reading then a * &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown. * * @param      name   the system-dependent file name. * @exception  FileNotFoundException  if the file does not exist, *                   is a directory rather than a regular file, *                   or for some other reason cannot be opened for *                   reading. * @exception  SecurityException      if a security manager exists and its *               &lt;code&gt;checkRead&lt;/code&gt; method denies read access *               to the file. * @see        java.lang.SecurityManager#checkRead(java.lang.String) */public FileInputStream(String name) throws FileNotFoundException {    this(name != null ? new File(name) : null);}/** * Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by * opening a connection to an actual file, * the file named by the &lt;code&gt;File&lt;/code&gt; * object &lt;code&gt;file&lt;/code&gt; in the file system. * A new &lt;code&gt;FileDescriptor&lt;/code&gt; object * is created to represent this file connection. * &lt;p&gt; * First, if there is a security manager, * its &lt;code&gt;checkRead&lt;/code&gt; method  is called * with the path represented by the &lt;code&gt;file&lt;/code&gt; * argument as its argument. * &lt;p&gt; * argument as its argument. * &lt;p&gt; * If the named file does not exist, is a directory rather than a regular * file, or for some other reason cannot be opened for reading then a * &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown. * * @param      file   the file to be opened for reading. * @exception  FileNotFoundException  if the file does not exist, *                   is a directory rather than a regular file, *                   or for some other reason cannot be opened for *                   reading. * @exception  SecurityException      if a security manager exists and its *               &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the file. * @see        java.io.File#getPath() * @see        java.lang.SecurityManager#checkRead(java.lang.String) */public FileInputStream(File file) throws FileNotFoundException {    String name = (file != null ? file.getPath() : null);    SecurityManager security = System.getSecurityManager();    if (security != null) {        security.checkRead(name);    }    if (name == null) {        throw new NullPointerException();    }    if (file.isInvalid()) {        throw new FileNotFoundException(&quot;Invalid file path&quot;);    }    fd = new FileDescriptor();    fd.attach(this);    path = name;    open(name);}/** * Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by using the file descriptor * &lt;code&gt;fdObj&lt;/code&gt;, which represents an existing connection to an * actual file in the file system. * &lt;p&gt; * If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is * called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to * see if it&apos;s ok to read the file descriptor. If read access is denied * to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown. * &lt;p&gt; * If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt; * is thrown. * &lt;p&gt; * This constructor does not throw an exception if &lt;code&gt;fdObj&lt;/code&gt; * is {@link java.io.FileDescriptor#valid() invalid}. * However, if the methods are invoked on the resulting stream to attempt * I/O on the stream, an &lt;code&gt;IOException&lt;/code&gt; is thrown. * * @param      fdObj   the file descriptor to be opened for reading. * @throws     SecurityException      if a security manager exists and its *                 &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the *                 file descriptor. * @see        SecurityManager#checkRead(java.io.FileDescriptor) */public FileInputStream(FileDescriptor fdObj) {    SecurityManager security = System.getSecurityManager();    if (fdObj == null) {        throw new NullPointerException();    }    if (security != null) {        security.checkRead(fdObj);    }    fd = fdObj;    path = null;    /*     * FileDescriptor is being shared by streams.     * Register this stream with FileDescriptor tracker.     */    fd.attach(this);}</code></pre><h3 id="2-2-FileOutputStream源码分析"><a href="#2-2-FileOutputStream源码分析" class="headerlink" title="2.2 FileOutputStream源码分析"></a>2.2 FileOutputStream源码分析</h3><h4 id="2-1-1-构造方法-1"><a href="#2-1-1-构造方法-1" class="headerlink" title="2.1.1 构造方法"></a>2.1.1 构造方法</h4><pre><code>public FileOutputStream(String name) throws FileNotFoundException {    this(name != null ? new File(name) : null, false);}/** * Creates a file output stream to write to the file with the specified * name.  If the second argument is &lt;code&gt;true&lt;/code&gt;, then * bytes will be written to the end of the file rather than the beginning. * A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this * file connection. * &lt;p&gt; * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt; * method is called with &lt;code&gt;name&lt;/code&gt; as its argument. * &lt;p&gt; * If the file exists but is a directory rather than a regular file, does * not exist but cannot be created, or cannot be opened for any other * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown. * * @param     name        the system-dependent file name * @param     append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written *                   to the end of the file rather than the beginning * @exception  FileNotFoundException  if the file exists but is a directory *                   rather than a regular file, does not exist but cannot *                   be created, or cannot be opened for any other reason. * @exception  SecurityException  if a security manager exists and its *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access *               to the file. * @see        java.lang.SecurityManager#checkWrite(java.lang.String) * @since     JDK1.1 */public FileOutputStream(String name, boolean append)        throws FileNotFoundException{    this(name != null ? new File(name) : null, append);}public FileOutputStream(File file) throws FileNotFoundException {    this(file, false);}/** * Creates a file output stream to write to the file represented by * the specified &lt;code&gt;File&lt;/code&gt; object. If the second argument is * &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file * rather than the beginning. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is * created to represent this file connection. * &lt;p&gt; * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt; * method is called with the path represented by the &lt;code&gt;file&lt;/code&gt; * argument as its argument. * &lt;p&gt; * If the file exists but is a directory rather than a regular file, does * not exist but cannot be created, or cannot be opened for any other * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown. * * @param      file               the file to be opened for writing. * @param     append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written *                   to the end of the file rather than the beginning * @exception  FileNotFoundException  if the file exists but is a directory *                   rather than a regular file, does not exist but cannot *                   be created, or cannot be opened for any other reason * @exception  SecurityException  if a security manager exists and its *                   be created, or cannot be opened for any other reason * @exception  SecurityException  if a security manager exists and its *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access *               to the file. * @see        java.io.File#getPath() * @see        java.lang.SecurityException * @see        java.lang.SecurityManager#checkWrite(java.lang.String) * @since 1.4 */public FileOutputStream(File file, boolean append)        throws FileNotFoundException{    String name = (file != null ? file.getPath() : null);    SecurityManager security = System.getSecurityManager();    if (security != null) {        security.checkWrite(name);    }    if (name == null) {        throw new NullPointerException();    }    if (file.isInvalid()) {        throw new FileNotFoundException(&quot;Invalid file path&quot;);    }    this.fd = new FileDescriptor();    fd.attach(this);    this.append = append;    this.path = name;    open(name, append);}/** * Creates a file output stream to write to the specified file * descriptor, which represents an existing connection to an actual * file in the file system. * &lt;p&gt; * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt; * method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; * argument as its argument. * &lt;p&gt; * If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt; * is thrown. * &lt;p&gt; * This constructor does not throw an exception if &lt;code&gt;fdObj&lt;/code&gt; * is {@link java.io.FileDescriptor#valid() invalid}. * However, if the methods are invoked on the resulting stream to attempt * I/O on the stream, an &lt;code&gt;IOException&lt;/code&gt; is thrown. * * @param      fdObj   the file descriptor to be opened for writing * @exception  SecurityException  if a security manager exists and its *               &lt;code&gt;checkWrite&lt;/code&gt; method denies *               write access to the file descriptor * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor) */public FileOutputStream(FileDescriptor fdObj) {    SecurityManager security = System.getSecurityManager();    if (fdObj == null) {        throw new NullPointerException();    }    if (security != null) {        security.checkWrite(fdObj);    }    this.fd = fdObj;    this.append = false;    this.path = null;    fd.attach(this);}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_07.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_07.html</a><br>[2] <a href="http://wangkuiwu.github.io/2012/05/07/FileInputStreamAndFileOutputStream/" target="_blank" rel="noopener"><br>http://wangkuiwu.github.io/2012/05/07/FileInputStreamAndFileOutputStream/</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：IO框架</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9AIO%E6%A1%86%E6%9E%B6/"/>
      <content type="html"><![CDATA[<p>Java IO：IO框架</p><p>Java 流处理分为字节流和字符流。字节流处理的单位是byte，而字符流处理的单位是以2个字节为单位的Unicode编码字符。字符流的操作效率比字节流高，字<br>符流按字符处理，字节流一次只能处理一个字节。下面是网上盗用的图（ <a href="http://blog.csdn.net/yczz/article/details/38761237" target="_blank" rel="noopener"><br>http://blog.csdn.net/yczz/article/details/38761237</a> ）<br><img src="http://img.blog.csdn.net/20160324162626046" alt="IO框架图"></p><h2 id="1-字节流-InputStream-OutputStream（创建一个输入-输出的Stream流）"><a href="#1-字节流-InputStream-OutputStream（创建一个输入-输出的Stream流）" class="headerlink" title="1 字节流 InputStream/OutputStream（创建一个输入/输出的Stream流）"></a>1 字节流 InputStream/OutputStream（创建一个输入/输出的Stream流）</h2><p>InputStream是字节输入流的基类，是一个抽象类，它提供的方法有：<br>int available() //返回stream中的可读字节数，inputstream类中的这个方法始终返回的是0，这个方法需要子类去实现。</p><pre><code>void close() //关闭stream方法，这个是每次在用完流之后必须调用的方法。int read() //方法是读取一个byte字节,但是返回的是int。int read(byte[]) //一次性读取内容到缓冲字节数组int read(byte[],int,int) //从数据流中的哪个位置offset开始读长度为len的内容到缓冲字节数组long skip(long) //从stream中跳过long类型参数个位置synchronized void mark(int) //用于标记stream的作用boolean markSupported() //返回的是boolean类型，因为不是所有的stream都可以调用mark方法的，这个方法就是用来判断stream是否可以调用mark方法和reset方法synchronized void reset() //这个方法和mark方法一起使用的，让stream回到mark的位置。</code></pre><p>OutputStream是一个输出字节流，是一个抽象类，他提供的方法有：</p><pre><code>void write(int) //写入一个字节到stream中void write(byte[]) //写入一个byte数组到stream中void write(byte[],int,int) //把byte数组中从offset开始处写入长度为len的数据void close() //关闭流，这个是在操作完stream之后必须要调用的方法void flush() //这个方法是用来刷新stream中的数据，让缓冲区中的数据强制的输出</code></pre><h3 id="1-1-FileInputStream-FileOutputStream"><a href="#1-1-FileInputStream-FileOutputStream" class="headerlink" title="1.1 FileInputStream/FileOutputStream"></a>1.1 FileInputStream/FileOutputStream</h3><p>把一个文件作为InputStream/OutputStream，实现对文件的读写操作。</p><h3 id="1-2-FilterInputStream-FilterOutputStream"><a href="#1-2-FilterInputStream-FilterOutputStream" class="headerlink" title="1.2 FilterInputStream/FilterOutputStream"></a>1.2 FilterInputStream/FilterOutputStream</h3><p>一个提供过滤功能的InputStream/OutputStream，并不常用，常用的是他们的子类BufferedInputStream、DataInputS<br>tream、BufferedOutputStream、DataOutputStream和PrintStream。<br>BufferedInputStream提供了将原始数据分批加载到内存的功能，提高处理效率。<br>DataInputStream提供了允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。<br>BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。<br>DataOutputStream提供了允许应用程序以与机器无关方式从底层输入流中写入基本 Java 数据类型。<br>PrintStream是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p><h3 id="1-3-ObjectInputStream-ObjectOutputStream"><a href="#1-3-ObjectInputStream-ObjectOutputStream" class="headerlink" title="1.3 ObjectInputStream/ObjectOutputStream"></a>1.3 ObjectInputStream/ObjectOutputStream</h3><p>对基本数据或对象进行序列化操作。</p><h3 id="1-4-PipedInputStream-PipedOutputStream"><a href="#1-4-PipedInputStream-PipedOutputStream" class="headerlink" title="1.4 PipedInputStream/PipedOutputStream"></a>1.4 PipedInputStream/PipedOutputStream</h3><p>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的<br>PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以<br>实现，线程A和线程B的通信。</p><h3 id="1-5-ByteArrayInputStream-ByteArrayOutputStream"><a href="#1-5-ByteArrayInputStream-ByteArrayOutputStream" class="headerlink" title="1.5 ByteArrayInputStream/ByteArrayOutputStream"></a>1.5 ByteArrayInputStream/ByteArrayOutputStream</h3><p>ByteArrayInputStream它包含一个内部缓冲区，该缓冲区包含从流中读取的字节;<br>ByteArrayOutputStream中的数据被写入一个 byte 数组。</p><h2 id="2-字符流-Reader-Writer"><a href="#2-字符流-Reader-Writer" class="headerlink" title="2 字符流 Reader/Writer"></a>2 字符流 Reader/Writer</h2><p>Reader/Writer和InputStream/OutputStream功能类似，Reader/Writer操作的是字符char而InputStream<br>/OutputStream操作的是字节byte。</p><h3 id="2-1-FileReader-FileWriter"><a href="#2-1-FileReader-FileWriter" class="headerlink" title="2.1 FileReader/FileWriter"></a>2.1 FileReader/FileWriter</h3><p>和FileInputStream/FileOutputStream对应。</p><h3 id="2-2-BufferedReader-BufferedWriter"><a href="#2-2-BufferedReader-BufferedWriter" class="headerlink" title="2.2 BufferedReader/BufferedWriter"></a>2.2 BufferedReader/BufferedWriter</h3><p>和BufferedInputStream/BufferedOutputStream对应。</p><h3 id="2-3-PipedReader-PipedWriter"><a href="#2-3-PipedReader-PipedWriter" class="headerlink" title="2.3 PipedReader/PipedWriter"></a>2.3 PipedReader/PipedWriter</h3><p>和PipedInputStream/PipedOutputStream对应。</p><h3 id="2-4-InputStreamReader-OutputStreamWriter"><a href="#2-4-InputStreamReader-OutputStreamWriter" class="headerlink" title="2.4 InputStreamReader/OutputStreamWriter"></a>2.4 InputStreamReader/OutputStreamWriter</h3><p>实现InputStream/OutputStream和Reader/Writer转换。</p><h3 id="2-5-CharArrayReader-CharArrayWriter"><a href="#2-5-CharArrayReader-CharArrayWriter" class="headerlink" title="2.5 CharArrayReader/CharArrayWriter"></a>2.5 CharArrayReader/CharArrayWriter</h3><p>和ByteArrayInputStream/ByteArrayOutputStream对应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://blog.csdn.net/yczz/article/details/38761237" target="_blank" rel="noopener"> http://blog.csdn.net/yczz/article/details/38761237</a><br>[2] <a href="http://blog.csdn.net/jiangwei0910410003/article/details/22376895" target="_blank" rel="noopener"> http://blog.csdn.net/jiangwei0910410003/article/details/22376895</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：PipedOutputStream和PipedInputStream使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9APipedOutputStream%E5%92%8CPipedInputStream%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<p>Java IO：PipedOutputStream和PipedInputStream使用详解及源码分析</p><h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>PipedOutputStream和PipedInputStream是管道输出流和管道输入流，配合使用可以实现线程间通信。<br>使用管道实现线程间通信的主要流程如下：建立输出流out和输入流in，将out和in绑定，out中写入的数据则会同步写入的in的缓冲区（实际情况是，out中写<br>入数据就是往in的缓冲区写数据，out中没有数据缓冲区）。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>PipedOutputStream提供的API如下：</p><pre><code>//构造函数public PipedOutputStream(PipedInputStream snk);public PipedOutputStream();public synchronized void connect(PipedInputStream snk); //将PipedOutputStream 和 PipedInputSteam绑定public void write(int b); //向output写入bpublic void write(byte b[], int off, int len); //向output写入字节数组bpublic synchronized void flush();//刷新缓冲区,通知其他input读取数据public void close();// 关闭PipedOutputStream提供的API如下：//构造函数public PipedInputStream(PipedOutputStream src);public PipedInputStream(PipedOutputStream src, int pipeSize);public void connect(PipedOutputStream src); //将PipedOutputStream 和 PipedInputSteam绑定protected synchronized void receive(int b); //向input缓冲区写入bsynchronized void receive(byte b[], int off, int len); //向input写入字节数组bpublic synchronized int read(); //读取缓冲区下一个字节public synchronized int read(byte b[], int off, int len) //读取缓冲区字节数组到bpublic synchronized int available();// 缓冲区可读字节数组的个数public void close(); // 关闭</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>/** * 生产者线程 */public class Producer extends Thread {    //输出流    private PipedOutputStream out = new PipedOutputStream();    //构造方法    public Producer(PipedOutputStream out) {        this.out = out;    }    @Override    public void run() {        writeMessage();    }    private void writeMessage() {        StringBuilder sb = new StringBuilder(&quot;Hello World!!!&quot;);        try {            out.write(sb.toString().getBytes());            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}/** * 消费线程 */public class Consumer extends Thread {    //输入流, 默认缓冲区大小为1024    private PipedInputStream in = new PipedInputStream();    //构造方法    public Consumer(PipedInputStream in) {        this.in = in;    }    @Override    public void run() {        readMessage();    }    private void readMessage() {        byte [] buf = new byte[1024];        try {            int len = in.read(buf);            System.out.println(&quot;缓冲区的内容为: &quot; + new String(buf, 0, len));            in.close();        } catch (IOException e) {            e.printStackTrace();        } finally {        }    }}@org.junit.Testpublic void testPiped() {    /**     * 流程     * 1 建立输入输出流     * 2 绑定输入输出流     * 3 向缓冲区写数据     * 4 读取缓冲区数据     */    PipedOutputStream out = new PipedOutputStream();    PipedInputStream in = new PipedInputStream();    Producer producer = new Producer(out);    Consumer consumer = new Consumer(in);    try {        out.connect(in);        producer.start();        consumer.start();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>缓冲区的内容为: Hello World!!!</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><p>按照演示程序运行过程分析源码，主要有 <strong> 构造方法、connect、out写、in读 </strong> 等。</p><h3 id="2-1-PipedOutputStream构造方法"><a href="#2-1-PipedOutputStream构造方法" class="headerlink" title="2.1 PipedOutputStream构造方法"></a>2.1 PipedOutputStream构造方法</h3><pre><code>/** * Creates a piped output stream connected to the specified piped * input stream. Data bytes written to this stream will then be * available as input from &lt;code&gt;snk&lt;/code&gt;. * * @param      snk   The piped input stream to connect to. * @exception  IOException  if an I/O error occurs. */public PipedOutputStream(PipedInputStream snk)  throws IOException {    connect(snk);}/** * Creates a piped output stream that is not yet connected to a * piped input stream. It must be connected to a piped input stream, * either by the receiver or the sender, before being used. * * @see     java.io.PipedInputStream#connect(java.io.PipedOutputStream) * @see     java.io.PipedOutputStream#connect(java.io.PipedInputStream) */public PipedOutputStream() {}</code></pre><h3 id="2-2-PipedInputStream构造方法"><a href="#2-2-PipedInputStream构造方法" class="headerlink" title="2.2 PipedInputStream构造方法"></a>2.2 PipedInputStream构造方法</h3><pre><code>/** * Creates a &lt;code&gt;PipedInputStream&lt;/code&gt; so that it is * connected to the piped output stream * &lt;code&gt;src&lt;/code&gt; and uses the specified pipe size for * the pipe&apos;s buffer. * Data bytes written to &lt;code&gt;src&lt;/code&gt; will then * be available as input from this stream. * * @param      src   the stream to connect to. * @param      pipeSize the size of the pipe&apos;s buffer. * @exception  IOException  if an I/O error occurs. * @exception  IllegalArgumentException if {@code pipeSize &lt;= 0}. * @since      1.6 */public PipedInputStream(PipedOutputStream src, int pipeSize)        throws IOException {    initPipe(pipeSize);    connect(src);}public PipedInputStream(PipedOutputStream src) throws IOException {    this(src, DEFAULT_PIPE_SIZE);}/** * Creates a &lt;code&gt;PipedInputStream&lt;/code&gt; so that it is not yet * {@linkplain #connect(java.io.PipedOutputStream) connected} and * uses the specified pipe size for the pipe&apos;s buffer. * It must be {@linkplain java.io.PipedOutputStream#connect( * java.io.PipedInputStream) * connected} to a &lt;code&gt;PipedOutputStream&lt;/code&gt; before being used. * * @param      pipeSize the size of the pipe&apos;s buffer. * @exception  IllegalArgumentException if {@code pipeSize &lt;= 0}. * @since      1.6 */public PipedInputStream(int pipeSize) {    initPipe(pipeSize);}public PipedInputStream() {    initPipe(DEFAULT_PIPE_SIZE);}</code></pre><h3 id="2-3-PipedOutputStream-connect方法"><a href="#2-3-PipedOutputStream-connect方法" class="headerlink" title="2.3 PipedOutputStream connect方法"></a>2.3 PipedOutputStream connect方法</h3><pre><code>/** * Connects this piped output stream to a receiver. If this object * is already connected to some other piped input stream, an * &lt;code&gt;IOException&lt;/code&gt; is thrown. * &lt;p&gt; * If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream and * &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream, they may * be connected by either the call: * &lt;blockquote&gt;&lt;pre&gt; * src.connect(snk)&lt;/pre&gt;&lt;/blockquote&gt; * or the call: * &lt;blockquote&gt;&lt;pre&gt; * snk.connect(src)&lt;/pre&gt;&lt;/blockquote&gt; * The two calls have the same effect. * * @param      snk   the piped input stream to connect to. * @exception  IOException  if an I/O error occurs. */public synchronized void connect(PipedInputStream snk) throws IOException {    if (snk == null) {        throw new NullPointerException();    } else if (sink != null || snk.connected) {        throw new IOException(&quot;Already connected&quot;);    }    sink = snk; //设置输入流    snk.in = -1; //写入缓冲区下标    snk.out = 0; //读取缓冲区下标    snk.connected = true; //设置连接状态}</code></pre><h3 id="2-4-PipedOutputStream-write方法"><a href="#2-4-PipedOutputStream-write方法" class="headerlink" title="2.4 PipedOutputStream write方法"></a>2.4 PipedOutputStream write方法</h3><pre><code>/** * Writes the specified &lt;code&gt;byte&lt;/code&gt; to the piped output stream. * &lt;p&gt; * Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;. * * @param      b   the &lt;code&gt;byte&lt;/code&gt; to be written. * @exception IOException if the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;, *          {@link #connect(java.io.PipedInputStream) unconnected}, *          closed, or if an I/O error occurs. */public void write(int b)  throws IOException {    if (sink == null) {        throw new IOException(&quot;Pipe not connected&quot;);    }    sink.receive(b); //直接调用输入流方法操作输入流缓冲区}/** * Receives a byte of data.  This method will block if no input is * available. * @param b the byte being received * @exception IOException If the pipe is &lt;a href=&quot;#BROKEN&quot;&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;, *          {@link #connect(java.io.PipedOutputStream) unconnected}, *          closed, or if an I/O error occurs. * @since     JDK1.1 */protected synchronized void receive(int b) throws IOException {    checkStateForReceive(); //检查可写入状态    writeSide = Thread.currentThread(); //获取输入流线程    if (in == out) //满,即缓冲区数据已读取完        awaitSpace();    if (in &lt; 0) { //缓冲区为空        in = 0;        out = 0;    }    buffer[in++] = (byte)(b &amp; 0xFF); //写入,限定为8位    if (in &gt;= buffer.length) { //        in = 0;    }}</code></pre><h3 id="2-5-PipedInputStream-read方法"><a href="#2-5-PipedInputStream-read方法" class="headerlink" title="2.5 PipedInputStream read方法"></a>2.5 PipedInputStream read方法</h3><pre><code>/** * Reads the next byte of data from this piped input stream. The * value byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range * &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. * This method blocks until input data is available, the end of the * stream is detected, or an exception is thrown. * * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the *             stream is reached. * @exception  IOException  if the pipe is *           {@link #connect(java.io.PipedOutputStream) unconnected}, *           &lt;a href=&quot;#BROKEN&quot;&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;, closed, *           or if an I/O error occurs. */public synchronized int read()  throws IOException {    if (!connected) {        throw new IOException(&quot;Pipe not connected&quot;);    } else if (closedByReader) {        throw new IOException(&quot;Pipe closed&quot;);    } else if (writeSide != null &amp;&amp; !writeSide.isAlive()            &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) {        throw new IOException(&quot;Write end dead&quot;);    }    readSide = Thread.currentThread(); //获取当前读取线程    int trials = 2;    while (in &lt; 0) { //没有可读内容        if (closedByWriter) {            /* closed by writer, return EOF */            return -1;        }        if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) {            throw new IOException(&quot;Pipe broken&quot;);        }        /* might be a writer waiting */        notifyAll(); //通知写入        try {            wait(1000);        } catch (InterruptedException ex) {            throw new java.io.InterruptedIOException();        }    }    int ret = buffer[out++] &amp; 0xFF; //读取字节    if (out &gt;= buffer.length) { //超过缓冲区长度,则从头开始读,写的时候一样,所以能保证读写一样顺序        out = 0;    }    if (in == out) { //没有可读内容        /* now empty */        in = -1; //receive中将out置为0    }    return ret;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_04.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_04.html</a><br>[2] <a href="http://www.2cto.com/kf/201402/279143.html" target="_blank" rel="noopener"> http://www.2cto.com/kf/201402/279143.html</a><br>[3] <a href="http://www.cnblogs.com/meng72ndsc/archive/2010/12/23/1915358.html" target="_blank" rel="noopener"> http://www.cnblogs.com/meng72ndsc/archive/2010/12/23/1915358.html</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：PipedReader和PipedWriter使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9APipedReader%E5%92%8CPipedWriter%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<p>Java IO：PipedReader和PipedWriter使用详解及源码分析</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>PipedReader和PipedWriter即管道输入流和输出流，可用于线程间管道通信。它们和PipedInputStream/PipedOutputSt<br>ream区别是前者操作的是字符后者是字节。</p><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>PipedReader提供的API如下：</p><pre><code>//构造方法PipedReader(PipedWriter src)    //使用默认的buf的大小和传入的pw构造prPipedReader(PipedWriter src, int pipeSize)      //使用指定的buf的大小和传入的pw构造prPipedReader()       //使用默认大小构造prPipedReader(int pipeSize)       //使用指定大小构造pr//关闭流void close()//绑定Writervoid connect(PipedWriter src)//是否可读synchronized boolean ready()//读取一个字符synchronized int read()//读取多个字符到cbufsynchronized int read(char cbuf[], int off, int len)//Writer调用, 向Reader缓冲区写数据synchronized void receive(int c)synchronized void receive(char c[], int off, int len)synchronized void receivedLast()</code></pre><p>PipedWriter提供的API如下：</p><pre><code>//构造方法PipedWriter(PipedReader snk)PipedWriter()//绑定Reader Writersynchronized void connect(PipedReader snk)//关闭流void close()//刷新流,唤醒Readersynchronized void flush()//写入1个字符,实际是写到绑定Reader的缓冲区void write(int c)//写入多个字符到Reader缓冲区void write(char cbuf[], int off, int len)</code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code>/** * 写线程 */public class Producer extends Thread {    //输出流    private PipedWriter writer = new PipedWriter();    public Producer(PipedWriter writer) {        this.writer = writer;    }    @Override    public void run() {        try {            StringBuilder sb = new StringBuilder();            sb.append(&quot;Hello World!&quot;);            writer.write(sb.toString());        } catch (Exception e) {            e.printStackTrace();        }    }}/** * 读取线程 */public class Consumer extends Thread{    //输入流    private PipedReader reader = new PipedReader();    public Consumer(PipedReader reader) {        this.reader = reader;    }    @Override    public void run() {        try {            char [] cbuf = new char[20];            reader.read(cbuf, 0, cbuf.length);            System.out.println(&quot;管道流中的数据为: &quot; + new String(cbuf));        } catch (Exception e) {            e.printStackTrace();        }    }}@org.junit.Testpublic void testPipedReaderWriter() {    /**     * 管道流通信核心是,Writer和Reader公用一块缓冲区,缓冲区在Reader中申请,     * 由Writer调用和它绑定的Reader的Receive方法进行写.     *     * 线程间通过管道流通信的步骤为     * 1 建立输入输出流     * 2 绑定输入输出流     * 3 Writer写     * 4 Reader读     */    PipedReader reader = new PipedReader();    PipedWriter writer = new PipedWriter();    Producer producer = new Producer(writer);    Consumer consumer = new Consumer(reader);    try {        writer.connect(reader);        producer.start();        consumer.start();    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>管道流中的数据为: Hello World!</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>按照演示程序运行过程分析源码，主要有 <strong> 构造方法、connect、writer写、reader读 </strong> 等。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="PipedWriter构造方法"><a href="#PipedWriter构造方法" class="headerlink" title="PipedWriter构造方法"></a>PipedWriter构造方法</h4><p>PipedWriter构造方法有两个，区别是是否指定需要连接的PipedReader对象。</p><pre><code>/** * Creates a piped writer connected to the specified piped * reader. Data characters written to this stream will then be * available as input from &lt;code&gt;snk&lt;/code&gt;. * * @param      snk   The piped reader to connect to. * @exception  IOException  if an I/O error occurs. */public PipedWriter(PipedReader snk)  throws IOException {    connect(snk);}/** * Creates a piped writer that is not yet connected to a * piped reader. It must be connected to a piped reader, * either by the receiver or the sender, before being used. * * @see     java.io.PipedReader#connect(java.io.PipedWriter) * @see     java.io.PipedWriter#connect(java.io.PipedReader) */public PipedWriter() {}</code></pre><h4 id="PipedReader-构造方法"><a href="#PipedReader-构造方法" class="headerlink" title="PipedReader 构造方法"></a>PipedReader 构造方法</h4><p>PipedReader构造方法有四个，区别是是否指定要连接的PipedWriter对象以及缓冲区大小设置，默认缓冲区大小为1024。</p><pre><code>/** * Creates a &lt;code&gt;PipedReader&lt;/code&gt; so that it is connected * to the piped writer &lt;code&gt;src&lt;/code&gt; and uses the specified * pipe size for the pipe&apos;s buffer. Data written to &lt;code&gt;src&lt;/code&gt; * will then be  available as input from this stream. * @param      src       the stream to connect to. * @param      pipeSize  the size of the pipe&apos;s buffer. * @exception  IOException  if an I/O error occurs. * @exception  IllegalArgumentException if {@code pipeSize &lt;= 0}. * @since      1.6 */public PipedReader(PipedWriter src, int pipeSize) throws IOException {    initPipe(pipeSize); //设置缓冲区大小    connect(src);  //连接对应的PipedWriter}public PipedReader(PipedWriter src) throws IOException {    this(src, DEFAULT_PIPE_SIZE); //默认缓冲区大小}/** * Creates a &lt;code&gt;PipedReader&lt;/code&gt; so that it is not yet * {@link #connect(java.io.PipedWriter) connected} and uses * the specified pipe size for the pipe&apos;s buffer. * It must be  {@linkplain java.io.PipedWriter#connect( * java.io.PipedReader) connected} to a &lt;code&gt;PipedWriter&lt;/code&gt; * before being used. * * @param   pipeSize the size of the pipe&apos;s buffer. * @exception  IllegalArgumentException if {@code pipeSize &lt;= 0}. * @since      1.6 */public PipedReader(int pipeSize) {    initPipe(pipeSize); //指定大小}public PipedReader() {    initPipe(DEFAULT_PIPE_SIZE); //默认1024}</code></pre><h3 id="connect方法"><a href="#connect方法" class="headerlink" title="connect方法"></a>connect方法</h3><p>PipedWriter和PipedReader都有connect方法，两者作用相同。实际上PipedReader的connect方法是调用PipedWrit<br>er中connect方法实现的。</p><h4 id="PipedWriter-connect方法"><a href="#PipedWriter-connect方法" class="headerlink" title="PipedWriter connect方法"></a>PipedWriter connect方法</h4><pre><code>/** * Connects this piped writer to a receiver. If this object * is already connected to some other piped reader, an * &lt;code&gt;IOException&lt;/code&gt; is thrown. * &lt;p&gt; * If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader and * &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer, they may * be connected by either the call: * &lt;blockquote&gt;&lt;pre&gt; * src.connect(snk)&lt;/pre&gt;&lt;/blockquote&gt; * or the call: * &lt;blockquote&gt;&lt;pre&gt; * snk.connect(src)&lt;/pre&gt;&lt;/blockquote&gt; * The two calls have the same effect. * * @param      snk   the piped reader to connect to. * @exception  IOException  if an I/O error occurs. */public synchronized void connect(PipedReader snk) throws IOException {    if (snk == null) {        throw new NullPointerException();    } else if (sink != null || snk.connected) {        throw new IOException(&quot;Already connected&quot;);    } else if (snk.closedByReader || closed) {        throw new IOException(&quot;Pipe closed&quot;);    }    sink = snk; //绑定对应的PipedReader    snk.in = -1; //写入操作下标    snk.out = 0; //读取操作下标    snk.connected = true; //连接状态}</code></pre><h4 id="PipedReader-connect方法"><a href="#PipedReader-connect方法" class="headerlink" title="PipedReader connect方法"></a>PipedReader connect方法</h4><pre><code>/** * Causes this piped reader to be connected * to the piped  writer &lt;code&gt;src&lt;/code&gt;. * If this object is already connected to some * other piped writer, an &lt;code&gt;IOException&lt;/code&gt; * is thrown. * @param      src   The piped writer to connect to. * @exception  IOException  if an I/O error occurs. */public void connect(PipedWriter src) throws IOException {    src.connect(this); //调用PipedWriter的方法}</code></pre><h3 id="PipedWriter-write方法"><a href="#PipedWriter-write方法" class="headerlink" title="PipedWriter write方法"></a>PipedWriter write方法</h3><p>write有写入一个字符和写入多个字符两种重载方法，实现原理都一样，调用和它绑定的PipedReader的receive方法向缓冲区写数据，下面分析写入多个<br>字符的write方法。</p><pre><code>/** * Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream. * If a thread was reading data characters from the connected piped input * stream, but the thread is no longer alive, then an * &lt;code&gt;IOException&lt;/code&gt; is thrown. * &lt;p&gt; * Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;Writer&lt;/code&gt;. * * @param      c   the &lt;code&gt;char&lt;/code&gt; to be written. * @exception  IOException  if the pipe is *          &lt;a href=PipedOutputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;, *          {@link #connect(java.io.PipedReader) unconnected}, closed *          or an I/O error occurs. */public void write(int c)  throws IOException {    if (sink == null) {        throw new IOException(&quot;Pipe not connected&quot;);    }    sink.receive(c); //调用PipedReader的receive方法}/** * Receives a char of data. This method will block if no input is * available. */synchronized void receive(int c) throws IOException {    if (!connected) {        throw new IOException(&quot;Pipe not connected&quot;);    } else if (closedByWriter || closedByReader) {        throw new IOException(&quot;Pipe closed&quot;);    } else if (readSide != null &amp;&amp; !readSide.isAlive()) {        throw new IOException(&quot;Read end dead&quot;);    }    writeSide = Thread.currentThread(); //获取当前线程    while (in == out) { //满，唤醒读者。（有点疑惑）        if ((readSide != null) &amp;&amp; !readSide.isAlive()) {            throw new IOException(&quot;Pipe broken&quot;);        }        /* full: kick any waiting readers */        notifyAll();        try {            wait(1000);        } catch (InterruptedException ex) {            throw new java.io.InterruptedIOException();        }    }    if (in &lt; 0) {        in = 0;        out = 0;    }    buffer[in++] = (char) c;    if (in &gt;= buffer.length) {        in = 0;    }}</code></pre><h3 id="PipedReader-read方法"><a href="#PipedReader-read方法" class="headerlink" title="PipedReader read方法"></a>PipedReader read方法</h3><p>read方法同样有读取一个字符和读取多个字符两种重载方法，下面分析读取一个字符的read。</p><pre><code>/** * Reads the next character of data from this piped stream. * If no character is available because the end of the stream * has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. * This method blocks until input data is available, the end of * the stream is detected, or an exception is thrown. * * @return     the next character of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the *             stream is reached. * @exception  IOException  if the pipe is *          &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;, *          {@link #connect(java.io.PipedWriter) unconnected}, closed, *          or an I/O error occurs. */public synchronized int read()  throws IOException {    if (!connected) {        throw new IOException(&quot;Pipe not connected&quot;);    } else if (closedByReader) {        throw new IOException(&quot;Pipe closed&quot;);    } else if (writeSide != null &amp;&amp; !writeSide.isAlive()            &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) {        throw new IOException(&quot;Write end dead&quot;);    }    readSide = Thread.currentThread();    int trials = 2;    while (in &lt; 0) { //缓冲区为空        if (closedByWriter) {            /* closed by writer, return EOF */            return -1;        }        if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) {            throw new IOException(&quot;Pipe broken&quot;);        }        /* might be a writer waiting */        notifyAll(); //唤醒写者        try {            wait(1000);        } catch (InterruptedException ex) {            throw new java.io.InterruptedIOException();        }    }    int ret = buffer[out++]; //读    if (out &gt;= buffer.length) {        out = 0;    }    if (in == out) { //所有字符都被读取        /* now empty */        in = -1;    }    return ret;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.2cto.com/kf/201312/263319.html" target="_blank" rel="noopener"> http://www.2cto.com/kf/201312/263319.html</a><br>[2] <a href="http://www.cnblogs.com/skywang12345/p/io_20.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_20.html</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java字符串：StringBuffer使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9AStringBuffer%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>StringBuffer和StringBuilder功能基本相同，他们的区别在于StringBuffer是线程安全的而StringBuilder不是线程安全<br>的。他们的关系和HashMap-Hashtable、Vector-ArrrayList类似。</p><pre><code>public final class StringBuffer        extends AbstractStringBuilder        implements java.io.Serializable, CharSequence{}</code></pre><p>StringBuffer和StringBuilder一样继承了AbstractStringBuilder并且实现了Serializable和CharSequ<br>ence。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>StringBuffer提供的的API主要如下：</p><pre><code>//构造函数StringBuffer()StringBuffer(int capacity)StringBuffer(String string)StringBuffer(CharSequence cs)//追加synchronized StringBuffer     append(boolean b)synchronized StringBuffer     append(int i)synchronized StringBuffer     append(long l)synchronized StringBuffer     append(float f)synchronized StringBuffer     append(double d)synchronized StringBuffer     append(char ch)synchronized StringBuffer     append(char[] chars)synchronized StringBuffer     append(char[] chars, int start, int length)synchronized StringBuffer     append(Object obj)synchronized StringBuffer     append(String string)synchronized StringBuffer     append(StringBuffer sb)synchronized StringBuffer     append(CharSequence s)synchronized StringBuffer     append(CharSequence s, int start, int end)synchronized StringBuffer     appendCodePoint(int codePoint)synchronized int     capacity() //获取容量synchronized char     charAt(int index) //获取index下标的字符synchronized int     codePointAt(int index) //获取index下标的Unicode编码synchronized int     codePointBefore(int index)synchronized int     codePointCount(int beginIndex, int endIndex)synchronized StringBuffer     delete(int start, int end) //删除[start,end)的字符synchronized StringBuffer     deleteCharAt(int location) //删除location下标的字符synchronized void     ensureCapacity(int min) //确认货增加容量(length*2 + 2)synchronized void     getChars(int start, int end, char[] buffer, int idx) //将[start,end)中的字符添加的buffer的idx及以后的位置synchronized int     indexOf(String subString, int start) //获取提一次出现的位置int     indexOf(String string) //通过调用其他同步方法实现同步//插入字符串StringBuffer     insert(int index, boolean b)StringBuffer     insert(int index, int i)StringBuffer     insert(int index, long l)StringBuffer     insert(int index, float f)StringBuffer     insert(int index, double d)synchronized StringBuffer     insert(int index, char ch)synchronized StringBuffer     insert(int index, char[] chars)synchronized StringBuffer     insert(int index, char[] chars, int start, int length)synchronized StringBuffer     insert(int index, String string)StringBuffer     insert(int index, Object obj)synchronized StringBuffer     insert(int index, CharSequence s)synchronized StringBuffer     insert(int index, CharSequence s, int start, int end)int     lastIndexOf(String string)synchronized int     lastIndexOf(String subString, int start)int     length()synchronized int     offsetByCodePoints(int index, int codePointOffset)synchronized StringBuffer     replace(int start, int end, String string) //替换synchronized StringBuffer     reverse() //反转synchronized void     setCharAt(int index, char ch) //替换指定下标的字符synchronized void     setLength(int length)synchronized CharSequence     subSequence(int start, int end)synchronized String     substring(int start) //子串synchronized String     substring(int start, int end)synchronized String     toString()synchronized void     trimToSize()</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public void testStringBuffer() {    //构造并初始化    StringBuffer StringBuffer = new StringBuffer(&quot;0123456&quot;);    //获取容量    System.out.println(&quot;StringBuffer的容量为: &quot; + StringBuffer.capacity());    //获取字符数量    System.out.println(&quot;StringBuffer的字符数量为: &quot; + StringBuffer.length());    //获取指定index的字符    System.out.println(&quot;StringBuffer的第2个字符为: &quot; + StringBuffer.charAt(1));    //子串第一次出现的位置    System.out.println(&quot;\&quot;23\&quot;在StringBuffer中第一次出现的位置为: &quot; + StringBuffer.indexOf(&quot;23&quot;));    //子串最后一次出现的位置,从后往前    System.out.println(&quot;\&quot;34\&quot;在StringBuffer从第5个字符以前的字符串中第一次一次出现的位置为: &quot;            + StringBuffer.lastIndexOf(&quot;34&quot;, 5));    //替换字符串    System.out.println(&quot;将StringBuffer的第2-3个字符替换为abcde: &quot; + StringBuffer.replace(1, 3, &quot;abcde&quot;));    //设置指定位置字符    StringBuffer.setCharAt(1, &apos;A&apos;);    System.out.println(&quot;将第2个字符设置为A: &quot; + StringBuffer);    //删除滴定位置的字符串    StringBuffer.delete(2,5);    System.out.println(&quot;删除第3到第5个字符: &quot; + StringBuffer);    //追加字符    System.out.println(&quot;StringBuffer尾部追加一个7&quot; + StringBuffer.append(&quot;7&quot;));    //追加double    System.out.println(&quot;StringBuffer尾部追加8.0d&quot; + StringBuffer.append(8.0d));    //插入字符串    System.out.println(&quot;StringBuffer第3个字符看是追加test: &quot; + StringBuffer.insert(2, &quot;test&quot;));    String s = null;    System.out.println(&quot;StringBuffer第3个字符看是追加null: &quot; + StringBuffer.insert(2, s));}</code></pre><p>运行结果如下：</p><pre><code>StringBuffer的容量为: 23StringBuffer的字符数量为: 7StringBuffer的第2个字符为: 1&quot;23&quot;在StringBuffer中第一次出现的位置为: 2&quot;34&quot;在StringBuffer从第5个字符以前的字符串中第一次一次出现的位置为: 3将StringBuffer的第2-3个字符替换为abcde: 0abcde3456将第2个字符设置为A: 0Abcde3456删除第3到第5个字符: 0Ae3456StringBuffer尾部追加一个70Ae34567StringBuffer尾部追加8.0d0Ae345678.0StringBuffer第3个字符看是追加test: 0Ateste345678.0StringBuffer第3个字符看是追加null: 0Anullteste345678.0</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>StringBuffer和StringBuilder的构造方法也几乎是相同的。</p><pre><code>/** * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */public StringBuffer() {    super(16);}/** * Constructs a string buffer with no characters in it and * the specified initial capacity. * * @param      capacity  the initial capacity. * @exception  NegativeArraySizeException  if the {@code capacity} *               argument is less than {@code 0}. */public StringBuffer(int capacity) {    super(capacity);}/** * Constructs a string buffer initialized to the contents of the * specified string. The initial capacity of the string buffer is * {@code 16} plus the length of the string argument. * * @param   str   the initial contents of the buffer. */public StringBuffer(String str) {    super(str.length() + 16);    append(str);}</code></pre><h3 id="2-2-insert方法"><a href="#2-2-insert方法" class="headerlink" title="2.2 insert方法"></a>2.2 insert方法</h3><p>insert方法有插入字符串、整形、布尔型等多个重载方法，实现方法都是调用父类AbstractStringBuilder的insert方法。</p><h4 id="2-2-1-插入一个对象"><a href="#2-2-1-插入一个对象" class="headerlink" title="2.2.1 插入一个对象"></a>2.2.1 插入一个对象</h4><pre><code>/** * @throws StringIndexOutOfBoundsException {@inheritDoc} */@Overridepublic  StringBuffer insert(int offset, boolean b) {    // Note, synchronization achieved via invocation of StringBuffer insert(int, String)    // after conversion of b to String by super class method    // Ditto for toStringCache clearing    super.insert(offset, b); //调用父类的insert    return this;}/** * Inserts the string representation of the {@code boolean} * argument into this sequence. * &lt;p&gt; * The overall effect is exactly as if the second argument were * converted to a string by the method {@link String#valueOf(boolean)}, * and the characters of that string were then * {@link #insert(int,String) inserted} into this character * sequence at the indicated offset. * &lt;p&gt; * The {@code offset} argument must be greater than or equal to * {@code 0}, and less than or equal to the {@linkplain #length() length} * of this sequence. * * @param      offset   the offset. * @param      b        a {@code boolean}. * @return     a reference to this object. * @throws     StringIndexOutOfBoundsException  if the offset is invalid. */public AbstractStringBuilder insert(int offset, boolean b) {    return insert(offset, String.valueOf(b)); //子类中insert(int, String),已经重写,调用子类的方法,子类已经保证同步}</code></pre><h4 id="2-2-2-插入一个字符串"><a href="#2-2-2-插入一个字符串" class="headerlink" title="2.2.2 插入一个字符串"></a>2.2.2 插入一个字符串</h4><pre><code>/** * @throws StringIndexOutOfBoundsException {@inheritDoc} */@Overridepublic synchronized StringBuffer insert(int offset, String str) {    toStringCache = null;    super.insert(offset, str);    return this;}/** * Inserts the string into this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are inserted, in * order, into this sequence at the indicated offset, moving up any * characters originally above that position and increasing the length * of this sequence by the length of the argument. If * {@code str} is {@code null}, then the four characters * {@code &quot;null&quot;} are inserted into this sequence. * &lt;p&gt; * The character at index &lt;i&gt;k&lt;/i&gt; in the new character sequence is * equal to: * &lt;ul&gt; * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if * &lt;i&gt;k&lt;/i&gt; is less than {@code offset} * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -offset} in the * argument {@code str}, if &lt;i&gt;k&lt;/i&gt; is not less than * {@code offset} but is less than {@code offset+str.length()} * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -str.length()} in the * old character sequence, if &lt;i&gt;k&lt;/i&gt; is not less than * {@code offset+str.length()} * &lt;/ul&gt;&lt;p&gt; * The {@code offset} argument must be greater than or equal to * {@code 0}, and less than or equal to the {@linkplain #length() length} * of this sequence. * * @param      offset   the offset. * @param      str      a string. * @return     a reference to this object. * @throws     StringIndexOutOfBoundsException  if the offset is invalid. */public AbstractStringBuilder insert(int offset, String str) {    if ((offset &lt; 0) || (offset &gt; length()))        throw new StringIndexOutOfBoundsException(offset);    if (str == null)        str = &quot;null&quot;;    int len = str.length();    ensureCapacityInternal(count + len);    System.arraycopy(value, offset, value, offset + len, count - offset);    str.getChars(value, offset);    count += len;    return this;}</code></pre><h3 id="2-3-append方法"><a href="#2-3-append方法" class="headerlink" title="2.3 append方法"></a>2.3 append方法</h3><pre><code>public synchronized StringBuffer append(String str) {    toStringCache = null;    super.append(str);    return this;}/** * Appends the specified string to this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are appended, in * order, increasing the length of this sequence by the length of the * argument. If {@code str} is {@code null}, then the four * characters {@code &quot;null&quot;} are appended. * &lt;p&gt; * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to * execution of the {@code append} method. Then the character at * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index * &lt;i&gt;k-n&lt;/i&gt; in the argument {@code str}. * * @param   str   a string. * @return  a reference to this object. */public AbstractStringBuilder append(String str) {    if (str == null)        return appendNull();    int len = str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count += len;    return this;}</code></pre><h3 id="2-4-replace方法"><a href="#2-4-replace方法" class="headerlink" title="2.4 replace方法"></a>2.4 replace方法</h3><pre><code>/** * @throws StringIndexOutOfBoundsException {@inheritDoc} * @since      1.2 */@Overridepublic synchronized StringBuffer replace(int start, int end, String str) {    toStringCache = null;    super.replace(start, end, str);    return this;}/** * Replaces the characters in a substring of this sequence * with characters in the specified {@code String}. The substring * begins at the specified {@code start} and extends to the character * at index {@code end - 1} or to the end of the * sequence if no such character exists. First the * characters in the substring are removed and then the specified * {@code String} is inserted at {@code start}. (This * sequence will be lengthened to accommodate the * specified String if necessary.) * * @param      start    The beginning index, inclusive. * @param      end      The ending index, exclusive. * @param      str   String that will replace previous contents. * @return     This object. * @throws     StringIndexOutOfBoundsException  if {@code start} *             is negative, greater than {@code length()}, or *             greater than {@code end}. */public AbstractStringBuilder replace(int start, int end, String str) {    if (start &lt; 0)        throw new StringIndexOutOfBoundsException(start);    if (start &gt; count)        throw new StringIndexOutOfBoundsException(&quot;start &gt; length()&quot;);    if (start &gt; end)        throw new StringIndexOutOfBoundsException(&quot;start &gt; end&quot;);    if (end &gt; count)        end = count;    int len = str.length();    int newCount = count + len - (end - start);    ensureCapacityInternal(newCount);    System.arraycopy(value, end, value, start + len, count - end);    str.getChars(value, start);    count = newCount;    return this;}</code></pre><h3 id="2-5-delete方法"><a href="#2-5-delete方法" class="headerlink" title="2.5 delete方法"></a>2.5 delete方法</h3><pre><code>/** * @throws StringIndexOutOfBoundsException {@inheritDoc} * @since      1.2 */@Overridepublic synchronized StringBuffer delete(int start, int end) {    toStringCache = null;    super.delete(start, end);    return this;}/** * Removes the characters in a substring of this sequence. * The substring begins at the specified {@code start} and extends to * the character at index {@code end - 1} or to the end of the * sequence if no such character exists. If * {@code start} is equal to {@code end}, no changes are made. * * @param      start  The beginning index, inclusive. * @param      end    The ending index, exclusive. * @return     This object. * @throws     StringIndexOutOfBoundsException  if {@code start} *             is negative, greater than {@code length()}, or *             greater than {@code end}. */public AbstractStringBuilder delete(int start, int end) {    if (start &lt; 0)        throw new StringIndexOutOfBoundsException(start);    if (end &gt; count)        end = count;    if (start &gt; end)        throw new StringIndexOutOfBoundsException();    int len = end - start;    if (len &gt; 0) {        System.arraycopy(value, start+len, value, start, count-end);        count -= len;    }    return this;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/string03.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/string03.html</a><br>[2] <a href="http://blog.csdn.net/linbooooo1987/article/details/7531517" target="_blank" rel="noopener"> http://blog.csdn.net/linbooooo1987/article/details/7531517</a></p>]]></content>
      
      <categories>
          
          <category> Java字符串 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java字符串：String、StringBuilder、StringBuffer区别</title>
      <link href="/2017/11/11/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9AString%E3%80%81StringBuilder%E3%80%81StringBuffer%E5%8C%BA%E5%88%AB/"/>
      <content type="html"><![CDATA[<p>在学习String、StringBuilder、StringBuffer这三个类的时候在github上看到如下几个问题：</p><h3 id="1-成员变量、局部变量在什么场景下用哪个更合适"><a href="#1-成员变量、局部变量在什么场景下用哪个更合适" class="headerlink" title="1. 成员变量、局部变量在什么场景下用哪个更合适"></a>1. 成员变量、局部变量在什么场景下用哪个更合适</h3><h3 id="2-他们之间效率如何，为什么"><a href="#2-他们之间效率如何，为什么" class="headerlink" title="2. 他们之间效率如何，为什么"></a>2. 他们之间效率如何，为什么</h3><h3 id="3-有没有存在特殊情况"><a href="#3-有没有存在特殊情况" class="headerlink" title="3. 有没有存在特殊情况"></a>3. 有没有存在特殊情况</h3><h3 id="4-编译器对他们的优化"><a href="#4-编译器对他们的优化" class="headerlink" title="4. 编译器对他们的优化"></a>4. 编译器对他们的优化</h3><p>下面尝试对这几个问题进行回答  </p><h3 id="回答1："><a href="#回答1：" class="headerlink" title="回答1："></a>回答1：</h3><p>String是不可变的字符串，任何拼接、修改操作都是返回的新的String对象，原对象并没有改变；StringBuilder和StringBuffer是可变<br>字符串，修改操作改变的是原有的对象。StringBuilder和StringBuffer的区别是StringBuffer是线程安全的，他的大部分API都使用<br>synchronized 关键字修饰。所以针对这三个类的使用场景归纳如下<br>1）修改操作较少的场景可以用String；<br>2）单线程情况下字符串需要大量操作的适合使用StringBuilder；<br>3）多线程操作情况下大量操作字符串适合使用StringBuffer。</p><h3 id="回答2："><a href="#回答2：" class="headerlink" title="回答2："></a>回答2：</h3><p>String的修改、拼接等操作由于需要重新申请新对象所以速度一般情况下比StringBuilder和StringBuffer慢。StringBuffer<br>API采用synchronized修饰，一般速度会比StringBuilder慢。</p><h3 id="回答3："><a href="#回答3：" class="headerlink" title="回答3："></a>回答3：</h3><p>用例子回答这个问题</p><pre><code>String s = “a” + “b” + “c” + “d”;StringBuilder sb = new StringBuilder(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;).append(&quot;d&quot;);</code></pre><p>回答2指出StringBuilder速度比String快，这两个语句执行效率情况如下：</p><pre><code>public void testSpeed() {    long t1 = System.nanoTime();    String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; + &quot;d&quot;;    long t2 = System.nanoTime();    System.out.println(&quot;String耗时为: &quot; + (t2 - t1));    long t3 = System.nanoTime();    StringBuilder sb = new StringBuilder(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;).append(&quot;d&quot;);    long t4 = System.nanoTime();    System.out.println(&quot;StringBuilder耗时为: &quot; + (t4 -t3));}</code></pre><p>执行结果为：</p><pre><code>String耗时为: 3611StringBuilder耗时为: 13617</code></pre><h3 id="回答4："><a href="#回答4：" class="headerlink" title="回答4："></a>回答4：</h3><p>回答3中指出了String效率可能会比StringBuilder高，产生这种情况的原因是JVM对此进行了优化。理论上说String s = “a” +<br>“b” + “c” + “d”; 这条语句会产生4个对象，实际向JVM将这条语句优化为String s = “abcd”;所以效率高。</p>]]></content>
      
      <categories>
          
          <category> Java字符串 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java字符串：StringBuilder使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9AStringBuilder%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>StringBuilder是可变字符串，和String的主要区别是他的字符串是可变的，例如拼接等操作不会重返回新的StringBuilder实例。</p><pre><code>public final class StringBuilder        extends AbstractStringBuilder        implements java.io.Serializable, CharSequence{}</code></pre><p>StringBuilder继承了AbstractStringBuilder并且实现了Serializable和CharSequence。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>StringBuilder提供的的API主要如下：</p><pre><code>//构造函数StringBuilder()StringBuilder(int capacity)StringBuilder(CharSequence seq)StringBuilder(String str)//尾部添加字符(串)StringBuilder     append(float f)StringBuilder     append(double d)StringBuilder     append(boolean b)StringBuilder     append(int i)StringBuilder     append(long l)StringBuilder     append(char c)StringBuilder     append(char[] chars)StringBuilder     append(char[] str, int offset, int len)StringBuilder     append(String str)StringBuilder     append(Object obj)StringBuilder     append(StringBuffer sb)StringBuilder     append(CharSequence csq)StringBuilder     append(CharSequence csq, int start, int end)StringBuilder     appendCodePoint(int codePoint)int     capacity() //容量char     charAt(int index) //获取index下标的字符int     codePointAt(int index) //获取index下标字符的Unicode编码int     codePointBefore(int index)int     codePointCount(int start, int end)StringBuilder     delete(int start, int end) //删除[start,end)之间的字符StringBuilder     deleteCharAt(int index) //删除index下标的字符void     getChars(int start, int end, char[] dst, int dstStart) //获取将[start,end)间的字符填充到到dst中,dstStart为开始位置int     indexOf(String subString, int start) //子串的第一次出现位置, 从start开始查找int     indexOf(String string) //子串的第一次出现位置//插入字符StringBuilder     insert(int offset, boolean b)StringBuilder     insert(int offset, int i)StringBuilder     insert(int offset, long l)StringBuilder     insert(int offset, float f)StringBuilder     insert(int offset, double d)StringBuilder     insert(int offset, char c)StringBuilder     insert(int offset, char[] ch)StringBuilder     insert(int offset, char[] str, int strOffset, int strLen)StringBuilder     insert(int offset, String str)StringBuilder     insert(int offset, Object obj)StringBuilder     insert(int offset, CharSequence s)StringBuilder     insert(int offset, CharSequence s, int start, int end)int     lastIndexOf(String string) //子串从后往前第一次出现的位置int     lastIndexOf(String subString, int start)int     length() //StringBuilder中字符数量StringBuilder     replace(int start, int end, String string) //将[start,end)替换为stringStringBuilder     reverse() //反转字符串void     setCharAt(int index, char ch) //将index字符设置为chCharSequence     subSequence(int start, int end) //获取子串String     substring(int start)String     substring(int start, int end)String     toString()void     trimToSize()</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>@Componentpublic class TestStringBuilder {    public void testStringBuilder() {        //构造并初始化        StringBuilder stringBuilder = new StringBuilder(&quot;0123456&quot;);        //获取容量        System.out.println(&quot;stringBuilder的容量为: &quot; + stringBuilder.capacity());        //获取字符数量        System.out.println(&quot;stringBuilder的字符数量为: &quot; + stringBuilder.length());        //获取指定index的字符        System.out.println(&quot;stringBuilder的第2个字符为: &quot; + stringBuilder.charAt(1));        //子串第一次出现的位置        System.out.println(&quot;\&quot;23\&quot;在stringBuilder中第一次出现的位置为: &quot; + stringBuilder.indexOf(&quot;23&quot;));        //子串最后一次出现的位置,从后往前        System.out.println(&quot;\&quot;34\&quot;在stringBuilder从第5个字符以前的字符串中第一次一次出现的位置为: &quot;                + stringBuilder.lastIndexOf(&quot;34&quot;, 5));        //替换字符串        System.out.println(&quot;将stringBuilder的第2-3个字符替换为abcde: &quot; + stringBuilder.replace(1, 3, &quot;abcde&quot;));        //设置指定位置字符        stringBuilder.setCharAt(1, &apos;A&apos;);        System.out.println(&quot;将第2个字符设置为A: &quot; + stringBuilder);        //删除滴定位置的字符串        stringBuilder.delete(2,5);        System.out.println(&quot;删除第3到第5个字符: &quot; + stringBuilder);        //追加字符        System.out.println(&quot;stringBuilder尾部追加一个7&quot; + stringBuilder.append(&quot;7&quot;));        //追加double        System.out.println(&quot;stringBuilder尾部追加8.0d&quot; + stringBuilder.append(8.0d));        //插入字符串        System.out.println(&quot;stringBuilder第3个字符看是追加test: &quot; + stringBuilder.insert(2, &quot;test&quot;));    }}</code></pre><p>运行结果如下：</p><pre><code>stringBuilder的容量为: 23stringBuilder的字符数量为: 7stringBuilder的第2个字符为: 1&quot;23&quot;在stringBuilder中第一次出现的位置为: 2&quot;34&quot;在stringBuilder从第5个字符以前的字符串中第一次一次出现的位置为: 3将stringBuilder的第2-3个字符替换为abcde: 0abcde3456将第2个字符设置为A: 0Abcde3456删除第3到第5个字符: 0Ae3456stringBuilder尾部追加一个70Ae34567stringBuilder尾部追加8.0d0Ae345678.0stringBuilder第3个字符看是追加test: 0Ateste345678.0</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>StringBuilder的构造函数有多个，基本的区别是初始容量大小和是否用字符串进行初始化，下面列举3个典型的构造方法。</p><pre><code>/** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. */public StringBuilder() {    super(16);}/** * Constructs a string builder with no characters in it and an * initial capacity specified by the {@code capacity} argument. * * @param      capacity  the initial capacity. * @throws     NegativeArraySizeException  if the {@code capacity} *               argument is less than {@code 0}. */public StringBuilder(int capacity) {    super(capacity);}/** * Constructs a string builder initialized to the contents of the * specified string. The initial capacity of the string builder is * {@code 16} plus the length of the string argument. * * @param   str   the initial contents of the buffer. */public StringBuilder(String str) {    super(str.length() + 16);    append(str);}</code></pre><h3 id="2-2-insert方法"><a href="#2-2-insert方法" class="headerlink" title="2.2 insert方法"></a>2.2 insert方法</h3><p>insert方法有插入字符串、整形、布尔型等多个重载方法，实现方法都是调用父类AbstractStringBuilder的insert方法。</p><h4 id="2-2-1-插入一个对象"><a href="#2-2-1-插入一个对象" class="headerlink" title="2.2.1 插入一个对象"></a>2.2.1 插入一个对象</h4><pre><code>/** * 插入一个对象(int/boolean/double....etc) * @throws StringIndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder insert(int offset, Object obj) {    super.insert(offset, obj); //调用AbstractStringBuilder类中的insert方法    return this;}/** * 父类AbstractStringBuilder中的方法 * @param offset * @param obj * @return */public AbstractStringBuilder insert(int offset, Object obj) {    return insert(offset, String.valueOf(obj)); //调用insert(int offset, String str)}/** * Inserts the string into this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are inserted, in * order, into this sequence at the indicated offset, moving up any * characters originally above that position and increasing the length * of this sequence by the length of the argument. If * {@code str} is {@code null}, then the four characters * {@code &quot;null&quot;} are inserted into this sequence. * &lt;p&gt; * The character at index &lt;i&gt;k&lt;/i&gt; in the new character sequence is * equal to: * &lt;ul&gt; * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if * &lt;i&gt;k&lt;/i&gt; is less than {@code offset} * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -offset} in the * argument {@code str}, if &lt;i&gt;k&lt;/i&gt; is not less than * {@code offset} but is less than {@code offset+str.length()} * &lt;li&gt;the character at index &lt;i&gt;k&lt;/i&gt;{@code -str.length()} in the * old character sequence, if &lt;i&gt;k&lt;/i&gt; is not less than * {@code offset+str.length()} * &lt;/ul&gt;&lt;p&gt; * The {@code offset} argument must be greater than or equal to * {@code 0}, and less than or equal to the {@linkplain #length() length} * of this sequence. * * @param      offset   the offset. * @param      str      a string. * @return     a reference to this object. * @throws     StringIndexOutOfBoundsException  if the offset is invalid. */public AbstractStringBuilder insert(int offset, String str) {    if ((offset &lt; 0) || (offset &gt; length()))        throw new StringIndexOutOfBoundsException(offset);    if (str == null)        str = &quot;null&quot;; //str为null时    int len = str.length();    ensureCapacityInternal(count + len); //确定容量是否够用,不够则增加(length*2 + 2)    System.arraycopy(value, offset, value, offset + len, count - offset); //offset开始的字符后移len位    str.getChars(value, offset); //str字符填充    count += len;    return this;}</code></pre><h4 id="2-2-2-插入一个字符串"><a href="#2-2-2-插入一个字符串" class="headerlink" title="2.2.2 插入一个字符串"></a>2.2.2 插入一个字符串</h4><pre><code>/** * 插入字符串 * @throws IndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder insert(int dstOffset, CharSequence s,                            int start, int end){    super.insert(dstOffset, s, start, end);    return this;}/** * Inserts the string representation of a subarray of the {@code str} * array argument into this sequence. The subarray begins at the * specified {@code offset} and extends {@code len} {@code char}s. * The characters of the subarray are inserted into this sequence at * the position indicated by {@code index}. The length of this * sequence increases by {@code len} {@code char}s. * * @param      index    position at which to insert subarray. * @param      str       A {@code char} array. * @param      offset   the index of the first {@code char} in subarray to *             be inserted. * @param      len      the number of {@code char}s in the subarray to *             be inserted. * @return     This object * @throws     StringIndexOutOfBoundsException  if {@code index} *             is negative or greater than {@code length()}, or *             {@code offset} or {@code len} are negative, or *             {@code (offset+len)} is greater than *             {@code str.length}. */public AbstractStringBuilder insert(int index, char[] str, int offset,                                    int len){    if ((index &lt; 0) || (index &gt; length()))        throw new StringIndexOutOfBoundsException(index);    if ((offset &lt; 0) || (len &lt; 0) || (offset &gt; str.length - len))        throw new StringIndexOutOfBoundsException(                &quot;offset &quot; + offset + &quot;, len &quot; + len + &quot;, str.length &quot;                        + str.length);    ensureCapacityInternal(count + len); //确定容量    System.arraycopy(value, index, value, index + len, count - index); //后移len位    System.arraycopy(str, offset, value, index, len); //将str从offset开始的len个字符复制到value    count += len;    return this;}</code></pre><h3 id="2-3-append方法"><a href="#2-3-append方法" class="headerlink" title="2.3 append方法"></a>2.3 append方法</h3><p>append和insert方法类似，也有很多重载版本，主要是追加对象或者字符串，也是调用父类的方法。</p><pre><code>/** * Appends the specified {@code StringBuffer} to this sequence. * &lt;p&gt; * The characters of the {@code StringBuffer} argument are appended, * in order, to this sequence, increasing the * length of this sequence by the length of the argument. * If {@code sb} is {@code null}, then the four characters * {@code &quot;null&quot;} are appended to this sequence. * &lt;p&gt; * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to * execution of the {@code append} method. Then the character at index * &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character at * index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less than * &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index &lt;i&gt;k-n&lt;/i&gt; * in the argument {@code sb}. * * @param   sb   the {@code StringBuffer} to append. * @return  a reference to this object. */public StringBuilder append(StringBuffer sb) {    super.append(sb);    return this;}/** * Appends the specified string to this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are appended, in * order, increasing the length of this sequence by the length of the * argument. If {@code str} is {@code null}, then the four * characters {@code &quot;null&quot;} are appended. * &lt;p&gt; * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to * execution of the {@code append} method. Then the character at * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index * &lt;i&gt;k-n&lt;/i&gt; in the argument {@code str}. * * @param   str   a string. * @return  a reference to this object. */public AbstractStringBuilder append(String str) {    if (str == null)        return appendNull();    int len = str.length();    ensureCapacityInternal(count + len); //确定容量    str.getChars(0, len, value, count); //将str追缴到value最后    count += len;    return this;}</code></pre><h3 id="2-4-replace方法"><a href="#2-4-replace方法" class="headerlink" title="2.4 replace方法"></a>2.4 replace方法</h3><pre><code>/** * @throws StringIndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder replace(int start, int end, String str) {    super.replace(start, end, str);    return this;}/** * Replaces the characters in a substring of this sequence * with characters in the specified {@code String}. The substring * begins at the specified {@code start} and extends to the character * at index {@code end - 1} or to the end of the * sequence if no such character exists. First the * characters in the substring are removed and then the specified * {@code String} is inserted at {@code start}. (This * sequence will be lengthened to accommodate the * specified String if necessary.) * * @param      start    The beginning index, inclusive. * @param      end      The ending index, exclusive. * @param      str   String that will replace previous contents. * @return     This object. * @throws     StringIndexOutOfBoundsException  if {@code start} *             is negative, greater than {@code length()}, or *             greater than {@code end}. */public AbstractStringBuilder replace(int start, int end, String str) {    if (start &lt; 0)        throw new StringIndexOutOfBoundsException(start);    if (start &gt; count)        throw new StringIndexOutOfBoundsException(&quot;start &gt; length()&quot;);    if (start &gt; end)        throw new StringIndexOutOfBoundsException(&quot;start &gt; end&quot;);    if (end &gt; count)        end = count;    int len = str.length();    int newCount = count + len - (end - start); //新数组长度    ensureCapacityInternal(newCount); //确定容量    System.arraycopy(value, end, value, start + len, count - end); //将value从end开始的字符移动到start+len的位置,共count -end个    str.getChars(value, start); //填充字符    count = newCount;    return this;}</code></pre><h3 id="2-5-delete方法"><a href="#2-5-delete方法" class="headerlink" title="2.5 delete方法"></a>2.5 delete方法</h3><pre><code>/** * @throws StringIndexOutOfBoundsException {@inheritDoc} */@Overridepublic StringBuilder delete(int start, int end) {    super.delete(start, end);    return this;}/** * Removes the characters in a substring of this sequence. * The substring begins at the specified {@code start} and extends to * the character at index {@code end - 1} or to the end of the * sequence if no such character exists. If * {@code start} is equal to {@code end}, no changes are made. * * @param      start  The beginning index, inclusive. * @param      end    The ending index, exclusive. * @return     This object. * @throws     StringIndexOutOfBoundsException  if {@code start} *             is negative, greater than {@code length()}, or *             greater than {@code end}. */public AbstractStringBuilder delete(int start, int end) {    if (start &lt; 0)        throw new StringIndexOutOfBoundsException(start);    if (end &gt; count)        end = count;    if (start &gt; end)        throw new StringIndexOutOfBoundsException();    int len = end - start;    if (len &gt; 0) {        //将value从start+len开始的count-end个字符复制到start开始的位置,即向前覆盖掉要删除的字符串        System.arraycopy(value, start+len, value, start, count-end);        count -= len;    }    return this;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://blog.csdn.net/jiutianhe/article/details/42171103" target="_blank" rel="noopener"> http://blog.csdn.net/jiutianhe/article/details/42171103</a><br>[2] <a href="http://www.cnblogs.com/skywang12345/p/string02.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/string02.html</a></p>]]></content>
      
      <categories>
          
          <category> Java字符串 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：并发基础概念</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <content type="html"><![CDATA[<p>并发编程可以使我们的程序执行速度得到提高，多进程和多线程是常见的并发技术。</p><p><strong> 1、多进程 </strong><br><strong> 2、多线程 </strong><br><strong> 3、Java并发编程采用的方法 </strong></p><hr><h4 id="1、多进程"><a href="#1、多进程" class="headerlink" title="1、多进程"></a>1、多进程</h4><p>多进程是实现并发技术最直接的方法，它是操作系统级别的，操作系统周期性的快速的将CPU在给各个进程间切换，达到并发的目的。多进程的特点是每个进程都有自己的系统<br>资源、地址空间等，进程之间的运行不会相互影响。进程和程序的区别就是进程是正在执行的指令集，而程序是静态的指令集。多进程的调度采用抢占式的方式。</p><h4 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h4><p>多线程可以实现进程内部的并发，它是进程执行的单位，每个进程至少会有一个主线程。多线程的特点是每个线程拥有自己的堆栈和计数器等，但是他们没有自己独立的系统资源<br>和地址空间，它与同一进程的所有线程共享进程的全部资源。所以，线程可以独立的运行，但是线程的运行可能会影响同一进程的其他线程。多线程的调度和多进程一样采用抢占<br>式的方式，可以防止其他线程一直等待。</p><h4 id="3、Java并发编程采用的方法"><a href="#3、Java并发编程采用的方法" class="headerlink" title="3、Java并发编程采用的方法"></a>3、Java并发编程采用的方法</h4><p>java中并发采用多线程的方式， <strong> <em> 《Java编程思想》 </em> </strong> 中介绍了Java的一个重要设计目标就是对系统透明，而多进程是系统级别的。Java<br>早期的重要目标系统Mac并不支持多任务，只有采用多线程技术才能在Mac系统上实现并发。为了满足“一次编写，到处运行”的目标，Java并发采用了多线程技术。<br>3.1 线程的创建成本小。由于线程共享进程的系统资源和地址空间，所以创建新的线程不需要再重新分配。<br>3.2 线程共享进程的内存空间、文件句柄等，进程拥有独立的内存空间，线程比进程执行更高效。<br>3.3 线程间共享代码段，进程变量等数据是的线程间通信更加方便。</p>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：ThreadPoolExecutor类及方法源码分析</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9AThreadPoolExecutor%E7%B1%BB%E5%8F%8A%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<p>ThreadPoolExecutor是jdk自带线程池实现类，现有的Executors工具类实现的几种线程池核心都是调用ThreadPoolExecutor<br>类。ThreadPoolExecutor在jdk1.7及以后做了部分修改， <strong> 本文以JDK1.8为准 </strong> 。</p><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h2><p>ThreadPoolExecutor类共有4个构造函数，其他三个构造函数都是调用下参数最全的一个，下面只介绍参数最全的的一个。</p><pre><code>public ThreadPoolExecutor(int corePoolSize,  //参数的意义已经在上一篇中介绍                             int maximumPoolSize,                             long keepAliveTime,                             TimeUnit unit,                             BlockingQueue&lt;Runnable&gt; workQueue,                             ThreadFactory threadFactory,                             RejectedExecutionHandler handler) {       if (corePoolSize &lt; 0 ||  //参数检查           maximumPoolSize &lt;= 0 ||           maximumPoolSize &lt; corePoolSize ||           keepAliveTime &lt; 0)           throw new IllegalArgumentException();       if (workQueue == null || threadFactory == null || handler == null)           throw new NullPointerException();       this.corePoolSize = corePoolSize; //设置基本线程数       this.maximumPoolSize = maximumPoolSize; //设置最大线程数       this.workQueue = workQueue;  //设置任务队列       this.keepAliveTime = unit.toNanos(keepAliveTime); //设置存活时间       this.threadFactory = threadFactory; //设置线程工厂       this.handler = handler; //设局拒绝策略   }</code></pre><h2 id="2-ThreadPoolExecutor类的方法"><a href="#2-ThreadPoolExecutor类的方法" class="headerlink" title="2 ThreadPoolExecutor类的方法"></a>2 ThreadPoolExecutor类的方法</h2><p>ThreadPoolExecutor类的主要方法有提交任务的execute()方法和submit()方法，终止线程的shutdown()方法和shutdow<br>mNow方法。<br><strong> execute方法用于提交任务，在Executor接口中声明并在ThreadPoolExecutor类中实现。 </strong><br><strong> submit方法用于提交任务并且有返回结果，在ExecutorService中声明并且在AbstractExecutorService类中实现，ThreadPoolExecutor类并没有重写。 </strong><br><strong> shutdown方法用于关闭线程池，但是允许正在运行的任务运行完，将状态置为SHUTDOWN。 </strong><br><strong> shutdownNow方法在关闭线程池时尝试终止正在运行的任务，将状态置为STOP。 </strong></p><h2 id="3-ThreadPoolExecutor类重要方法源码分析"><a href="#3-ThreadPoolExecutor类重要方法源码分析" class="headerlink" title="3 ThreadPoolExecutor类重要方法源码分析"></a>3 ThreadPoolExecutor类重要方法源码分析</h2><h3 id="3-1-execute方法源码分析"><a href="#3-1-execute方法源码分析" class="headerlink" title="3.1 execute方法源码分析"></a>3.1 execute方法源码分析</h3><p>execute方法在JDK1.7及以后具体实现做了重大修改，分析execute源码之前先列举ThreadPoolExecutor类定义的一些常量。</p><pre><code>  private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); //采用原子整型来记录线程数量及状态private static final int COUNT_BITS = Integer.SIZE - 3;  //线程池中线程数量存在低29位，高3位是线程池状态private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;// runState is stored in the high-order bitsprivate static final int RUNNING    = -1 &lt;&lt; COUNT_BITS; //private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;private static final int STOP       =  1 &lt;&lt; COUNT_BITS;private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;// Packing and unpacking ctlprivate static int runStateOf(int c)    { return c &amp; ~CAPACITY; }private static int workerCountOf(int c)  { return c &amp; CAPACITY; }private static int ctlOf(int rs, int wc) { return rs | wc; }</code></pre><p><strong> 线程池的五种状态： </strong><br><strong> RUNNING 在ThreadPoolExecutor被实例化的时候就是这个状态。 </strong><br><strong> SHUTDOWN 通常是已经执行过shutdown()方法，不再接受新任务，等待线程池中和队列中任务完成。 </strong><br><strong> STOP 通常是已经执行过shutdownNow()方法，不接受新任务，队列中的任务也不再执行，并尝试终止线程池中的线程。 </strong><br><strong> TIDYING 线程池为空，就会到达这个状态，执行terminated()方法。 </strong><br><strong> TERMINATED terminated()执行完毕，就会到达这个状态。 </strong><br>下面直接上代码，代码分析放在注释里：</p><pre><code>public void execute(Runnable command) {        if (command == null) //参数检查            throw new NullPointerException();        int c = ctl.get(); //获取当前记录线程池状态和池中线程数量的变量        if (workerCountOf(c) &lt; corePoolSize) { //如果当前线程池中线程数量小于基本线程数量            if (addWorker(command, true))  //新起一个线程处理任务，并将这个任务作为这个线程的第一个任务                return;            c = ctl.get(); //增加线程失败，再次获取变量。（其他线程可能改变了线程池中线程数量，线程也可能die）        }        if (isRunning(c) &amp;&amp; workQueue.offer(command)) { //如果线程池还是RUNNING状态就将任务加入工作队列            int recheck = ctl.get(); //需要double check主要是时间差的问题，在上一句和这一句中间其他线程可能改变了线程池状态            if (! isRunning(recheck) &amp;&amp; remove(command)) //如果线程池状态不再是RUNNING，则从工作队列移除这个任务                reject(command); //移除任务成功，对这个任务使用拒绝策略            else if (workerCountOf(recheck) == 0) //如果线程池状态是RUNNING，并且线程数量为0，说明基本线程数为0                addWorker(null, false); //线程池启动一个线程,启动后并不直接处理任务，并且判断界限变为maximumPoolSize        }        else if (!addWorker(command, false))  //如果工作队列已满，则增加线程处理，线程判断条件变为maximumPoolSize            reject(command);    }</code></pre><p>忽略细节后总的逻辑如下：<br><strong> 第一，线程池中线程数量小于基本线程数（corePoolSize），则启动新线程处理新的任务。 </strong><br><strong> 第二，线程池中线程数不小于基本线程数，则将任务加入工作队列。 </strong><br><strong> 第三，工作队列如果已满，判断线程数如果小于最大线程数（maximumPoolSize），则启动新线程处理当前任务。 </strong><br>execute方法中最核心的方法就是addWorker方法，这个方法负责创建线程，下面重点分析洗addWorker源码。</p><pre><code>private boolean addWorker(Runnable firstTask, boolean core) {     retry:     for (;;) {         int c = ctl.get();         int rs = runStateOf(c); //获取线程池状态         // Check if queue empty only if necessary.         if (rs &gt;= SHUTDOWN &amp;&amp;             ! (rs == SHUTDOWN &amp;&amp; //队列没有任务并且没有提交新任务则不会创建新线程                firstTask == null &amp;&amp;                ! workQueue.isEmpty()))             return false;         for (;;) {             int wc = workerCountOf(c);             if (wc &gt;= CAPACITY ||                 wc &gt;= (core ? corePoolSize : maximumPoolSize)) //线程数量大于线程池容量或者传入的最大池数量则不会创建新线程                 return false;             if (compareAndIncrementWorkerCount(c)) //如果线程池的状态和线程数量都没有改变，则将线程数量+1并且开始真正创建线程                 break retry;             c = ctl.get();  // Re-read ctl，线程数量或者线程池状态改变重新获取线程状态             if (runStateOf(c) != rs) //线程池状态改变则重新判断是否要创建新线程                 continue retry;             // else CAS failed due to workerCount change; retry inner loop         }     }     boolean workerStarted = false;     boolean workerAdded = false;     //private final class Worker extends AbstractQueuedSynchronizer implements Runnable     Worker w = null;     try {         w = new Worker(firstTask);         final Thread t = w.thread;         if (t != null) {             final ReentrantLock mainLock = this.mainLock;             mainLock.lock(); //加锁，防止其他线程同事操作             try {                 // Recheck while holding lock.                 // Back out on ThreadFactory failure or if                 // shut down before lock acquired.                 int rs = runStateOf(ctl.get());//获取线程状态                 if (rs &lt; SHUTDOWN ||                     (rs == SHUTDOWN &amp;&amp; firstTask == null)) { //检查线程池状态                     if (t.isAlive()) // precheck that t is startable                         throw new IllegalThreadStateException();                     workers.add(w);  //添加创建好的worker对象                     int s = workers.size();                     if (s &gt; largestPoolSize) //更新线程池最大数量记录                         largestPoolSize = s;                     workerAdded = true;                 }             } finally {                 mainLock.unlock();             }             if (workerAdded) {                 t.start();  //启动线程                 workerStarted = true;             }         }     } finally {         if (! workerStarted) //线程未启动成功，失败处理             addWorkerFailed(w);     }     return workerStarted; }</code></pre><h3 id="3-2-shutdown方法源码分析"><a href="#3-2-shutdown方法源码分析" class="headerlink" title="3.2 shutdown方法源码分析"></a>3.2 shutdown方法源码分析</h3><p><strong> shutdown方法关闭线程池时将线程池的状态置为SHUTDOWN，不再接受新任务，等待队列中的任务执行完成。 </strong></p><pre><code>public void shutdown() {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            checkShutdownAccess(); //检查当前线程是否有权限终端线程池中的所有线程            advanceRunState(SHUTDOWN); //将线程池状态改为SHUTDOWN            interruptIdleWorkers(); //中断空闲线程            onShutdown(); // hook for ScheduledThreadPoolExecutor        } finally {            mainLock.unlock();        }        tryTerminate(); //将线程池状态置为TERMINATED    }</code></pre><h3 id="3-3-shutdownNow方法源码分析"><a href="#3-3-shutdownNow方法源码分析" class="headerlink" title="3.3 shutdownNow方法源码分析"></a>3.3 shutdownNow方法源码分析</h3><p><strong> shutdownNow方法关闭线程池时将线程池的状态置为STOP，并且停止队列中正在进行的任务。 </strong></p><pre><code>public List&lt;Runnable&gt; shutdownNow() {        List&lt;Runnable&gt; tasks;        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            checkShutdownAccess();            advanceRunState(STOP); //将线程池状态改为STOP            interruptWorkers();            tasks = drainQueue(); //和shutdown方法的区别就在于shutdownNow会停止正在处理的任务        } finally {            mainLock.unlock();        }        tryTerminate();        return tasks;    }</code></pre>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java字符串：String使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9AString%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>String类型的字符串是不可变字符串，提供了较多操作API。</p><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}</code></pre><p>String可以序列化,可以使用compareTo比较字符串。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>String提供了的API主要如下：</p><pre><code>public char    charAt(int index) //index位置的字符public int    compareTo(String anotherString) //按字典顺序比较两个字符串public String    concat(String str) //拼接字符串public boolean    contains(CharSequence s) //是否包含spublic boolean    contentEquals(StringBuffer sb) //比较当前String和cs是否相同public boolean    contentEquals(CharSequence cs) //同上public static String    copyValueOf(char[] data, int offset, int count) //返回从offset开始的count个字符组成的字符串Stringpublic boolean    endsWith(String suffix) //是否以suffix结尾public boolean    equals(Object anObject) //比较字符串public static String    format(String format, Object[] args) //将args格式化为formatpublic int    hashCode() //hash codepublic int    indexOf(int ch) //第一次出现ch所在的下标public int    indexOf(int ch, int fromIndex)public int    indexOf(String str) //第一次出现str的下标public int    indexOf(String str, int fromIndex)public int    lastIndexOf(int ch) //最后一次出现ch的下标public int    lastIndexOf(int ch, int fromIndex)public int    lastIndexOf(String str) //租后一次出现str的下标public int    lastIndexOf(String str, int fromIndex)public int    length() //长度public boolean    matches(String regex) //正则匹配public int    offsetByCodePoints(int index, int codePointOffset)public boolean    regionMatches(int toffset, String other, int ooffset, int len) //比较指定子串public boolean    regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)public String    replace(char oldChar, char newChar) //替换oldChar为newCharpublic String    replace(CharSequence target, CharSequence replacement) //替换public String    replaceAll(String regex, String replacement)public String    replaceFirst(String regex, String replacement)public boolean    startsWith(String prefix, int toffset) //从toffset开始是否以prefix开头public boolean    startsWith(String prefix)public CharSequence    subSequence(int beginIndex, int endIndex) //获取子串public String    substring(int beginIndex)public String    substring(int beginIndex, int endIndex)public char[]    toCharArray()public String    toLowerCase(Locale locale) //转为小写字母public String    toLowerCase()public String    toString()public String    toUpperCase(Locale locale) //转为大写字母public String    toUpperCase()public String    trim()public static String    valueOf(Object obj) //转换为stringpublic void    getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) //获取byte数组public byte[]    getBytes(String charsetName)public byte[]    getBytes(Charset charset)public byte[]    getBytes()public void    getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)public boolean    isEmpty() //判空</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public void testString () {    String myStr = new String(&quot;MYSTR&quot;);    //myStr的长度    System.out.println(&quot;myStr的长度为: &quot; + myStr.length());    //myStr判空    System.out.println(&quot;myStr是否为空: &quot; + myStr.isEmpty());    //获取指定位置的字符    System.out.println(&quot;myStr的第4个字符为: &quot; + myStr.charAt(3));    //将myStr转换为数组    char [] chars = myStr.toCharArray();    try {        printChars(chars);    } catch (Exception e) {        System.out.println(&quot;myStr转换数组失败!&quot;);    }    System.out.println();    //格式化字符串    System.out.println(&quot;格式化myStr: &quot; + String.format(&quot;%s-%d-%b&quot;, myStr, 3, true));    //追加字符串    System.out.println(&quot;myStr追加字符ING!: &quot; + myStr.concat(&quot;ING!&quot;));    //拼接的字符串为一个新的对象,不影响原有字符串    System.out.println(&quot;myStr的字符串为: &quot; + myStr);    //获取子串    System.out.println(&quot;myStr第2到5个字符的子串为: &quot; + myStr.substring(1,5));    //替换    System.out.println(&quot;替换Y为y: &quot; + myStr.replace(&quot;Y&quot;, &quot;y&quot;));    //比较    System.out.println(&quot;myStr字符串和\&quot;MySTR\&quot;是否相等: &quot; + myStr.compareTo(&quot;MySTR&quot;));    //忽略大小写比较    System.out.println(&quot;myStr字符串和\&quot;MySTR\&quot;是否相等: &quot; + myStr.compareToIgnoreCase(&quot;MySTR&quot;));    //获取字符的index    System.out.println(&quot;\&quot;ST\&quot;在myStr中第一次出现的位置: &quot; + myStr.indexOf(&quot;ST&quot;));    //获取Unicode编码    System.out.printf(&quot;%s0x%x&quot;, &quot;第一个字符M的Unicode编码为: &quot;,myStr.codePointAt(0));}/** * 打印字符数组 * @param chars * @throws NullPointerException */public void printChars(char[] chars) throws Exception {    if (chars == null) {        throw new NullPointerException();    }    for (int i = 0; i &lt; chars.length; i++) {        System.out.printf(&quot;char[%d]=%c &quot;, i, chars[i]);    }}</code></pre><p>运行结果如下：</p><pre><code>myStr的长度为: 5myStr是否为空: falsemyStr的第4个字符为: Tchar[0]=M char[1]=Y char[2]=S char[3]=T char[4]=R格式化myStr: MYSTR-3-truemyStr追加字符ING!: MYSTRING!myStr的字符串为: MYSTRmyStr第2到5个字符的子串为: YSTR替换Y为y: MySTRmyStr字符串和&quot;MySTR&quot;是否相等: -32myStr字符串和&quot;MySTR&quot;是否相等: 0&quot;ST&quot;在myStr中第一次出现的位置: 2第一个字符M的Unicode编码为: 0x4d</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><p>String的字符串是不可变的，拼接替换等操作都会返回新的String实例，不会影响原有的字符串。</p><pre><code>/** The value is used for character storage. */private final char value[]; //final类型</code></pre><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>String包含的构造函数很多，主要区别是是否初始化和初始化方式。下面列举两个代表行的例子。</p><pre><code>/** * 申请一个空的String * Initializes a newly created {@code String} object so that it represents * an empty character sequence.  Note that use of this constructor is * unnecessary since Strings are immutable. */public String() {    this.value = new char[0];}/** * Allocates a new {@code String} that contains characters from a subarray * of the character array argument. The {@code offset} argument is the * index of the first character of the subarray and the {@code count} * argument specifies the length of the subarray. The contents of the * subarray are copied; subsequent modification of the character array does * not affect the newly created string. * * @param  value *         Array that is the source of characters * * @param  offset *         The initial offset * * @param  count *         The length * * @throws  IndexOutOfBoundsException *          If the {@code offset} and {@code count} arguments index *          characters outside the bounds of the {@code value} array */public String(char value[], int offset, int count) {    if (offset &lt; 0) {        throw new StringIndexOutOfBoundsException(offset);    }    if (count &lt; 0) {        throw new StringIndexOutOfBoundsException(count);    }    // Note: offset or count might be near -1&gt;&gt;&gt;1.    if (offset &gt; value.length - count) {        throw new StringIndexOutOfBoundsException(offset + count);    }    this.value = Arrays.copyOfRange(value, offset, offset+count);}</code></pre><h3 id="2-2-compareTo方法"><a href="#2-2-compareTo方法" class="headerlink" title="2.2 compareTo方法"></a>2.2 compareTo方法</h3><pre><code>/** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in * the strings. The character sequence represented by this * {@code String} object is compared lexicographically to the * character sequence represented by the argument string. The result is * a negative integer if this {@code String} object * lexicographically precedes the argument string. The result is a * positive integer if this {@code String} object lexicographically * follows the argument string. The result is zero if the strings * are equal; {@code compareTo} returns {@code 0} exactly when * the {@link #equals(Object)} method would return {@code true}. * &lt;p&gt; * This is the definition of lexicographic ordering. If two strings are * different, then either they have different characters at some index * that is a valid index for both strings, or their lengths are different, * or both. If they have different characters at one or more index * positions, let &lt;i&gt;k&lt;/i&gt; be the smallest such index; then the string * whose character at position &lt;i&gt;k&lt;/i&gt; has the smaller value, as * determined by using the &amp;lt; operator, lexicographically precedes the * other string. In this case, {@code compareTo} returns the * difference of the two character values at position {@code k} in * the two string -- that is, the value: * &lt;blockquote&gt;&lt;pre&gt; * this.charAt(k)-anotherString.charAt(k) * &lt;/pre&gt;&lt;/blockquote&gt; * If there is no index position at which they differ, then the shorter * string lexicographically precedes the longer string. In this case, * {@code compareTo} returns the difference of the lengths of the * strings -- that is, the value: * &lt;blockquote&gt;&lt;pre&gt; * this.length()-anotherString.length() * &lt;/pre&gt;&lt;/blockquote&gt; * * @param   anotherString   the {@code String} to be compared. * @return  the value {@code 0} if the argument string is equal to *          this string; a value less than {@code 0} if this string *          is lexicographically less than the string argument; and a *          value greater than {@code 0} if this string is *          lexicographically greater than the string argument. */public int compareTo(String anotherString) {    int len1 = value.length;    int len2 = anotherString.value.length;    int lim = Math.min(len1, len2);    char v1[] = value;    char v2[] = anotherString.value;    int k = 0;    while (k &lt; lim) {        char c1 = v1[k];        char c2 = v2[k];        if (c1 != c2) {            return c1 - c2;        }        k++;    }    return len1 - len2;}</code></pre><h3 id="2-3-concat方法"><a href="#2-3-concat方法" class="headerlink" title="2.3 concat方法"></a>2.3 concat方法</h3><pre><code>/** * Concatenates the specified string to the end of this string. * &lt;p&gt; * If the length of the argument string is {@code 0}, then this * {@code String} object is returned. Otherwise, a * {@code String} object is returned that represents a character * sequence that is the concatenation of the character sequence * represented by this {@code String} object and the character * sequence represented by the argument string.&lt;p&gt; * Examples: * &lt;blockquote&gt;&lt;pre&gt; * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot; * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param   str   the {@code String} that is concatenated to the end *                of this {@code String}. * @return  a string that represents the concatenation of this object&apos;s *          characters followed by the string argument&apos;s characters. */public String concat(String str) {    int otherLen = str.length();    if (otherLen == 0) { //判空        return this;    }    int len = value.length;    char buf[] = Arrays.copyOf(value, len + otherLen); //获取原字符串的字符数组    str.getChars(buf, len); //将str存到buf的尾部    return new String(buf, true); //返回新String}</code></pre><h3 id="2-4-replace方法"><a href="#2-4-replace方法" class="headerlink" title="2.4 replace方法"></a>2.4 replace方法</h3><p>replace方法有很多重载方法，下面只分析其中一种。</p><pre><code>/** * Returns a string resulting from replacing all occurrences of * {@code oldChar} in this string with {@code newChar}. * &lt;p&gt; * If the character {@code oldChar} does not occur in the * character sequence represented by this {@code String} object, * then a reference to this {@code String} object is returned. * Otherwise, a {@code String} object is returned that * represents a character sequence identical to the character sequence * represented by this {@code String} object, except that every * occurrence of {@code oldChar} is replaced by an occurrence * of {@code newChar}. * &lt;p&gt; * Examples: * &lt;blockquote&gt;&lt;pre&gt; * &quot;mesquite in your cellar&quot;.replace(&apos;e&apos;, &apos;o&apos;) *         returns &quot;mosquito in your collar&quot; * &quot;the war of baronets&quot;.replace(&apos;r&apos;, &apos;y&apos;) *         returns &quot;the way of bayonets&quot; * &quot;sparring with a purple porpoise&quot;.replace(&apos;p&apos;, &apos;t&apos;) *         returns &quot;starring with a turtle tortoise&quot; * &quot;JonL&quot;.replace(&apos;q&apos;, &apos;x&apos;) returns &quot;JonL&quot; (no change) * &lt;/pre&gt;&lt;/blockquote&gt; * * @param   oldChar   the old character. * @param   newChar   the new character. * @return  a string derived from this string by replacing every *          occurrence of {@code oldChar} with {@code newChar}. */public String replace(char oldChar, char newChar) {    if (oldChar != newChar) { //新老字符相同则返回原字符串        int len = value.length;        int i = -1;        char[] val = value; /* avoid getfield opcode */        while (++i &lt; len) { //找到第一个需要替换的字符            if (val[i] == oldChar) {                break;            }        }        if (i &lt; len) {            char buf[] = new char[len];            for (int j = 0; j &lt; i; j++) { //第一个之前的字符直接存储                buf[j] = val[j];            }            while (i &lt; len) { //替换并且查找                char c = val[i];                buf[i] = (c == oldChar) ? newChar : c;                i++;            }            return new String(buf, true); //返回新字符串        }    }    return this;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://blog.csdn.net/mazhimazh/article/details/17715677" target="_blank" rel="noopener"> http://blog.csdn.net/mazhimazh/article/details/17715677</a><br>[2] <a href="http://www.cnblogs.com/skywang12345/p/string01.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/string01.html</a></p>]]></content>
      
      <categories>
          
          <category> Java字符串 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：死锁及解决方法</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%AD%BB%E9%94%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <content type="html"><![CDATA[<h2 id="1-什么是死锁"><a href="#1-什么是死锁" class="headerlink" title="1 什么是死锁"></a>1 什么是死锁</h2><p>死锁是多个进程\线程为了完成任务申请多个不可剥夺的资源并且以不正确的方式推进导致的一直互相等待对方释放资源的状态。下面以经典的哲学家就餐问题为例，描述死锁产<br>生的场景。</p><h2 id="2-哲学家就餐问题"><a href="#2-哲学家就餐问题" class="headerlink" title="2 哲学家就餐问题"></a>2 哲学家就餐问题</h2><p>五个哲学家坐在一个圆桌上，每个哲学家两侧都放着1根筷子，总共有5只筷子。哲学家需要分别或者左右手的两只筷子才能就餐，就餐完成后将筷子放回原处，其他哲学家可以<br>获取放回的筷子。有这样一种状态，每个哲学家都获取了他右手的筷子，试图获取左手的筷子时都会失败（被他左手边的哲学家拿走了），然后所有哲学家都会一直等待他左手边<br>哲学家释放筷子，这就导致了死锁状态。</p><pre><code>public class PhilosopherEat {    /*     *筷子类     */    public static class Chop {        private volatile boolean taken = false; //筷子状态        ReentrantLock lock = new ReentrantLock(); //定义锁        Condition isTaken = lock.newCondition();        //拿起筷子        public void take() throws InterruptedException {            lock.lock();            try {                while (taken) { //筷子已被其他哲学家拿走                    isTaken.await();                }                taken = true; //标记筷子被拿走            } finally {                lock.unlock();            }        }        // 放下筷子        public  void put() throws InterruptedException {            lock.lock();            try {                taken = false; //放下筷子                isTaken.signalAll(); //通知邻座的哲学家拿筷子            } finally {                lock.unlock();            }        }    }    /*     * 哲学家就餐类     */    public static class Philosopher implements Runnable {        private Chop left; //左手的筷子        private Chop right; //右手的筷子        private int id; //哲学家编号        private int ponderFactor; //思考时间        private Random random = new Random(47);        //暂停时间,模拟哲学家吃饭用时等        private void pasue() throws InterruptedException {            if (ponderFactor == 0) {                return;            }            //TimeUnit.MILLISECONDS.sleep(random.nextInt(ponderFactor * 250));            TimeUnit.MILLISECONDS.sleep(10);        }        //构造方法        public Philosopher(Chop left, Chop right, int id, int ponderFactor) {            this.left = left;            this.right = right;            this.id = id;            this.ponderFactor = ponderFactor;        }        @Override        public void run() {            try {                while (!Thread.interrupted()) {                    System.out.println(this + &quot; &quot; + &quot;thinking&quot;);                    pasue();                    right.take();                    System.out.println(this + &quot; &quot; + &quot;take right&quot;);                    left.take();                    System.out.println(this + &quot; &quot; + &quot;take left&quot;);                    System.out.println(this + &quot; &quot; + &quot;eat&quot;);                    pasue();                    left.put();                    System.out.println(this + &quot; &quot; + &quot;put left&quot;);                    right.put();                    System.out.println(this + &quot; &quot; + &quot;put right&quot;);                }            } catch (InterruptedException e) {}        }    }    public static void main(String[] args) {        int size = 5;        int ponder = 5;        Chop [] chops = new Chop[5]; //5跟筷子        for (int i = 0; i &lt; 5; i++) {            chops[i] = new Chop();        }        ExecutorService pool = Executors.newCachedThreadPool();        for (int i = 0; i &lt; size; i++) {            pool.execute(new Philosopher(chops[i], chops[(i + 1) % 5], i, ponder));        }        try {            System.out.println(&quot;quit&quot;);            System.in.read();        } catch (IOException e) {}        pool.shutdown();    }}</code></pre><p>大部分情况下执行不会发生死锁，就餐和思考时间越短越容易发生死锁，这也是死锁问题的可怕之处，不易复现。</p><h2 id="3-死锁的必要条件"><a href="#3-死锁的必要条件" class="headerlink" title="3 死锁的必要条件"></a>3 死锁的必要条件</h2><p>死锁的必要条件有如下四个：</p><h3 id="3-1-互斥条件"><a href="#3-1-互斥条件" class="headerlink" title="3.1 互斥条件"></a>3.1 互斥条件</h3><p>一个资源每次只能被一个线程使用，如IO等。</p><h3 id="3-2-请求与保持条件"><a href="#3-2-请求与保持条件" class="headerlink" title="3.2 请求与保持条件"></a>3.2 请求与保持条件</h3><p>一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p><h3 id="3-3-不剥夺条件"><a href="#3-3-不剥夺条件" class="headerlink" title="3.3 不剥夺条件"></a>3.3 不剥夺条件</h3><p>进程已获得的资源，在未使用完之前，不能强行剥夺。</p><h3 id="3-4-循环等待条件"><a href="#3-4-循环等待条件" class="headerlink" title="3.4 循环等待条件"></a>3.4 循环等待条件</h3><p>若干进程之间形成一种头尾相接的循环等待资源关系。</p><h2 id="4-解决死锁的方法"><a href="#4-解决死锁的方法" class="headerlink" title="4 解决死锁的方法"></a>4 解决死锁的方法</h2><p>死锁的必要条件必须全部满足才会产生死锁，所以要解决死锁问题只需要任意破坏其中一个条件就可以解决死锁问题。</p><h3 id="4-1-互斥条件"><a href="#4-1-互斥条件" class="headerlink" title="4.1 互斥条件"></a>4.1 互斥条件</h3><p>很多系统资源如IO等必须是互斥的，破坏互斥条件的成本较大。</p><h3 id="4-2-请求与保持条件"><a href="#4-2-请求与保持条件" class="headerlink" title="4.2 请求与保持条件"></a>4.2 请求与保持条件</h3><p>可以通过一次性获取所有资源即对需要的资源进行原子申请可以解决死锁问题，这种方式对系统开销较大，不太理想。</p><h3 id="4-3-不可剥夺条件"><a href="#4-3-不可剥夺条件" class="headerlink" title="4.3 不可剥夺条件"></a>4.3 不可剥夺条件</h3><p>可以通过定时释放占有的资源解决死锁问题，但是这也会带来过多的资源占有释放操作。</p><h3 id="4-4-循环等待条件"><a href="#4-4-循环等待条件" class="headerlink" title="4.4 循环等待条件"></a>4.4 循环等待条件</h3><p>这是解决死锁常用的方法，例如哲学家就餐问题中，最后一个哲学家可以先拿左手的筷子，拿不到就会等待，他右手的筷子就可以供第一个哲学家使用。</p><pre><code>public static void main(String[] args) {    int size = 5;    int ponder = 5;    Chop [] chops = new Chop[5]; //5跟筷子    for (int i = 0; i &lt; 5; i++) {        chops[i] = new Chop();    }    ExecutorService pool = Executors.newCachedThreadPool();    for (int i = 0; i &lt; size; i++) {        if (i &lt; size - 1) {            pool.execute(new Philosopher(chops[i], chops[(i + 1) % 5], i, ponder));        } else {            pool.execute(new Philosopher(chops[0], chops[i], i, ponder));        }    }    try {        System.out.println(&quot;quit&quot;);        System.in.read();    } catch (IOException e) {}    pool.shutdown();}</code></pre>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：生产者-消费者模式</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<p>生产者消费者模型是并发编程的经典模型，生产者模型的核心思想是生产者生产的产品通过一块共享的资源与消费者交互，通过共享资源的交互实现了生产者与消费者的解耦。现<br>在的消息队列使用的也是这种思想。<br>本文实现了如下描述的生产者-消费者模型：<br>1、生产者和消费者各有1个；<br>2、通信所使用的队列大小一定（200），并且队列不能溢出；<br>3、生产者和我消费者的消费速度不做假设，生产速度和消费速度大小大概率不一致；<br>4、生产者生产完商品后会通知消费者取商品，消费者消费完后会通知生产者生产商品；<br>5、队列承载不了本次生产的商品时生产者会进入wait，队列里的商品不够本次消费时消费者会进入wait。</p><p>具体代码可解释如下：</p><pre><code>public class ProduceConsumer {    //定义产品类    public static class Product {        private int name; //产品名称,编号        @Override        public String toString() {            return &quot;Product:&quot; + name;        }    }    //仓库类,主要逻辑在这里实现    public static class WareHouse {        private static Queue&lt;Product&gt; products = new LinkedList&lt;Product&gt;(); //产品队列        private final int MAX = 200; //仓库最大容量        private static int currentCount = 0; //当前仓储量        private static int name = 1; //产品编号        private static Lock lock = new ReentrantLock(); //自定义锁对象        private static Condition condition = lock.newCondition();        //生产产品        public void produce(Product product, int amount) {            lock.lock();            try {                while (currentCount + amount &gt; MAX) { //队列满                    System.out.println(Thread.currentThread().getName() + &quot;生产后的产品总量大于承载能力, wait&quot;);                    try {                        condition.await(); //进入等待                        System.out.println(Thread.currentThread().getName() + &quot;Get signal&quot;);                    } catch (InterruptedException e) {                        System.out.println(e.getStackTrace());                    }                }                for (int i = 0; i &lt; amount; i++) {                    product.name = name++; //设置产品编号                    products.add(product); //向队列中加入产品                    currentCount++; //仓储数量增加                }                System.out.println(Thread.currentThread().getName() + &quot;生产了 &quot; + amount + &quot; 个商品, 现在库存为: &quot; + currentCount);                condition.signalAll(); //通知消费者                System.out.println(Thread.currentThread().getName() + &quot; signalAll...&quot;);            } finally {                lock.unlock();            }        }        //消费产品        public void consume(int amount) {            lock.lock();            try {                while (currentCount &lt; amount) { //商品不够本次消费                    System.out.println(Thread.currentThread().getName() + &quot;要消费数量为: &quot; + amount + &quot;仓储数量: &quot; + currentCount + &quot; 仓储数量不足, wait&quot;);                    try {                        condition.await(); //进入等待                        System.out.println(Thread.currentThread().getName() + &quot;Get signal&quot;);                    } catch (InterruptedException e) {                    }                }                for (int i = 0; i &lt; amount; i++) {                    Product product = products.poll();                    currentCount--; //减仓储                }                System.out.println(Thread.currentThread().getName() + &quot;消费了 &quot; + amount + &quot; 个商品, 现在库存为: &quot; + currentCount);                condition.signalAll(); //通知生产者                System.out.println(Thread.currentThread().getName() + &quot;signalAll...&quot;);            } finally {                lock.unlock();            }        }    }    //生产者类    public static class Producer implements Runnable {        @Override        public void run() {            int amount = (int) (Math.random() * 100); //最多生产仓储量的一半            Product product = new Product();            WareHouse wareHouse = new WareHouse();            wareHouse.produce(product, amount);        }    }    //消费者类    public static class Consumer implements  Runnable{        @Override        public void run() {            int amount = (int) (Math.random() * 100); //最多生产仓储量的一半            WareHouse wareHouse = new WareHouse();            wareHouse.consume(amount);        }    }    public static void main(String[] args) {        //生产者线程池        ExecutorService producerPool = Executors.newFixedThreadPool(1);        ExecutorService consumerPool = Executors.newSingleThreadExecutor();        int i = 0;        while (true) {            Producer producer = new Producer();            producerPool.execute(producer);            Consumer consumer = new Consumer();            consumerPool.execute(consumer);            if (i++ &gt; 200) {                break;            }        }    }}</code></pre><p>部分执行结果如下：</p><pre><code>pool-1-thread-1生产了 44 个商品, 现在库存为: 44pool-1-thread-1 signalAll...pool-2-thread-1消费了 44 个商品, 现在库存为: 0pool-2-thread-1signalAll...pool-1-thread-1生产了 3 个商品, 现在库存为: 3pool-1-thread-1 signalAll...pool-2-thread-1要消费数量为: 54仓储数量: 3 仓储数量不足, waitpool-1-thread-1生产了 91 个商品, 现在库存为: 94pool-1-thread-1 signalAll...pool-2-thread-1Get signalpool-2-thread-1消费了 54 个商品, 现在库存为: 40pool-2-thread-1signalAll...pool-1-thread-1生产了 34 个商品, 现在库存为: 74pool-1-thread-1 signalAll...pool-2-thread-1要消费数量为: 95仓储数量: 74 仓储数量不足, waitpool-1-thread-1生产了 62 个商品, 现在库存为: 136pool-1-thread-1 signalAll...pool-2-thread-1Get signalpool-2-thread-1消费了 95 个商品, 现在库存为: 41pool-2-thread-1signalAll...pool-2-thread-1要消费数量为: 89仓储数量: 41 仓储数量不足, waitpool-1-thread-1生产了 82 个商品, 现在库存为: 123pool-1-thread-1 signalAll...pool-1-thread-1生产了 14 个商品, 现在库存为: 137pool-1-thread-1 signalAll...pool-1-thread-1生产了 28 个商品, 现在库存为: 165pool-1-thread-1 signalAll...pool-1-thread-1生产了 19 个商品, 现在库存为: 184pool-1-thread-1 signalAll...pool-1-thread-1生产后的产品总量大于承载能力, waitpool-2-thread-1Get signalpool-2-thread-1消费了 89 个商品, 现在库存为: 95</code></pre><p>这段代码里控制了生产者消费者的速度都不能超过100即仓储总量的一半，否则可能发生消费者和生产者相互等待的情况。例如：仓储现在已有110个商品，消费者需要消费<br>120个，所以消费者进入wait；此时生产者线程获得cpu，并且需要生产100个商品，由于现在剩下的仓储只有90个，所以生产者线程此时也进入wait，导致两<br>个线程相互等待。大家看看怎么解决。</p>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：线程同步机制</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
      <content type="html"><![CDATA[<p><strong> Java中线程同步可以通过wait、notify、notifyAll等方法实现。这几个方法在最顶级的父类Object中实现，并且被声明为final，所以子类无法重写这几个方法。在实现线程同步时，一般需要配合synchronized关键字使用，定义同步代码块或者方法。JDK 1.5以后提供了Condition来实现线程间的协作，Condition提供的await、signal、signalAll方法相对于wait、notify、notifyAll的方法更加安全高效，Condition所使用的是ReentrantLock锁。 </strong></p><h2 id="1-synchronized关键字和ReentrantLock类"><a href="#1-synchronized关键字和ReentrantLock类" class="headerlink" title="1 synchronized关键字和ReentrantLock类"></a>1 synchronized关键字和ReentrantLock类</h2><p>理解synchronized关键字必须首先了解下Java的内存模型。<br><strong> Java中每一个进程都有自己的主内存，进程中的每个线程有自己的线程内存，线程从主内存中获取数据在线程内存中计算完成后回写到主内存中。在并发情况下就可能造成数据过期数据的问题。 </strong> 具体例子看如下代码： </p><pre><code>public class TestSync {    public static int sum = 0;    public static class MyThreadA implements Runnable {        @Override        public void run() {            for (int j = 0; j &lt; 10000; j++) {                sum++;            }        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 10; i++) { //10个任务交给线程池, 返回的数据预期为10*10000            MyThreadA myThreadA = new MyThreadA();            executorService.execute(myThreadA);        }        executorService.shutdown();        System.out.println(sum);    }}</code></pre><p>执行结果如下：</p><pre><code>88625</code></pre><p>从执行结果可以看出，并不是预期中的100000。原因就在数据过期的问题。例如线程A和线程B同时从主内存中获取sum的值为1500。线程A计算了1000次，此<br>时线程A内存中的sum为2500，并向主内存回写sum=2500，后交出CPU;线程B获得CPU开始计算了900次，此时线程B内存中的sum=2400,并向<br>主内存回写sum=2400,后交出CPU。此时主内存的sum=2400,而预期是1500+1000+900=3400。<br>使用synchronized关键字改进代码如下：</p><pre><code>public class TestSync {    public static int sum = 0;    public static Object lock = new Object(); //自定义锁对象,代价较小    public static class MyThreadA implements Runnable {        @Override        public void run() {            synchronized (lock) { //同步代码块                for (int j = 0; j &lt; 10000; j++) {                    sum++;                }            }        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 10; i++) { //10个任务交给线程池, 返回的数据预期为10*10000            MyThreadA myThreadA = new MyThreadA();            executorService.execute(myThreadA);        }        executorService.shutdown();        System.out.println(sum);    }}</code></pre><p>执行结果如下：</p><pre><code>100000</code></pre><p>执行结果符合预期。原因是线程进入同步代码块后会获取对象锁，阻止其他线程进入执行，线程执行完for循环并向主内存回写sum后才会退出退出同步代码块，其他线程才<br>会执行。<br>ReentrantLock类提供的锁机制可以完成所有synchronized关键字能实现的功能并且针对synchronized的限制 —<br>它无法中断一个正在等候获得锁的线程，也无法通过投票得到锁，如果不想等下去，也就没法得到锁，做出了改进，提高了高争用条件下的执行效率。具体分析请参考（ <a href="https://www.ibm.com/developerworks/cn/java/j-jtp10264/" target="_blank" rel="noopener"><br>https://www.ibm.com/developerworks/cn/java/j-jtp10264/</a> ）；</p><h2 id="2-wait-、notify-、notifyAll-介绍及代码演示（介绍纯属copy其他博客，-地址："><a href="#2-wait-、notify-、notifyAll-介绍及代码演示（介绍纯属copy其他博客，-地址：" class="headerlink" title="2 wait()、notify()、notifyAll() 介绍及代码演示（介绍纯属copy其他博客， 地址： ["></a>2 wait()、notify()、notifyAll() 介绍及代码演示（介绍纯属copy其他博客， 地址： [</h2><p><a href="http://blog.csdn.net/ns_code/article/details/17225469" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17225469</a><br>](<a href="http://blog.csdn.net/ns_code/article/details/17225469" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17225469</a>) ）</p><h3 id="2-1-wait方法介绍"><a href="#2-1-wait方法介绍" class="headerlink" title="2.1 wait方法介绍"></a>2.1 wait方法介绍</h3><p><strong> 该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。进入wait（）方法后，当前线程释放锁。在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 </strong></p><h3 id="2-2-notify方法介绍"><a href="#2-2-notify方法介绍" class="headerlink" title="2.2 notify方法介绍"></a>2.2 notify方法介绍</h3><p><strong> 该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。 </strong> 这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的notifyAll（）方法执行后的情况不同。 </p><h3 id="2-3-notifyAll方法介绍"><a href="#2-3-notifyAll方法介绍" class="headerlink" title="2.3 notifyAll方法介绍"></a>2.3 notifyAll方法介绍</h3><p><strong> 该方法与notify（）方法的工作方式相同，重要的一点差异是：notifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 </strong></p><h3 id="2-4-更深入的理解"><a href="#2-4-更深入的理解" class="headerlink" title="2.4 更深入的理解"></a>2.4 更深入的理解</h3><p><strong> 如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。 </strong><br><strong> 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 </strong></p><h3 id="2-5-代码展示"><a href="#2-5-代码展示" class="headerlink" title="2.5 代码展示"></a>2.5 代码展示</h3><p>3线程交替wait，相互唤醒。</p><pre><code>public class Main {    private static Object lock = new Object(); //自定义锁对象    public static class MyThreadA implements Runnable {        public String name;        public MyThreadA(String name) {            this.name = name;        }        @Override        public void run() {            synchronized (lock) {                for (int i = 0; i &lt; 11; i++) {                    if (i % 3 == 0 &amp;&amp; i != 0) {                        System.out.println(Thread.currentThread().getName() + &quot; : &quot;+ i);                        try {                            lock.wait();                        } catch (InterruptedException e) {                        }                    }                    //System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i + &quot;notify&quot;);                    lock.notify();                }            }        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 3; i++) {            MyThreadA myThreadA = new MyThreadA(&quot;thread a&quot;);            executorService.execute(myThreadA);        }        //executorService.shutdown();    }</code></pre><p>执行结果如下：</p><pre><code>pool-1-thread-1 : 3pool-1-thread-2 : 3pool-1-thread-3 : 3pool-1-thread-1 : 6pool-1-thread-3 : 6pool-1-thread-1 : 9pool-1-thread-3 : 9pool-1-thread-2 : 6</code></pre><p>线程2打印6后进入wait,没有其他线程notify导致一直等待。</p><h2 id="3-await-、signal-、signalAll-介绍及代码演示"><a href="#3-await-、signal-、signalAll-介绍及代码演示" class="headerlink" title="3 await()、signal()、signalAll()介绍及代码演示"></a>3 await()、signal()、signalAll()介绍及代码演示</h2><p>这三个方法的作用和wait、notify、notifyAll类似，采用这三个方法是需要使用的同步锁是Lock。</p><pre><code>public class Main {    private static Lock lock = new ReentrantLock(); //自定义锁对象    private static Condition condition = lock.newCondition();    public static class MyThreadA implements Runnable {        public String name;        public MyThreadA(String name) {            this.name = name;        }        @Override        public void run() {            lock.lock();            try {                for (int i = 0; i &lt; 11; i++) {                    if (i % 3 == 0 &amp;&amp; i != 0) {                        System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);                        try {                            condition.await();                        } catch (InterruptedException e) {}                    }                    //System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i + &quot;notify&quot;);                    condition.signalAll();                }            } finally {                lock.unlock();            }        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 3; i++) {            MyThreadA myThreadA = new MyThreadA(&quot;thread a&quot;);            executorService.execute(myThreadA);        }        executorService.shutdown();    }}</code></pre><p>执行结果如下：</p><pre><code>pool-1-thread-1 : 3pool-1-thread-2 : 3pool-1-thread-1 : 6pool-1-thread-2 : 6pool-1-thread-1 : 9pool-1-thread-2 : 9pool-1-thread-3 : 3pool-1-thread-3 : 6</code></pre><p>和使用wait、notify类似，最后一个线程有可能会陷入一直等待的状态。</p><h2 id="4、下一篇分别用上面描述的两种方法实现经典的生产者-消费者模型"><a href="#4、下一篇分别用上面描述的两种方法实现经典的生产者-消费者模型" class="headerlink" title="4、下一篇分别用上面描述的两种方法实现经典的生产者-消费者模型"></a>4、下一篇分别用上面描述的两种方法实现经典的生产者-消费者模型</h2>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：线程池创建及源码分析</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<p>Java5引入了线程池的顶级接口Executor，ExecutorService继承了Executor接口并增加了自己的方法。Executors工具类为Ex<br>ecutor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具<br>方法，通过这个工具类提供的方法可以方便的创建线程池。</p><h2 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1 使用线程池的好处"></a>1 使用线程池的好处</h2><p>使用线程池的好处主要有三点：<br>第一，降低资源消耗。通过预先创建的线程池，避免了高频率的创建和销毁线程，最大可能的重用线程。<br>第二，提高响应速度。有任务到达的时候可以直接使用线程池中的空闲线程，避免即时创建线程导致的效率降低。<br>第三，方便线程管理。通过线程池可以对线程进行统一创建、监控。</p><h2 id="2-创建线程池"><a href="#2-创建线程池" class="headerlink" title="2 创建线程池"></a>2 创建线程池</h2><p>Executors工具类为创建线程池提供了 <strong> newCachedThreadPool，newFixedThreadPool，newSingleThrea<br>dExecutor以及newScheduledThreadPool </strong> 四个工厂方法创建不同类型的线程池。</p><h3 id="2-1-newCachedThreadPool示例"><a href="#2-1-newCachedThreadPool示例" class="headerlink" title="2.1 newCachedThreadPool示例"></a>2.1 newCachedThreadPool示例</h3><p>这个方法创建的是一个可以动态改变大小的线程池。当任务较多时会增加线程池中线程的数量，如果需要处理的任务较少，导致线程60s没有运行，JVM则会回收线程。</p><pre><code>import java.io.*;import java.util.concurrent.*;public class TestThreadPool {    public static class MyThread implements Runnable {    @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot; is running...&quot;);        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        ExecutorService MyThreadPool =              Executors.newCachedThreadPool();        for (int i = 0; i &lt; 5; i++) {            MyThread t = new MyThread();            MyThreadPool.execute(t);        }    }}</code></pre><p>执行结果如下：</p><pre><code>pool-1-thread-3 is running...pool-1-thread-5 is running...pool-1-thread-4 is running...pool-1-thread-2 is running...pool-1-thread-1 is running...</code></pre><p>由执行结果可知，线程池为了处理5个任务启动了5个线程。</p><h3 id="2-2-newFixedThreadPool-示例"><a href="#2-2-newFixedThreadPool-示例" class="headerlink" title="2.2 newFixedThreadPool 示例"></a>2.2 newFixedThreadPool 示例</h3><p>这个方法可以创建一个大小固定的线程池，当需要处理的任务书大于空闲线程个数时会暂时存在等待队列中直到有空闲的线程。</p><pre><code>import java.io.*;import java.util.concurrent.*;public class TestThreadPool {    public static class MyThread implements Runnable {    @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot; is running...&quot;);        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        //ExecutorService MyThreadPool = Executors.newCachedThreadPool();        //创建大小为3的线程池        ExecutorService MyThreadPool = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 5; i++) {            MyThread t = new MyThread();            MyThreadPool.execute(t);        }        MyThreadPool.shutdown();    }}</code></pre><p>执行结果如下：</p><pre><code>pool-1-thread-2 is running...pool-1-thread-3 is running...pool-1-thread-1 is running...pool-1-thread-3 is running...pool-1-thread-2 is running...</code></pre><p>由执行结果可知，5个任务1\2\3号线程同时执行，当2\3号线程空闲后执行最后两个任务。</p><h3 id="2-3-newSingleThreadExecutor示例"><a href="#2-3-newSingleThreadExecutor示例" class="headerlink" title="2.3 newSingleThreadExecutor示例"></a>2.3 newSingleThreadExecutor示例</h3><p>这个方法和2.2中的方法类似，不过本方法产生固定大小为1的线程池，所有任务由一个线程完成。</p><pre><code>import java.io.*;import java.util.concurrent.*;public class TestThreadPool {    public static class MyThread implements Runnable {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot; is running...&quot;);        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        //ExecutorService MyThreadPool = Executors.newCachedThreadPool();        //创建大小为3的线程池        //ExecutorService MyThreadPool = Executors.newFixedThreadPool(3);        ExecutorService MyThreadPool = Executors.newSingleThreadExecutor();        for (int i = 0; i &lt; 5; i++) {            MyThread t = new MyThread();            MyThreadPool.execute(t);        }        MyThreadPool.shutdown();    }}</code></pre><p>执行结果如下：</p><pre><code>pool-1-thread-1 is running...pool-1-thread-1 is running...pool-1-thread-1 is running...pool-1-thread-1 is running...pool-1-thread-1 is running...</code></pre><p>5个任务全是由线程1完成的。</p><h3 id="2-4-newScheduledThreadPool示例"><a href="#2-4-newScheduledThreadPool示例" class="headerlink" title="2.4 newScheduledThreadPool示例"></a>2.4 newScheduledThreadPool示例</h3><p>这个方法创建的是一个大小固定，但是支持延时和周期操作的线程池。</p><pre><code>import java.io.*;import java.util.concurrent.*;import org.omg.CORBA.PUBLIC_MEMBER;public class TestThreadPool {    public static class MyThread implements Runnable {        @Override        public void run() {        System.out.println(Thread.currentThread().getName() + &quot; is running... 1&quot;);        }    }    public static class Scheduled1 implements Runnable {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot; is running... 2&quot;);        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        //ExecutorService MyThreadPool = Executors.newCachedThreadPool();        //创建大小为3的线程池        //ExecutorService MyThreadPool = Executors.newFixedThreadPool(3);        ScheduledThreadPoolExecutor MyThreadPool = new ScheduledThreadPoolExecutor(2);        Runnable r1 = new MyThread();        Runnable r2 = new Scheduled1();        MyThreadPool.scheduleAtFixedRate(r1, 1000, 2000, TimeUnit.MILLISECONDS);        MyThreadPool.scheduleAtFixedRate(r2, 1000, 5000, TimeUnit.MILLISECONDS);    }}</code></pre><p>执行结果如下：</p><pre><code>pool-1-thread-1 is running... 1pool-1-thread-2 is running... 2pool-1-thread-1 is running... 1pool-1-thread-1 is running... 1pool-1-thread-2 is running... 2pool-1-thread-1 is running... 1pool-1-thread-1 is running... 1</code></pre><h2 id="3-几种线程池源码分析"><a href="#3-几种线程池源码分析" class="headerlink" title="3 几种线程池源码分析"></a>3 几种线程池源码分析</h2><p>第二节介绍的几种线程池创建方法都是通过调用ThreadPoolExecutor方法实现的，区别是调用ThreadPoolExecutor时传递的参数不同。</p><h3 id="3-1ThreadPoolExecutor使用方法介绍"><a href="#3-1ThreadPoolExecutor使用方法介绍" class="headerlink" title="3.1ThreadPoolExecutor使用方法介绍"></a>3.1ThreadPoolExecutor使用方法介绍</h3><p>ThreadPoolExecutor的的构造方法如下：</p><pre><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></pre><p>corePoolSize: 线程池中基本线程数。线程池初始化会创建corePoolSize个基本线程用于处理任务。<br>maximumPoolSize：线程池最大容量。线程池最多允许存在的线程数。<br>keepAliveTime：线程空闲回收时间。线程池中除了基本线程的外的线程空闲时间达到keepAliveTime时就会由JVM自动销毁回收。<br>unit：时间单位。keepAliveTime的时间单位。<br>workQueue：线程的排队队列。常见的线程队列有无界队列（LinkedBlockingQueue），同步队列（SynchronousQueue），有界队<br>列（ArrayBlockingQueue）。任务的提交策略由选用哪种任务队列决定。<br>threadFactory：线程工厂。创建线程的方法，可以通过这个参数为线程命名一个有意义的名称。<br>handler：饱和处理策略。当线程池和队列都满时的处理策略。</p><h3 id="3-2-newCachedThreadPool源码分析"><a href="#3-2-newCachedThreadPool源码分析" class="headerlink" title="3.2 newCachedThreadPool源码分析"></a>3.2 newCachedThreadPool源码分析</h3><pre><code> public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());}</code></pre><p>newCachedThreadPool是一个静态方法，内部返回了一个ThreadPoolExecutor实例。<br>ThreadPoolExecutor的具体参数如下：<br>corePoolSize：0，线程池的基本线程数为0。线程池不会维护固定大小的基本线程。<br>maximumPoolSize：Integer.MAX_VALUE,2^31 - 1。线程池的大小可以认为是无限大的。<br>keepAliveTime：60L，保活时间为60。当基本线程外的线程超过60个时间单位没有处理任务则回收。<br>unit：TimeUnit.SECONDS，时间单位为秒。<br>workQueue：SynchronousQueue，同步队列。等待队列为同步队列，只有线程将队列中的任务取走时新的任务才会入队列。<br><strong> 由源码分析可知，newCachedThreadPool方法创建的线程池是一个无线大小的线程池，他会根据任务的多少动态增减线程池中线程的数量。 </strong></p><h3 id="3-3-newFixedThreadPool源码分析"><a href="#3-3-newFixedThreadPool源码分析" class="headerlink" title="3.3 newFixedThreadPool源码分析"></a>3.3 newFixedThreadPool源码分析</h3><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre><p>ThreadPoolExecutor的具体参数如下：<br>corePoolSize：nThreads，线程池的基本线程数为nThreads。<br>maximumPoolSize：nThreads。线程池的包含的最大数量和基本线程数量是一样的。<br>keepAliveTime：0L，保活时间为0。由于不存在线程池中数量大于基本线程数量的情况，所以JVM不会制动回收线程。<br>unit：TimeUnit.SECONDS，时间单位为秒。<br>workQueue：LinkedBlockingQueue，无界队列。队列的大小可以认为是无限的。<br><strong> 由源码分析可知，newFixedThreadPool方法创建的是一个大小固定的线程池，当线程池中线程数量大于基本线程数时，任务会加入等workQueue。 </strong></p><h3 id="3-4-newSingleThreadExecutor源码分析"><a href="#3-4-newSingleThreadExecutor源码分析" class="headerlink" title="3.4 newSingleThreadExecutor源码分析"></a>3.4 newSingleThreadExecutor源码分析</h3><pre><code> public static ExecutorService newSingleThreadExecutor() {  return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre><p>ThreadPoolExecutor的具体参数如下：<br>corePoolSize：1，线程池的基本线程数为1。<br>maximumPoolSize：1。线程池的包含的最大数量和基本线程数量是一样的，并且最多只允许有1个线程。<br>keepAliveTime：0L，保活时间为0。由于不存在线程池中数量大于基本线程数量的情况，所以JVM不会制动回收线程。<br>unit：TimeUnit.SECONDS，时间单位为秒。<br>workQueue：LinkedBlockingQueue，无界队列。队列的大小可以认为是无限的。<br>由源码分析可知，newFixedThreadPool方法和newFixedThreadPool方法几乎一样，只是线程池大小固定为1。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系及下一篇预告。</p><p>Executor是线程池的顶级接口，他只声明了execute方法。<br>ExecutorService继承了Executor接口并声明了submit的方法。<br>AbstractExecutorService类实现了ExecutorService的几乎所有方法。<br>ThreadPoolExecutor继承了AbstractExecutorService类。</p><p>下一篇会详细分析ThreadPoolExecutor。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p>[1] <a href="http://blog.csdn.net/sd0902/article/details/8395677" target="_blank" rel="noopener"> http://blog.csdn.net/sd0902/article/details/8395677</a><br>[2] <a href="http://www.infoq.com/cn/articles/java-threadPool#anch92136" target="_blank" rel="noopener"> http://www.infoq.com/cn/articles/java-threadPool#anch92136</a><br>[3] <a href="http://www.cnblogs.com/nayitian/p/3262031.html" target="_blank" rel="noopener"> http://www.cnblogs.com/nayitian/p/3262031.html</a><br>[4] <a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener"> http://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java并发编程：线程创建</title>
      <link href="/2017/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
      <content type="html"><![CDATA[<p>Java中创建线程最常用的方法有继承Thread类和实现Runnable两种。Thread类实际也是实现了Runnable方法，由于无法继承多个父类但是可以<br>继承多个接口，所有创建进程大多是实现Runnable接口</p><blockquote><ul><li>继承Thread类</li></ul></blockquote><p>&gt;</p><blockquote><blockquote><pre><code>* 创建线程示例* Thread类源码分析</code></pre></blockquote></blockquote><p>&gt;</p><blockquote><ul><li>实现Runnable接口</li></ul></blockquote><p>&gt;</p><blockquote><blockquote><pre><code>* 创建线程示例* Runnable接口源码分析</code></pre></blockquote></blockquote><hr><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1 继承Thread类"></a>1 继承Thread类</h2><h3 id="1-1-创建线程示例"><a href="#1-1-创建线程示例" class="headerlink" title="1.1 创建线程示例"></a>1.1 创建线程示例</h3><p>例如有15张票，有三个窗口，每个窗口卖五张票，可以使用继承Thread类实现多线程处理。</p><pre><code>import java.io.*;import java.lang.Thread;public class ExtendThread {    public static class MultiThread extends Thread {    private int total = 5;    private String name;    MultiThread(String name) {        // TODO Auto-generated constructor stub        super(name);    }    @Override    public void run () {        while (total &gt; 0) {            System.out.println(&quot;Ticket:&quot; + total-- + &quot; is saled by Thread:&quot; + Thread.currentThread().getName());        }    }}    public static void main(String[] args) {        // TODO Auto-generated method stub        MultiThread mt1 = new MultiThread(&quot;Thread1&quot;);        MultiThread mt2 = new MultiThread(&quot;Thread2&quot;);        MultiThread mt3 = new MultiThread(&quot;Thread3&quot;);        mt1.start();        mt2.start();        mt3.start();    }}运行结果如下：Ticket:5 is saled by Thread:Thread2Ticket:5 is saled by Thread:Thread1Ticket:5 is saled by Thread:Thread3Ticket:4 is saled by Thread:Thread3Ticket:3 is saled by Thread:Thread3Ticket:4 is saled by Thread:Thread1Ticket:4 is saled by Thread:Thread2Ticket:3 is saled by Thread:Thread1Ticket:2 is saled by Thread:Thread3Ticket:1 is saled by Thread:Thread3Ticket:2 is saled by Thread:Thread1Ticket:1 is saled by Thread:Thread1Ticket:3 is saled by Thread:Thread2Ticket:2 is saled by Thread:Thread2Ticket:1 is saled by Thread:Thread2</code></pre><h3 id="1-2-Thread类源码分析"><a href="#1-2-Thread类源码分析" class="headerlink" title="1.2 Thread类源码分析"></a>1.2 Thread类源码分析</h3><h4 id="1-2-1-类声明"><a href="#1-2-1-类声明" class="headerlink" title="1.2.1 类声明"></a>1.2.1 类声明</h4><pre><code>public class Thread extends Object implements Runnable；</code></pre><p>从类声明可以看出Thread实现了Runnable接口。</p><h4 id="1-2-2-构造函数"><a href="#1-2-2-构造函数" class="headerlink" title="1.2.2 构造函数"></a>1.2.2 构造函数</h4><p>Thread类的构造函数有8个，这里只介绍他的无参构造函数Thread()，其他构造函数可以到 <strong> <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener"><br>http://docs.oracle.com/javase/7/docs/api/</a> </strong> 学习了解。</p><pre><code>public Thread() {    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);}</code></pre><p>由init得第三个参数可以看出线程名称命名规则是Thread-加上线程数组合。 init函数的内部实现如下：</p><pre><code>/**     * Initializes a Thread.     *     * @param g the Thread group     * @param target the object whose run() method gets called     * @param name the name of the new Thread     * @param stackSize the desired stack size for the new thread, or     *        zero to indicate that this parameter is to be ignored.     */　　　　//ThreadGroup：线程组表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。    private void init(ThreadGroup g, Runnable target, String name,                      long stackSize) {    Thread parent = currentThread();    SecurityManager security = System.getSecurityManager();    if (g == null) {        /* Determine if it&apos;s an applet or not */        /* If there is a security manager, ask the security manager           what to do. */        if (security != null) {        g = security.getThreadGroup();        }        /* If the security doesn&apos;t have a strong opinion of the matter           use the parent thread group. */        if (g == null) {        g = parent.getThreadGroup();        }    }    /* checkAccess regardless of whether or not threadgroup is           explicitly passed in. */    g.checkAccess();    /*     * Do we have the required permissions?     */    if (security != null) {        if (isCCLOverridden(getClass())) {            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);        }    }        g.addUnstarted();    this.group = g;　　　　//每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。    this.daemon = parent.isDaemon();    this.priority = parent.getPriority();    this.name = name.toCharArray();    if (security == null || isCCLOverridden(parent.getClass()))        this.contextClassLoader = parent.getContextClassLoader();    else        this.contextClassLoader = parent.contextClassLoader;    this.inheritedAccessControlContext = AccessController.getContext();    this.target = target;    setPriority(priority);        if (parent.inheritableThreadLocals != null)        this.inheritableThreadLocals =        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);        /* Stash the specified stack size in case the VM cares */        this.stackSize = stackSize;        /* Set thread ID */        tid = nextThreadID();    }</code></pre><h4 id="1-2-3-run-方法"><a href="#1-2-3-run-方法" class="headerlink" title="1.2.3 run()方法"></a>1.2.3 run()方法</h4><p>run定义了线程实际完成的功能，具体源码如下：</p><pre><code>public void run() {    if (target != null) {        target.run();    }}</code></pre><p>target是接口Runnable实现的引用，由于run方法并未做任何实现，所以继承Thread类必须实现run方法。</p><h4 id="1-2-4-start-方法"><a href="#1-2-4-start-方法" class="headerlink" title="1.2.4 start()方法"></a>1.2.4 start()方法</h4><p>start方法作用为启动一个线程，源码如下：</p><pre><code>public synchronized void start() {        if (threadStatus != 0 || this != me)            throw new IllegalThreadStateException();        group.add(this);        start0();        if (stopBeforeStart) {        stop0(throwableFromStop);    } }</code></pre><p>start方法内部调用了本地方法start0创建线程，在创建线程之前会检查当前线程对象是否已经运行过start方法，确保一个线程对象只会运行一次start方<br>法。如果多次运行start方法，就会导致有多个线程同时操作相同的堆栈计数器等，导致无法预期的结果。</p><h4 id="1-2-5-yield-、wait-、sleep-方法"><a href="#1-2-5-yield-、wait-、sleep-方法" class="headerlink" title="1.2.5 yield()、wait()、sleep() 方法"></a>1.2.5 yield()、wait()、sleep() 方法</h4><p>yield方法使正在运行的线程变成就绪状态， <strong> 建议先运行其他线程 </strong><br>。但是这种方式只是建议，并不一定会让其他线程先运行，也有可能当前线程继续运行，yield方法只会让 <strong> 相同优先级的线程优先执行 </strong> 。<br>wait方法不属于Thread类，他是Object类的方法。这个方法释放线程锁，知道收到notify通知为止。<br>sleep方法会使线程休眠一段时间，但是休眠期间不会主动释放cpu资源。<br>这里面内容挺多，忙完这段时间，把和这几个方法相关的线程调度、同步锁等知识温习分享下。</p><h4 id="1-2-6-join-方法"><a href="#1-2-6-join-方法" class="headerlink" title="1.2.6 join()方法"></a>1.2.6 join()方法</h4><p>join方法的作用是强行运行要join的线程，阻塞当前线程知道join的线程执行完毕。如下示例：</p><pre><code>import java.io.*;import java.lang.Thread;public class TestJoin {    public static class MultiThreadA extends Thread {        private String name;        private int count = 5;        public MultiThreadA(String name) {            this.name = name;        }        @Override        public void run() {            while (count-- &gt; 0) {                try {                    Thread.currentThread().sleep(500);                } catch (Exception e) {                    // TODO: handle exception                }                System.out.println(name + count);            }        }    }    public static class MultiThreadB extends Thread {        private String name;        private int count = 5;        MultiThreadA a;        public MultiThreadB(MultiThreadA a) {        // TODO Auto-generated constructor stub            this.a = a;        }        @Override        public void run() {            try {                Thread.currentThread().sleep(505);            } catch (Exception e) {                // TODO: handle exception            }            System.out.println(&quot;Begin ThreadB&quot;);            try {                a.join();            } catch (InterruptedException e) {                // TODO: handle exception                System.out.println(&quot;getException&quot;);            }            System.out.println(&quot;End ThreadB&quot;);        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        MultiThreadA tA = new MultiThreadA(&quot;ThreadA&quot;);        MultiThreadB tB = new MultiThreadB(tA);        tA.start();        tB.start();    }}执行结果如下：ThreadA4Begin ThreadBThreadA3ThreadA2ThreadA1ThreadA0End ThreadB</code></pre><p>ThreadA首先打印了一条，然后ThreadB运行，遇到a.join()后运行ThreadA直到运行结束才会再次运行ThreadB。</p><h2 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h2><p>通过实现Runnable接口可以创建线程，实现的过程和Thread类内部实现很相似。</p><h3 id="2-1-创建线程示例"><a href="#2-1-创建线程示例" class="headerlink" title="2.1 创建线程示例"></a>2.1 创建线程示例</h3><p>Thread类演示了每个窗口售票不相互影响，各自卖五张票。如果需要三个窗口协同卖5张票，可以通过Runnalble共享变量，示例如下：</p><pre><code>import java.io.*;import java.lang.Thread;public class TestRunnable {    public static class MyThread implements Runnable {        private String name;        private int total = 5;        public MyThread(String name) {            // TODO Auto-generated constructor stub            this.name = name;        }        @Override        public synchronized void run() {            try {                Thread.currentThread().sleep(10);            } catch (Exception e) {                // TODO: handle exception            }            while (total &gt; 0) {                System.out.println(&quot;ticket:&quot; + total + &quot; is sold!&quot;);                total--;            }        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        MyThread mt = new MyThread(&quot;myThread&quot;);        Thread a = new Thread(mt);        Thread b = new Thread(mt);        Thread c = new Thread(mt);        a.start();        b.start();        c.start();    }}运行结果如下：ticket:5 is sold!ticket:4 is sold!ticket:3 is sold!ticket:2 is sold!ticket:1 is sold!</code></pre><p>三个线程共同完成5张票的售卖。</p><h3 id="2-2-Runnable源码分析"><a href="#2-2-Runnable源码分析" class="headerlink" title="2.2 Runnable源码分析"></a>2.2 Runnable源码分析</h3><p>Runnable接口中只有一个抽象run方法，所以不管是实现Runnable接口或者继承Thread类都需要重写run方法。</p><pre><code>public interface Runnable {     public abstract void run(); }</code></pre><hr><p>参考：</p>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：BufferedOutputStream使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9ABufferedOutputStream%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>BufferedOutputStream继承于FilterOutputStream，提供缓冲输出流功能。缓冲输出流相对于普通输出流的优势是，它提供了一个缓冲<br>数组，只有缓冲数组满了或者手动flush时才会向磁盘写数据，避免频繁IO。核心思想是，提供一个缓冲数组，写入时首先操作缓冲数组。</p><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>BufferedOutputStream提供的API如下：</p><pre><code>//构造函数BufferedOutputStream(OutputStream out) //默认缓冲数组大小为8192BufferedOutputStream(OutputStream out, int size)synchronized void     close() //关闭synchronized void     flush() //刷盘synchronized void     write(byte[] b, int off, int len) //向输出流写数据synchronized void     write(int b)</code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code>public void testBufferedOutput() {    try {        final byte [] letters = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;};        /*         *创建文件输出流out,缓冲区大小为8         */        OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(&quot;buff.txt&quot;)), 8);        /*将letters前6个字符写入到输出流*/        out.write(letters, 0 ,6);        /*此时不会写入任何数据到磁盘文件*/        readFile();        /*继续写入4个字符*/        for (int i = 0; i &lt; 4; i++) {            out.write(&apos;g&apos; + i);        }        /*此时只会写入8个字符到磁盘文件*/        readFile();        /*此时会把所有内容写入磁盘文件*/        out.flush();        readFile();    } catch (Exception e) {        e.printStackTrace();    }}private void readFile() {    try {        InputStream in = new FileInputStream(&quot;buff.txt&quot;);        byte [] bytes = new byte[20];        in.read(bytes, 0, bytes.length);        System.out.println(&quot;文件中的内容为: &quot;  + new String(bytes));    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>文件中的内容为:文件中的内容为: abcdefgh文件中的内容为: abcdefghij</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>BufferedOutputStream的构造方法有两个，区别是字节缓冲数组大小。</p><pre><code>/** * Creates a new buffered output stream to write data to the * specified underlying output stream. * * @param   out   the underlying output stream. */public BufferedOutputStream(OutputStream out) {    this(out, 8192);}/** * Creates a new buffered output stream to write data to the * specified underlying output stream with the specified buffer * size. * * @param   out    the underlying output stream. * @param   size   the buffer size. * @exception IllegalArgumentException if size &amp;lt;= 0. */public BufferedOutputStream(OutputStream out, int size) {    super(out);    if (size &lt;= 0) {        throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);    }    buf = new byte[size];}</code></pre><h3 id="write方法"><a href="#write方法" class="headerlink" title="write方法"></a>write方法</h3><p>write方法有两个重载方法，分别是协议一个字节的write(int b)和写入一个字节数组的write(byte b[], int off, int<br>len)。下面分析第二个方法的源码。</p><pre><code>/** * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array * starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream. * * &lt;p&gt; Ordinarily this method stores bytes from the given array into this * stream&apos;s buffer, flushing the buffer to the underlying output stream as * needed.  If the requested length is at least as large as this stream&apos;s * buffer, however, then this method will flush the buffer and write the * bytes directly to the underlying output stream.  Thus redundant * &lt;code&gt;BufferedOutputStream&lt;/code&gt;s will not copy data unnecessarily. * * @param      b     the data. * @param      off   the start offset in the data. * @param      len   the number of bytes to write. * @exception  IOException  if an I/O error occurs. */public synchronized void write(byte b[], int off, int len) throws IOException {    if (len &gt;= buf.length) { //如果写入长度比buf长度长,直接写入文件，不走缓冲区        /* If the request length exceeds the size of the output buffer,           flush the output buffer and then write the data directly.           In this way buffered streams will cascade harmlessly. */        flushBuffer(); //将原有缓冲区内容刷盘        out.write(b, off, len); //直接写入文件        return;    }    if (len &gt; buf.length - count) { //可用空间不足,先刷盘        flushBuffer();    }    System.arraycopy(b, off, buf, count, len); //复制写入    count += len;}/** Flush the internal buffer */private void flushBuffer() throws IOException {    if (count &gt; 0) {        out.write(buf, 0, count);        count = 0;    }}</code></pre><h3 id="flush方法"><a href="#flush方法" class="headerlink" title="flush方法"></a>flush方法</h3><pre><code>/** * Flushes this buffered output stream. This forces any buffered * output bytes to be written out to the underlying output stream. * * @exception  IOException  if an I/O error occurs. * @see        java.io.FilterOutputStream#out */public synchronized void flush() throws IOException {    flushBuffer(); //刷盘    out.flush(); //未做任何实现}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/io_13.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_13.html</a><br>[2] <a href="http://czj4451.iteye.com/blog/1545159" target="_blank" rel="noopener"> http://czj4451.iteye.com/blog/1545159</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：ArrayList使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9AArrayList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>ArrayList是数组队列，可以实现容量的动态增长。ArrayList类继承了AbstractList抽象类并且实现了List、RandomAccess，<br>Cloneable以及java.io.Serializable接口。<br>public class ArrayList extends AbstractList implements List, RandomAccess,<br>Cloneable, java.io.Serializable<br>AbstractList类继承了AbstractCollection类并实现了List接口。<br>实现RandomAccess接口使ArrayList拥有随机访问的能力，即通过下表索引访问数组元素。<br>实现Cloneable接口重写了接口定义的clone()方法，ArrayList可以使用clone()复制数组。<br>实现 java.io.Serializable接口使ArrayList支持序列化。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>ArrayList提供了增加、删除、判空等操作，具体提供的方法如下：</p><pre><code>// Collection中定义的APIboolean             add(E object)  //增加元素boolean             addAll(Collection&lt;? extends E&gt; collection) //复制另一个Collection中的所有元素void                clear() //清空数组boolean             contains(Object object) //判断数组中是否包含objectboolean             containsAll(Collection&lt;?&gt; collection) //判断另一个数组是否是这个数组的子集boolean             equals(Object object) //判断元素是否相等int                 hashCode() //获取hash codeboolean             isEmpty() //判空Iterator&lt;E&gt;         iterator() //迭代器boolean             remove(Object object) //删除元素boolean             removeAll(Collection&lt;?&gt; collection)  //删除collection包含的元素boolean             retainAll(Collection&lt;?&gt; collection) //保留collection包含的元素int                 size() //获取数组大小&lt;T&gt; T[]             toArray(T[] array)  //转换成T类型的数组Object[]            toArray() //转换成Object类型的数组// AbstractCollection中定义的APIvoid                add(int location, E object) //指定位置增加元素boolean             addAll(int location, Collection&lt;? extends E&gt; collection) //指定位置开始增加多个元素E                   get(int location) //获取location位置的元素int                 indexOf(Object object) //获取object首次出现的位置int                 lastIndexOf(Object object) //获取object最后一次出现的位置ListIterator&lt;E&gt;     listIterator(int location) //迭代器，从location起始ListIterator&lt;E&gt;     listIterator() //迭代器E                   remove(int location) //删除location位置的元素E                   set(int location, E object) //重置location位置的元素为objectList&lt;E&gt;             subList(int start, int end) //获取[start, end)之间的元素// ArrayList新增的APIObject               clone() //复制元素void                 ensureCapacity(int minimumCapacity) //最低容量void                 trimToSize() //修剪数组大小为当前元素个数void                 removeRange(int fromIndex, int toIndex) //删除[fromIndex, toIndex)之间的元素</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>package com;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Main {    public static void main(String[] args) {   // write your code here        List list = new ArrayList&lt;&gt;(20); //申请一个初始容量为20的ArrayList        String element; //要填充的元素        for (int i = 0; i &lt; 10; i++) {            element = &quot;num-&quot; + i;            list.add(element); // 填充list        }        list.add(10, &quot;num-10&quot;); //在指定位置增加元素        //使用Iterator遍历list        for (Iterator iter = list.iterator(); iter.hasNext();) {            System.out.print(iter.next() + &quot; &quot;);        }        System.out.println(&quot; &quot;);        System.out.println(&quot;The second element is: &quot; + list.get(1)); //获取第2个元素        System.out.println(&quot;array size is: &quot; + list.size()); //获取list大小        System.out.println(&quot;is array list contains num-15:&quot; + list.contains(&quot;num-15&quot;)); //判断list是否含有num-15        list.set(2,&quot;num-3-1&quot;); //将第三个元素设置为num-3-1        String[] arr = (String[])list.toArray(new String[0]); //将ArrayList转换为数组        for (String str:arr) { //遍历数组            System.out.print(str + &quot; &quot;);        }    }}</code></pre><p>运行结果如下：</p><pre><code>num-0 num-1 num-2 num-3 num-4 num-5 num-6 num-7 num-8 num-9 num-10The second element is: num-1array size is: 11is array list contains num-15:falsenum-0 num-1 num-3-1 num-3 num-4 num-5 num-6 num-7 num-8 num-9 num-10</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>ArrayList有三个构造函数，提供三种创建ArrayList实例的方法。</p><pre><code>/** * 获取一个初始长度为initialCapacity的空ArrayList * @param initialCapacity */public ArrayList(int initialCapacity) {    if (initialCapacity &gt; 0) {        this.elementData = new Object[initialCapacity];    } else if (initialCapacity == 0) {        this.elementData = EMPTY_ELEMENTDATA;    } else {        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                initialCapacity);    }}/** * 返回一个空ArrayList */public ArrayList() {    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}/** * 返回一个用ArrayList,并且用集合c进行初始化 * @param c */public ArrayList(Collection&lt;? extends E&gt; c) {    elementData = c.toArray();    if ((size = elementData.length) != 0) {        // c.toArray might (incorrectly) not return Object[] (see 6260652)        if (elementData.getClass() != Object[].class)            elementData = Arrays.copyOf(elementData, size, Object[].class);    } else {        // replace with empty array.        this.elementData = EMPTY_ELEMENTDATA;    }}</code></pre><h3 id="2-2-add方法"><a href="#2-2-add方法" class="headerlink" title="2.2 add方法"></a>2.2 add方法</h3><pre><code>/** * 增加元素 * @param e * @return */public boolean add(E e) {    ensureCapacityInternal(size + 1);  // 确定ArrayList长度    elementData[size++] = e; //向数组中增加元素    return true;}</code></pre><h3 id="2-3-remove方法"><a href="#2-3-remove方法" class="headerlink" title="2.3 remove方法"></a>2.3 remove方法</h3><pre><code>/** * 删除元素 * @param index * @return */public E remove(int index) {    rangeCheck(index); //检查下标是否合法    modCount++;    E oldValue = elementData(index); //获取删除的元素    int numMoved = size - index - 1;    if (numMoved &gt; 0) //移动元素        System.arraycopy(elementData, index+1, elementData, index,                numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;}</code></pre><h3 id="2-4-toArray方法"><a href="#2-4-toArray方法" class="headerlink" title="2.4 toArray方法"></a>2.4 toArray方法</h3><p>toArray有两个重载方法，一个不带参数返回Object数字，另一个带参数，返回任意类型的数组。</p><pre><code>/** * 返回Object对象的数组 * @return */public Object[] toArray() {    return Arrays.copyOf(elementData, size);}/** * 返回任意对象类型的数组 * @param a * @param &lt;T&gt; * @return */public &lt;T&gt; T[] toArray(T[] a) {    if (a.length &lt; size) //传入数组大小小于size时,直接返回一个新数组        // Make a new array of a&apos;s runtime type, but my contents:        return (T[]) Arrays.copyOf(elementData, size, a.getClass());    System.arraycopy(elementData, 0, a, 0, size); //传入数组大小大于size,将ArrayList中的内容复制到数组中    if (a.length &gt; size)        a[size] = null;    return a;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/3308556.html</a><br>[2] <a href="http://blog.chinaunix.net/uid-29702073-id-4334609.html" target="_blank" rel="noopener"> http://blog.chinaunix.net/uid-29702073-id-4334609.html</a><br>[3] <a href="http://www.cnblogs.com/hzmark/archive/2012/12/20/ArrayList.html" target="_blank" rel="noopener"> http://www.cnblogs.com/hzmark/archive/2012/12/20/ArrayList.html</a></p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：Hashtable使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9AHashtable%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>Hashtable是和HashMap类似的散列表，存储的内容为key-value键值对，key的值是唯一的，和HashMap不同的是key和value都不能<br>为null。Hashtable和HashMap的关系可以参考Vector和ArrayList的关系，操作和功能大部分相同，Hashtable是线程安全的但是<br>速度较慢，建议使用HashMap，如果遇到多线程情况则使用concurrentHashMap或者Collections提供静态函数SynchronizedM<br>ap等来保证线程安全。</p><pre><code>public class Hashtable&lt;K,V&gt;        extends Dictionary&lt;K,V&gt;        implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable {}</code></pre><p>HashMap继承了Dictionary并实现了Map、Cloneable以及Serializable接口，所以HashMap支持clone和序列化。</p><h3 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h3><p>Hashtable提供的API主要有如下几种：</p><pre><code>synchronized void                clear() //清空Hashtablesynchronized Object              clone() //复制Hashtableboolean             contains(Object value) //判断是否包含valuesynchronized boolean             containsKey(Object key) //是否包含keysynchronized boolean             containsValue(Object value) //是否包含valuesynchronized Enumeration&lt;V&gt;      elements() //获取value组成的枚举synchronized Set&lt;Entry&lt;K, V&gt;&gt;    entrySet() //获取entry组成的Set集合synchronized boolean             equals(Object object) //判断相等synchronized V                   get(Object key) //获取键值为key的entrysynchronized int                 hashCode() //获取hashCodesynchronized boolean             isEmpty() //判空synchronized Set&lt;K&gt;              keySet() //获取key组成的Set集合synchronized Enumeration&lt;K&gt;      keys() //获取key组成的枚举synchronized V                   put(K key, V value) //添加元素synchronized void                putAll(Map&lt;? extends K, ? extends V&gt; map) //添加一组元素synchronized V                   remove(Object key) //删除键为key的元素synchronized int                 size() //获取大小synchronized String              toString() //返回Hashtable键值组成的字符串synchronized Collection&lt;V&gt;       values() //获取值组成的Collection集合</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public void testHashtable() {        //新建hashtable        Hashtable hashtable = new Hashtable();        //添加元素        hashtable.put(1, &quot;one&quot;);        hashtable.put(2, &quot;two&quot;);        hashtable.put(3, &quot;three&quot;);        hashtable.put(4, &quot;four&quot;);        //打印元素        this.printMapByEntrySet(hashtable);        //获取大小        System.out.println(&quot;hashtable的大小为: &quot; + hashtable.size());        //是否包含key为4的元素        System.out.println(&quot;hashtable是否包含key为4的元素: &quot; + hashtable.containsKey(4));        //是否包含值为5的元素        System.out.println(&quot;hashtable是否包含value为two的元素: &quot; + hashtable.containsValue(&quot;two&quot;));        hashtable.put(5, &quot;five&quot;);        hashtable.put(6, &quot;six&quot;);        //删除元素        System.out.println(&quot;删除key为2的元素: &quot; + hashtable.remove(2));        //打印元素        this.printMapByKeySet(hashtable);        //clone        Hashtable cloneTable = (Hashtable) hashtable.clone();        //打印克隆table        System.out.println(&quot;clonetable的元素为: &quot; + cloneTable);        //打印克隆table的keys        this.printHashtableKeysByEnum(cloneTable);        //清空hashtable        hashtable.clear();        //判空        System.out.println(&quot;hashtable是否为空: &quot; + hashtable.isEmpty());    }    /**     * 根据entrySet()获取Entry集合,然后遍历Set集合获取键值对     * @param hashtable     */    private void printMapByEntrySet(Hashtable hashtable) {        Integer key = null;        String value = null;        Iterator iterator = hashtable.entrySet().iterator(); //        System.out.print(&quot;hashtable中含有的元素有: &quot;);        while (iterator.hasNext()) {            Map.Entry entry = (Map.Entry) iterator.next();            key = (Integer) entry.getKey();            value = (String) entry.getValue();            System.out.print(&quot;key/value : &quot; + key + &quot;/&quot; + value + &quot; &quot;);        }        System.out.println();    }    /**     * 使用keySet获取key的Set集合,利用key获取值     * @param hashtable     */    private void printMapByKeySet(Hashtable hashtable) {        Integer key = null;        String value = null;        Iterator iterator = hashtable.keySet().iterator();        System.out.print(&quot;hashtable中含有的元素有: &quot;);        while (iterator.hasNext()) {            key = (Integer) iterator.next();            value = (String) hashtable.get(key);            System.out.print(&quot;key/value : &quot; + key + &quot;/&quot; + value + &quot; &quot;);        }        System.out.println();    }    /**     * 使用枚举获取hashtable的keys     * @param hashtable     */    private void printHashtableKeysByEnum(Hashtable hashtable) {        Enumeration enumeration = hashtable.keys();        System.out.print(&quot;hashtable的key有: &quot;);        while (enumeration.hasMoreElements()) {            System.out.print(enumeration.nextElement() + &quot; &quot;);        }        System.out.println();    }}</code></pre><p>运行结果如下：</p><pre><code>hashtable中含有的元素有: key/value : 4/four key/value : 3/three key/value : 2/two key/value : 1/onehashtable的大小为: 4hashtable是否包含key为4的元素: truehashtable是否包含value为two的元素: true删除key为2的元素: twohashtable中含有的元素有: key/value : 6/six key/value : 5/five key/value : 4/four key/value : 3/three key/value : 1/oneclonetable的元素为: {6=six, 5=five, 4=four, 3=three, 1=one}hashtable的key有: 6 5 4 3 1hashtable是否为空: true</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>Hashtable有四个构造函数，每个构造函数的不同之处和hashMap构造函数类似在于初始容量和加载因子不同。初始容量为申请的Hashtable初始大小，<br>当加入元素后的容量大于加载因子和当前容量的乘积是，Hashtable需要再hash增大容量。</p><pre><code>/** * 构造一个空的Hashtable,容量为initialCapacity,加载因子为loadFactor * * @param      initialCapacity   the initial capacity of the hashtable. * @param      loadFactor        the load factor of the hashtable. * @exception  IllegalArgumentException  if the initial capacity is less *             than zero, or if the load factor is nonpositive. */public Hashtable(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0) //非法参数检查        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                initialCapacity);    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);    if (initialCapacity==0) //最少容量为1        initialCapacity = 1;    this.loadFactor = loadFactor;    table = new Entry&lt;?,?&gt;[initialCapacity]; //元素数组    //再hash阈值,和HashMap不同.HashMap构造时阈值为大于或者等于initialCapacity的最小的2的倍数    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);}/** * 构造一个初始容量为initialCapacity,加载因子为0.75的Hashtable. * * @param     initialCapacity   the initial capacity of the hashtable. * @exception IllegalArgumentException if the initial capacity is less *              than zero. */public Hashtable(int initialCapacity) {    this(initialCapacity, 0.75f);}/** * Constructs a new, empty hashtable with a default initial capacity (11) * and load factor (0.75). */public Hashtable() {    this(11, 0.75f);}/** * 构造并使用t初始化一个Hashtable,大小为t大小两倍和者11中的较大数,加载因子为0.75. * * @param t the map whose mappings are to be placed in this map. * @throws NullPointerException if the specified map is null. * @since   1.2 */public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {    this(Math.max(2*t.size(), 11), 0.75f);    putAll(t);}</code></pre><h3 id="2-2-put方法"><a href="#2-2-put方法" class="headerlink" title="2.2 put方法"></a>2.2 put方法</h3><pre><code>/** * 向Hashtable中添加元素 * * @param      key     the hashtable key * @param      value   the value * @return     the previous value of the specified key in this hashtable, *             or &lt;code&gt;null&lt;/code&gt; if it did not have one * @exception  NullPointerException  if the key or value is *               &lt;code&gt;null&lt;/code&gt; * @see     Object#equals(Object) * @see     #get(Object) */public synchronized V put(K key, V value) {    // Make sure the value is not null    if (value == null) {        throw new NullPointerException();    }    // Makes sure the key is not already in the hashtable.    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    @SuppressWarnings(&quot;unchecked&quot;)    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];    for(; entry != null ; entry = entry.next) {        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {            V old = entry.value;            entry.value = value;            return old;        }    }    addEntry(hash, key, value, index);    return null;}private void addEntry(int hash, K key, V value, int index) {    modCount++;    Entry&lt;?,?&gt; tab[] = table;    if (count &gt;= threshold) {        // Rehash the table if the threshold is exceeded        rehash();        tab = table;        hash = key.hashCode();        index = (hash &amp; 0x7FFFFFFF) % tab.length;    }    // Creates the new entry.    @SuppressWarnings(&quot;unchecked&quot;)    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];    tab[index] = new Entry&lt;&gt;(hash, key, value, e);    count++;}</code></pre><h3 id="2-3-get方法"><a href="#2-3-get方法" class="headerlink" title="2.3 get方法"></a>2.3 get方法</h3><pre><code>/** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key.equals(k))}, * then this method returns {@code v}; otherwise it returns * {@code null}.  (There can be at most one such mapping.) * * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or *         {@code null} if this map contains no mapping for the key * @throws NullPointerException if the specified key is null * @see     #put(Object, Object) */@SuppressWarnings(&quot;unchecked&quot;)public synchronized V get(Object key) {    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length; //获取下标    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { //遍历链表        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {            return (V)e.value;        }    }    return null;}</code></pre><p>2.4 remove方法</p><pre><code>/** * Removes the key (and its corresponding value) from this * hashtable. This method does nothing if the key is not in the hashtable. * * @param   key   the key that needs to be removed * @return  the value to which the key had been mapped in this hashtable, *          or &lt;code&gt;null&lt;/code&gt; if the key did not have a mapping * @throws  NullPointerException  if the key is &lt;code&gt;null&lt;/code&gt; */public synchronized V remove(Object key) {    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    @SuppressWarnings(&quot;unchecked&quot;)    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];    for(Entry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) {        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {            modCount++;            if (prev != null) { //不是链表的第一个元素, 跳过要删除的节点                prev.next = e.next;            } else {                tab[index] = e.next; //第一个节点            }            count--;            V oldValue = e.value;            e.value = null; //删除节点的value, help GC            return oldValue;        }    }    return null;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/3310887.html</a><br>[2] <a href="http://blog.csdn.net/ns_code/article/details/36191279" target="_blank" rel="noopener"> http://blog.csdn.net/ns_code/article/details/36191279</a><br>[3] 《Java编程思想》第4版</p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：HashMap使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9AHashMap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>HashMap是散列表，存储的内容为key-value键值对，key的值是唯一的，可以为null。</p><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {}</code></pre><p>HashMap继承了AbstractMap并实现了Map、Cloneable以及Serializable接口，所以HashMap支持clone和序列化。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>HashMap提供的API主要如下：</p><pre><code>void                 clear() //清空HashMapObject               clone() //复制HashMapboolean              containsKey(Object key) //判断是否存在keyboolean              containsValue(Object value) //判断是否存在ValueSet&lt;Entry&lt;K, V&gt;&gt;     entrySet() //返回HashMap的Entry组成的set集合V                    get(Object key) //获取键为key的元素值boolean              isEmpty() //判空Set&lt;K&gt;               keySet() //获取HashMap的key组成的set集合V                    put(K key, V value) //加入HashMapvoid                 putAll(Map&lt;? extends K, ? extends V&gt; map) //批量加入V                    remove(Object key) //删除键为key的Entryint                  size() //获取大小Collection&lt;V&gt;        values() //获取HashMap的value集合</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public void testHashMap() {    //新建hashMap    HashMap hashMap = new HashMap(); //新建hashMap    //添加元素    hashMap.put(1, &quot;one&quot;);    hashMap.put(2, &quot;two&quot;);    hashMap.put(3, &quot;three&quot;);    hashMap.put(4, &quot;four&quot;);    //打印元素    this.printMapByEntrySet(hashMap);    //获取大小    System.out.println(&quot;hashMap的大小为: &quot; + hashMap.size());    //是否包含key为4的元素    System.out.println(&quot;hashMap是否包含key为4的元素: &quot; + hashMap.containsKey(4));    //是否包含值为5的元素    System.out.println(&quot;hashMap是否包含value为two的元素: &quot; + hashMap.containsValue(&quot;two&quot;));    hashMap.put(5, &quot;five&quot;);    hashMap.put(6, &quot;six&quot;);    //删除元素    System.out.println(&quot;删除key为2的元素: &quot; + hashMap.remove(2));    //打印元素    this.printMapByKeySet(hashMap);    //clone    HashMap cloneMap = (HashMap) hashMap.clone();    //打印克隆map    System.out.println(&quot;cloneMap的元素为: &quot; + cloneMap);    //清空map    hashMap.clear();    //判空    System.out.println(&quot;hashMap是否为空: &quot; + hashMap.isEmpty());}/** * 根据entrySet()获取Entry集合,然后遍历Set集合获取键值对 * @param map */private void printMapByEntrySet(HashMap map) {    Integer key = null;    String value = null;    Iterator iterator = map.entrySet().iterator(); //    System.out.print(&quot;hashMap中含有的元素有: &quot;);    while (iterator.hasNext()) {        Map.Entry entry = (Map.Entry) iterator.next();        key = (Integer) entry.getKey();        value = (String) entry.getValue();        System.out.print(&quot;key/value : &quot; + key + &quot;/&quot; + value + &quot; &quot;);    }    System.out.println();}/** * 使用keySet获取key的Set集合,利用key获取值 * @param map */private void printMapByKeySet(HashMap map) {    Integer key = null;    String value = null;    Iterator iterator = map.keySet().iterator();    System.out.print(&quot;hashMap中含有的元素有: &quot;);    while (iterator.hasNext()) {        key = (Integer) iterator.next();        value = (String) map.get(key);        System.out.print(&quot;key/value : &quot; + key + &quot;/&quot; + value + &quot; &quot;);    }    System.out.println();}</code></pre><p>运行结果如下：</p><pre><code>hashMap中含有的元素有: key/value : 1/one key/value : 2/two key/value : 3/three key/value : 4/fourhashMap的大小为: 4hashMap是否包含key为4的元素: truehashMap是否包含value为two的元素: true删除key为2的元素: twohashMap中含有的元素有: key/value : 1/one key/value : 3/three key/value : 4/four key/value : 5/five key/value : 6/sixcloneMap的元素为: {1=one, 3=three, 4=four, 5=five, 6=six}hashMap是否为空: true</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>HashMap有四个构造函数，每个构造函数的不同之处在于初始容量和加载因子不同。初始容量为申请的HashMap初始大小，当加入元素后的容量大于加载因子和当前<br>容量的乘积是，HashMap需要再hash增大容量。</p><pre><code>/** * 申请初始容量为initialCapacity, 加载因子为loadFactor * @param initialCapacity 初始容量 * @param loadFactor 加载因子 * @throws IllegalArgumentException 非法参数异常 */public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY) //最大容量为2^30        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                loadFactor);    this.loadFactor = loadFactor; //加载因子    this.threshold = tableSizeFor(initialCapacity); //容量大小, &gt;=initialCapacity的最小的2的倍数}/** * 初始容量大小为initialCapacity, 加载因子为默认0.75 * @param  initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */public HashMap(int initialCapacity) {    this(initialCapacity, DEFAULT_LOAD_FACTOR);}/** * 初始容量大小为0, 加载因子为0.75 */public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}/** * 申请一个HashMap并且用m初始化 * * @param   m the map whose mappings are to be placed in this map * @throws  NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);}</code></pre><h3 id="2-2-put方法"><a href="#2-2-put方法" class="headerlink" title="2.2 put方法"></a>2.2 put方法</h3><pre><code>/** * 为HashMap插入一个键为key,值为value的元素 * @param key * @param value * @return */public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&apos;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0) //hash数组为null或者长度为0        n = (tab = resize()).length; //初始化数组    if ((p = tab[i = (n - 1) &amp; hash]) == null) //下标不存在,则这个下表所对应的元素为一个新节点        tab[i] = newNode(hash, key, value, null);    else { //将元素节点链接到链表最后        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //键已经存在            e = p;        else if (p instanceof TreeNode) //TreeNode节点            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) { //将元素节点链接到最后                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //键存在                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold) //超过容量值        resize();    afterNodeInsertion(evict);    return null;}</code></pre><h3 id="2-3-get方法"><a href="#2-3-get方法" class="headerlink" title="2.3 get方法"></a>2.3 get方法</h3><pre><code>/** * 获取键为key的键值对的值 * @param key * @return */public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}2.4 remove方法/** * 删除键为key的键值对 * @param key * @return */public V remove(Object key) {    Node&lt;K,V&gt; e;    return (e = removeNode(hash(key), key, null, false, true)) == null ?            null : e.value;}/** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                           boolean matchValue, boolean movable) {    Node&lt;K, V&gt;[] tab;    Node&lt;K, V&gt; p;    int n, index;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (p = tab[index = (n - 1) &amp; hash]) != null) { //hash表不为空,长度 &gt; 0,下标对应的元素存在        Node&lt;K, V&gt; node = null, e;        K k;        V v;        if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //判断第一个元素            node = p;        else if ((e = p.next) != null) { //同一下标有多个元素,遍历链表            if (p instanceof TreeNode)                node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);            else {                do {                    if (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                                    (key != null &amp;&amp; key.equals(k)))) {                        node = e;                        break;                    }                    p = e;                } while ((e = e.next) != null);            }        }        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                (value != null &amp;&amp; value.equals(v)))) { //删除元素            if (node instanceof TreeNode)                ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable);            else if (node == p)                tab[index] = node.next;            else                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        }    }}</code></pre><h2 id="3-HashMap和Hashtable区别"><a href="#3-HashMap和Hashtable区别" class="headerlink" title="3 HashMap和Hashtable区别"></a>3 HashMap和Hashtable区别</h2><p>HashMap和Hashtable从功能上来说几乎完全相同，主要区别在于Hashtable是线程安全的而HashMap不是。<br>1）HashMap的key和Value可以接受null，Hashtable不行；<br>2）Hashtable除了构造函数外几乎所有的方法都加上了synchronized保证线程安全，HashMap没有线程安全保证；<br>3） Hashtable由于使用了synchronized导致在单线程情况下速度较慢；<br>4） Hashtable构造时默认大小为11，HashMap为16；</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/3310835.html</a><br>[2] <a href="http://blog.csdn.net/mazhimazh/article/details/17876641" target="_blank" rel="noopener"> http://blog.csdn.net/mazhimazh/article/details/17876641</a><br>[3] <a href="http://blog.csdn.net/ns_code/article/details/36034955" target="_blank" rel="noopener"> http://blog.csdn.net/ns_code/article/details/36034955</a></p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：ConcurrentHashMap源码分析_JDK1.8.md</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88:_ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_JDK1.8/"/>
      <content type="html"><![CDATA[<p>转载文章，原博客地址为： <a href="http://blog.csdn.net/u010887744/article/details/50637030" target="_blank" rel="noopener"> http://blog.csdn.net/u010887744/article/details/50637030</a></p><p>jdk1.8和jdk1.7对于ConcurrentHashMap的实现出现的重大变化，不再采用分段锁的方法，网上这方面的博客较少，这篇文章写得较好，转载扩撒<br>。</p><p>本文首写于有道云笔记，并在小组分享会分享，先整理发布，希望和大家交流探讨。 <a href="http://note.youdao.com/share/?id=dde7a10b98aee57676408bc475ab0680&amp;type=note" target="_blank" rel="noopener"> 云笔记地址</a></p><p>概述：</p><p>1、设计首要目的：维护并发可读性（get、迭代相关）；次要目的：使空间消耗比HashMap相同或更好，且支持多线程高效率的初始插入（empty<br>table）。</p><p>2、HashTable  线程安全，但采用synchronized，多线程下效率低下。线程1put时，线程2无法put或get。</p><p>实现原理：</p><p>锁分离：</p><p>在HashMap的基础上，将数据分段存储，  ConcurrentHashMap由多个Segment组成，每个Segment都有把锁。<br>Segment下包含很多Node，也就是我们的键值对了。</p><p><strong> 如果还停留在锁分离、Segment，那已经out了。  </strong></p><p>Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。</p><ul><li><strong> CAS算法 </strong> ；  unsafe.compareAndSwapInt(this, valueOffset, expect, update);  CAS(Compare And Swap)，意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。 </li><li>与Java8的HashMap有相通之处，底层依然由 <strong> “数组”+链表+红黑树 </strong> ； </li><li>底层结构存放的是 <strong> TreeBin </strong> 对象，而不是TreeNode对象； </li><li>CAS作为知名无锁算法，那ConcurrentHashMap就没用锁了么？当然不是，hash值相同的链表的头结点还是会synchronized上锁。 </li></ul><p>private  static  final  int  MAXIMUM_CAPACITY  = 1 &lt;&lt; 30; // 2的30次方=1073741824</p><p>private  static  final  int  DEFAULT_CAPACITY  = 16;</p><p>static  final  int  MAX_ARRAY_SIZE  = Integer.  MAX_VALUE  - 8; //<br>MAX_VALUE=2^31-1=2147483647</p><p>private  static  final  int  DEFAULT_CONCURRENCY_LEVEL  = 16;</p><p>private  static  final  float  LOAD_FACTOR  = 0.75f;</p><p>static  final  int  TREEIFY_THRESHOLD  <strong> = 8; </strong> //  链表转树阀值，大于8时</p><p>static  final  int  UNTREEIFY_THRESHOLD  <strong> = 6; </strong> //  树转链表阀值，小于等于6（tranfer时，<br>lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）。【<br>仅在扩容tranfer时  才可能树转链表】</p><p>static  final  int  MIN_TREEIFY_CAPACITY  = 64;</p><p>private  static  final  int  MIN_TRANSFER_STRIDE  = 16;</p><p>private  static  int  RESIZE_STAMP_BITS  = 16;</p><p>private  static  final  int  MAX_RESIZERS  <strong> = (1 &lt;&lt; (32 - </strong> <strong><br>RESIZE_STAMP_BITS  </strong> <strong> )) - 1; </strong> // 2^15-1，hel  p resize的最大线程数</p><p>private  static  final  int  RESIZE_STAMP_SHIFT  <strong> = 32 - </strong> <strong><br>RESIZE_STAMP_BITS  </strong> <strong> ; </strong> // 32-16=16，sizeCtl  中记录size大小的偏移量</p><p>static  final  int  MOVED  <strong> = -1; </strong> // hash for forwarding nodes（for<br>warding nodes的hash值）、标示位</p><p>static  final  int  TREEBIN  <strong> = -2; </strong> // hash for roots of tree<br>s（树根节点的hash值）</p><p>static  final  int  RESERVED  <strong> = -3; </strong> // hash for transient reservations<br>（ReservationNode的hash值）</p><p>static  final  int  HASH_BITS  = 0x7fffffff;  // usable bits of normal node<br>hash</p><p>static  final  int  NCPU  <strong> = Runtime.  getRuntime  ().availableProcessors();</strong> // 可用处理器数量</p><p>/**</p><ul><li><p>Table initialization and resizing control.  When negative, the </p></li><li><p>table is being initialized or resized:  -  1 for initialization, </p></li><li><p>else  -  (1 + the number of active resizing threads).  Otherwise, </p></li><li><p>when table is null, holds the initial table size to use upon </p></li><li><p>creation, or 0 for default. After initialization, holds the </p></li><li><p>next element count value upon which to resize the table. </p></li></ul><p>*/ </p><p>private  transient  volatile  int  sizeCtl  ;</p><p>sizeCtl  是  控制标识符，不同的值表示不同的意义。</p><ul><li>负数代表正在进行初始化或扩容操作 </li><li>-1代表正在初始化 </li><li>-N 表示有N-1个线程正在进行扩容操作 </li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，类似于扩容阈值。它的值  始终是当前ConcurrentHashMap容量的0.75倍  ，这与loadfactor是对应的。  实际容量  &gt;=sizeCtl，则扩容。 </li></ul><p>部分构造函数：</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  ConcurrentHashMap(  int  initialCapacity, </li><li>float  loadFactor,  int  concurrencyLevel) { </li><li>if  (!(loadFactor &gt; 0  .0f) || initialCapacity &lt; 0  || concurrencyLevel &lt;=  0  ) </li><li>thrownew IllegalArgumentException(); </li><li>if  (initialCapacity &lt; concurrencyLevel)  // Use at least as many bins </li><li>initialCapacity = concurrencyLevel;  // as estimated threads </li><li>long  size = (  long  )(  1.0  + (  long  )initialCapacity / loadFactor); </li><li>int  cap = (size &gt;= (  long  )MAXIMUM_CAPACITY) ? </li><li>MAXIMUM_CAPACITY : tableSizeFor((  int  )size); </li><li>this  .sizeCtl = cap; </li><li>} </li></ol><p>concurrencyLevel  ：</p><p>concurrencyLevel，能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，在Java8之前实际上就是ConcurrentH<br>ashMap中的分段锁个数，即Segment[]的数组长度  。<br>正确地估计很重要，当低估，数据结构将根据额外的竞争，从而导致线程试图写入当前锁定的段时阻塞；<br>相反，如果高估了并发级别，你遇到过大的膨胀，由于段的不必要的数量;  这种膨胀可能会导致性能下降，由于高数缓存未命中。</p><p>在Java8里，仅仅是为了 <strong> 兼容旧版本而保留 </strong> 。唯一的作用就是保证构造map时初始容量不小于concurrencyLevel。</p><p>源码122行：</p><p>Also, for compatibility with previous  versions of this class, constructors<br>may optionally specify an  expected {@code concurrencyLevel} as an additional<br>hint for  internal sizing.</p><p>源码482行：</p><p>Mainly: We  leave untouched but unused constructor arguments refering to<br>concurrencyLevel .……</p><p>……</p><p>1、重要属性：</p><p>1.1 Node：</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>static  class  Node<k,v> implements  Map.Entry<k,v> { </k,v></k,v></li><li>final  int  hash; </li><li>final  K key; </li><li>volatile  V val;  // Java8增加volatile，保证可见性 </li><li>volatile  Node<k,v> next; </k,v></li><li><ol><li>Node(inthash, K key, V val, Node<k,v> next) { </k,v></li></ol></li><li>this  .hash = hash; </li><li>this  .key = key; </li><li>this  .val = val; </li><li>this  .next = next; </li><li>} </li><li><ol><li>public  final  K getKey()       {  return  key; } </li></ol></li><li>public  final  V getValue()     {  return  val; } </li><li>// HashMap调用Objects.hashCode()，最终也是调用Object.hashCode()；效果一样 </li><li>public  final  int  hashCode()   { returnkey.hashCode() ^ val.hashCode(); } </li><li>public  final  String toString(){ returnkey +  “=”  + val; } </li><li>public  final  V setValue(V value) {  // 不允许修改value值，HashMap允许 </li><li>throw  new  UnsupportedOperationException(); </li><li>} </li><li>// HashMap使用if (o == this)，且嵌套if；concurrent使用&amp;&amp;</li><li>public  final  boolean  equals(Object o) { </li><li>Object k, v, u; Map.Entry&lt;?,?&gt; e; </li><li>return  ((oinstanceof Map.Entry) &amp;&amp;</li><li>(k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) !=  null  &amp;&amp;</li><li>(v = e.getValue()) !=  null  &amp;&amp;</li><li>(k == key || k.equals(key)) &amp;&amp;</li><li>(v == (u = val) || v.equals(u))); </li><li>} </li><li><ol><li>/** </li></ol></li><li><ul><li>Virtualized support for map.get(); overridden in subclasses. </li></ul></li><li>*/ </li><li>Node<k,v> find(inth, Object k) {  // 增加find方法辅助get方法 </k,v></li><li>Node<k,v> e =  this  ; </k,v></li><li>if  (k !=  null  ) { </li><li>do  { </li><li>K ek; </li><li>if  (e.hash == h &amp;&amp;</li><li>((ek = e.key) == k || (ek !=  null  &amp;&amp; k.equals(ek)))) </li><li>returne; </li><li>}  while  ((e = e.next) !=  null  ); </li><li>} </li><li>returnnull; </li><li>} </li><li>} </li></ol><p>1.2 TreeNode  </p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// Nodes for use in TreeBins，链表&gt;8，才可能转为TreeNode. </li><li>// HashMap的TreeNode继承至LinkedHashMap.Entry；而这里继承至自己实现的Node，将带有next指针，便于treebin访问。 </li><li>static  final  class  TreeNode<k,v> extends  Node<k,v> { </k,v></k,v></li><li>TreeNode<k,v> parent;  // red-black tree links </k,v></li><li>TreeNode<k,v> left; </k,v></li><li>TreeNode<k,v> right; </k,v></li><li>TreeNode<k,v> prev;  // needed to unlink next upon deletion </k,v></li><li>boolean  red; </li><li><ol><li>TreeNode(inthash, K key, V val, Node<k,v> next, </k,v></li></ol></li><li>TreeNode<k,v> parent) { </k,v></li><li>super  (hash, key, val, next); </li><li>this  .parent = parent; </li><li>} </li><li><ol><li>Node<k,v> find(inth, Object k) { </k,v></li></ol></li><li>return  findTreeNode(h, k,  null  ); </li><li>} </li><li><ol><li>/** </li></ol></li><li><ul><li>Returns the TreeNode (or null if not found) for the given key </li></ul></li><li><ul><li>starting at given root. </li></ul></li><li>*/  // 查找hash为h，key为k的节点 </li><li>final  TreeNode<k,v> findTreeNode(  int  h, Object k, Class&lt;?&gt; kc) { </k,v></li><li>if  (k !=  null  ) {  // 比HMap增加判空 </li><li>TreeNode<k,v> p =  this  ; </k,v></li><li>do  { </li><li>intph, dir; K pk; TreeNode<k,v> q; </k,v></li><li>TreeNode<k,v> pl = p.left, pr = p.right; </k,v></li><li>if  ((ph = p.hash) &gt; h) </li><li>p = pl; </li><li>elseif (ph &lt; h) </li><li>p = pr; </li><li>elseif ((pk = p.key) == k || (pk !=  null  &amp;&amp; k.equals(pk))) </li><li>returnp; </li><li>elseif (pl ==  null  ) </li><li>p = pr; </li><li>elseif (pr ==  null  ) </li><li>p = pl; </li><li>elseif ((kc !=  null  || </li><li>(kc = comparableClassFor(k)) !=  null  ) &amp;&amp;</li><li>(dir = compareComparables(kc, k, pk)) !=  0  ) </li><li>p = (dir &lt; 0  ) ? pl : pr; </li><li>elseif ((q = pr.findTreeNode(h, k, kc)) !=  null  ) </li><li>returnq; </li><li>else </li><li>p = pl; </li><li>}  while  (p !=  null  ); </li><li>} </li><li>return  null  ; </li><li>} </li><li>} </li><li>// 和HashMap相比，这里的TreeNode相当简洁；ConcurrentHashMap链表转树时，并不会直接转，正如注释（Nodes for use in TreeBins）所说，只是把这些节点包装成TreeNode放到TreeBin中，再由TreeBin来转化红黑树。 </li></ol><p>1.3  TreeBin</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// TreeBin用于封装维护TreeNode，包含putTreeVal、lookRoot、UNlookRoot、remove、balanceInsetion、balanceDeletion等方法，这里只分析其构造函数。 </li><li>// 当链表转树时，用于封装TreeNode，也就是说，ConcurrentHashMap的红黑树存放的时TreeBin，而不是treeNode。 </li><li>TreeBin(TreeNode<k,v> b) { </k,v></li><li>super  (TREEBIN,  null  ,  null  ,  null  );  //hash值为常量TREEBIN=-2,表示roots of trees </li><li>this  .first = b; </li><li>TreeNode<k,v> r =  null  ; </k,v></li><li>for  (TreeNode<k,v> x = b, next; x !=  null  ; x = next) { </k,v></li><li>next = (TreeNode<k,v>)x.next; </k,v></li><li>x.left = x.right =  null  ; </li><li>if  (r ==  null  ) { </li><li>x.parent =  null  ; </li><li>x.red =  false  ; </li><li>r = x; </li><li>} </li><li>else  { </li><li>K k = x.key; </li><li>inth = x.hash; </li><li>Class&lt;?&gt; kc =  null  ; </li><li>for  (TreeNode<k,v> p = r;;) { </k,v></li><li>intdir, ph; </li><li>K pk = p.key; </li><li>if  ((ph = p.hash) &gt; h) </li><li>dir = -  1  ; </li><li>elseif (ph &lt; h) </li><li>dir =  1  ; </li><li>elseif ((kc ==  null  &amp;&amp;</li><li>(kc = comparableClassFor(k)) ==  null  ) || </li><li>(dir = compareComparables(kc, k, pk)) ==  0  ) </li><li>dir = tieBreakOrder(k, pk); </li><li>TreeNode<k,v> xp = p; </k,v></li><li>if  ((p = (dir &lt;=  0  ) ? p.left : p.right) ==  null  ) { </li><li>x.parent = xp; </li><li>if  (dir &lt;=  0  ) </li><li>xp.left = x; </li><li>else </li><li>xp.right = x; </li><li>r = balanceInsertion(r, x); </li><li>break  ; </li><li>} </li><li>} </li><li>} </li><li>} </li><li>this  .root = r; </li><li>assert  checkInvariants(root); </li><li>} </li></ol><p>1.4  treeifyBin</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>/** </li><li><ul><li>Replaces all linked nodes in bin at given index unless table is </li></ul></li><li><ul><li>too small, in which case resizes instead.链表转树 </li></ul></li><li>*/ </li><li>private  final  void  treeifyBin(Node<k,v>[] tab,  int  index) { </k,v></li><li>Node<k,v> b; intn, sc; </k,v></li><li>if  (tab !=  null  ) { </li><li>if  ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) </li><li>tryPresize(n &lt;&lt; 1  );  // 容量&lt;64，则table两倍扩容，不转树了 </li><li>else  if  ((b = tabAt(tab, index)) !=  null  &amp;&amp; b.hash &gt;=  0  ) { </li><li>synchronized  (b) {  // 读写锁 </li><li>if  (tabAt(tab, index) == b) { </li><li>TreeNode<k,v> hd =  null  , tl =  null  ; </k,v></li><li>for  (Node<k,v> e = b; e !=  null  ; e = e.next) { </k,v></li><li>TreeNode<k,v> p = </k,v></li><li>new  TreeNode<k,v>(e.hash, e.key, e.val, </k,v></li><li>null  ,  null  ); </li><li>if  ((p.prev = tl) ==  null  ) </li><li>hd = p; </li><li>else </li><li>tl.next = p; </li><li>tl = p; </li><li>} </li><li>setTabAt(tab, index,  new  TreeBin<k,v>(hd)); </k,v></li><li>} </li><li>} </li><li>} </li><li>} </li><li>} </li></ol><p>1.5  ForwardingNode</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// A node inserted at head of bins during transfer operations.连接两个table </li><li>// 并不是我们传统的包含key-value的节点，只是一个标志节点，并且指向nextTable，提供find方法而已。生命周期：仅存活于扩容操作且bin不为null时，一定会出现在每个bin的首位。 </li><li>static  final  class  ForwardingNode<k,v> extends  Node<k,v> { </k,v></k,v></li><li>final  Node<k,v>[] nextTable; </k,v></li><li>ForwardingNode(Node<k,v>[] tab) { </k,v></li><li>super  (MOVED,  null  ,  null  ,  null  );  // 此节点hash=-1，key、value、next均为null </li><li>this  .nextTable = tab; </li><li>} </li><li><ol><li>Node<k,v> find(  int  h, Object k) { </k,v></li></ol></li><li>// 查nextTable节点，outer避免深度递归 </li><li>outer:  for  (Node<k,v>[] tab = nextTable;;) { </k,v></li><li>Node<k,v> e; intn; </k,v></li><li>if  (k ==  null  || tab ==  null  || (n = tab.length) ==  0  || </li><li>(e = tabAt(tab, (n -  1  ) &amp; h)) ==  null  ) </li><li>returnnull; </li><li>for  (;;) {  // CAS算法多和死循环搭配！直到查到或null </li><li>int  eh; K ek; </li><li>if  ((eh = e.hash) == h &amp;&amp;</li><li>((ek = e.key) == k || (ek !=  null  &amp;&amp; k.equals(ek)))) </li><li>returne; </li><li>if  (eh &lt; 0  ) { </li><li>if  (e  instanceof  ForwardingNode) { </li><li>tab = ((ForwardingNode<k,v>)e).nextTable; </k,v></li><li>continue  outer; </li><li>} </li><li>else </li><li>return  e.find(h, k); </li><li>} </li><li>if  ((e = e.next) ==  null  ) </li><li>return  null  ; </li><li>} </li><li>} </li><li>} </li><li>} </li></ol><p>1.6  3个原子操作（调用频率很高）</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>@SuppressWarnings  (  “unchecked”  )  // ASHIFT等均为private static final </li><li>static  final  <k,v> Node<k,v> tabAt(Node<k,v>[] tab,  int  i) {  // 获取索引i处Node </k,v></k,v></k,v></li><li>return  (Node<k,v>)U.getObjectVolatile(tab, ((  long  )i &lt;&lt; ASHIFT) + ABASE); </k,v></li><li>} </li><li>// 利用CAS算法设置i位置上的Node节点（将c和table[i]比较，相同则插入v）。 </li><li>static  final  <k,v> boolean  casTabAt(Node<k,v>[] tab,  int  i, </k,v></k,v></li><li>Node<k,v> c, Node<k,v> v) { </k,v></k,v></li><li>return  U.compareAndSwapObject(tab, ((  long  )i &lt;&lt; ASHIFT) + ABASE, c, v); </li><li>} </li><li>// 设置节点位置的值，仅在上锁区被调用 </li><li>static  final  <k,v> void  setTabAt(Node<k,v>[] tab,  int  i, Node<k,v> v) { </k,v></k,v></k,v></li><li>U.putObjectVolatile(tab, ((  long  )i &lt;&lt; ASHIFT) + ABASE, v); </li><li>} </li></ol><p>1.7  Unsafe</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>//在源码的6277行到最后，有着ConcurrentHashMap中极为重要的几个属性（SIZECTL），unsafe静态块控制其修改行为。Java8中，大量运用CAS进行变量、属性的无锁修改，大大提高性能。 </li><li>// Unsafe mechanics </li><li>private  static  final  sun.misc.Unsafe U; </li><li>private  static  final  long  SIZECTL; </li><li>private  static  final  long  TRANSFERINDEX; </li><li>private  static  final  long  BASECOUNT; </li><li>private  static  final  long  CELLSBUSY; </li><li>private  static  final  long  CELLVALUE; </li><li>private  static  final  long  ABASE; </li><li>private  static  final  int  ASHIFT; </li><li><ol><li>static  { </li></ol></li><li>try  { </li><li>U = sun.misc.Unsafe.getUnsafe(); </li><li>Class&lt;?&gt; k = ConcurrentHashMap.  class  ; </li><li>SIZECTL = U.objectFieldOffset (k.getDeclaredField(  “sizeCtl”  )); </li><li>TRANSFERINDEX=U.objectFieldOffset(k.getDeclaredField(  “transferIndex”  )); </li><li>BASECOUNT = U.objectFieldOffset (k.getDeclaredField(  “baseCount”  )); </li><li>CELLSBUSY = U.objectFieldOffset (k.getDeclaredField(  “cellsBusy”  )); </li><li>Class&lt;?&gt; ck = CounterCell.  class  ; </li><li>CELLVALUE = U.objectFieldOffset (ck.getDeclaredField(  “value”  )); </li><li>Class&lt;?&gt; ak = Node[].  class  ; </li><li>ABASE = U.arrayBaseOffset(ak); </li><li>intscale = U.arrayIndexScale(ak); </li><li>if  ((scale &amp; (scale -  1  )) !=  0  ) </li><li>thrownew Error(  “data type scale not a power of two”  ); </li><li>ASHIFT =  31  - Integer.numberOfLeadingZeros(scale); </li><li>}  catch  (Exception e) { </li><li>thrownew Error(e); </li><li>} </li><li>} </li></ol><p>1.8  扩容相关</p><p>tryPresize  在  putAll以及treeifyBin中调用</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>private  final  void  tryPresize(  int  size) { </li><li>// 给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容 </li><li>int  c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1  )) ? MAXIMUM_CAPACITY : </li><li>tableSizeFor(size + (size &gt;&gt;&gt; 1  ) +  1  ); </li><li>int  sc; </li><li>while  ((sc = sizeCtl) &gt;=  0  ) {  //没有正在初始化或扩容，或者说表还没有被初始化 </li><li>Node<k,v>[] tab = table;  int  n; </k,v></li><li>if  (tab ==  null  || (n = tab.length) ==  0  ) { </li><li>n = (sc &gt; c) ? sc : c;  // 扩容阀值取较大者 </li><li>// 期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化 </li><li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc, -  1  )) { </li><li>try  { </li><li>if  (table == tab) { </li><li>@SuppressWarnings  (  “unchecked”  ) </li><li>Node<k,v>[] nt = (Node<k,v>[])  new  Node&lt;?,?&gt;[n]; </k,v></k,v></li><li>table = nt; </li><li>sc = n - (n &gt;&gt;&gt; 2  );  //无符号右移2位，此即0.75*n </li><li>} </li><li>}  finally  { </li><li>sizeCtl = sc;  // 更新扩容阀值 </li><li>} </li><li>} </li><li>}  // 若欲扩容值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 </li><li>else  if  (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) </li><li>break  ; </li><li>else  if  (tab == table) {  // table不为空，且在此期间其他线程未修改table </li><li>int  rs = resizeStamp(n); </li><li>if  (sc &lt; 0  ) { </li><li>Node<k,v>[] nt;  //RESIZE_STAMP_SHIFT=16,MAX_RESIZERS=2^15-1 </k,v></li><li>if  ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs +  1  || </li><li>sc == rs + MAX_RESIZERS || (nt = nextTable) ==  null  || </li><li>transferIndex &lt;=  0  ) </li><li>break  ; </li><li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc, sc +  1  )) </li><li>transfer(tab, nt); </li><li>} </li><li>else  if  (U.compareAndSwapInt(  this  , SIZECTL, sc, </li><li>(rs &lt;&lt; RESIZE_STAMP_SHIFT) +  2  )) </li><li>transfer(tab,  null  ); </li><li>} </li><li>} </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>private  static  final  int  tableSizeFor(  int  c){  //和HashMap一样,返回&gt;=n的最小2的自然数幂 </li><li>int  n = c -  1  ; </li><li>n |= n &gt;&gt;&gt; 1  ; </li><li>n |= n &gt;&gt;&gt; 2  ; </li><li>n |= n &gt;&gt;&gt; 4  ; </li><li>n |= n &gt;&gt;&gt; 8  ; </li><li>n |= n &gt;&gt;&gt; 16  ; </li><li>return  (n &lt; 0  ) ?  1  : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n +  1  ; </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>/** </li><li><ul><li>Returns the stamp bits for resizing a table of size n. </li></ul></li><li><ul><li>Must be negative when shifted left by RESIZE_STAMP_SHIFT. </li></ul></li><li>*/ </li><li>static  final  int  resizeStamp(  int  n) {  // 返回一个标志位 </li><li>return  Integer.numberOfLeadingZeros(n) | (  1  &lt;&lt; (RESIZE_STAMP_BITS -  1  )); </li><li>}  // numberOfLeadingZeros返回n对应32位二进制数左侧0的个数，如9（1001）返回28 </li><li>// RESIZE_STAMP_BITS=16,(左侧0的个数)|(2^15) </li></ol><p><strong> ConcurrentHashMap无锁多线程扩容，减少扩容时的时间消耗。 </strong></p><p><strong> transfer扩容操作 </strong> <strong> ： </strong> 单线程构建两倍容量的nextTable；允许多线程复制原table元素到nextTable。 </p><ol><li>为每个内核均分任务，并保证其不小于16； </li><li>若nextTab为null，则初始化其为原table的2倍； </li><li>死循环遍历，直到finishing。 </li></ol><ul><li>节点为空，则插入ForwardingNode； </li><li>链表节点（fh&gt;=0），分别插入nextTable的i和i+n的位置；【逆序链表？？】 </li><li>TreeBin节点（fh&lt;0），判断是否需要untreefi，分别插入nextTable的i和i+n的位置；【逆序树？？】 </li><li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。 </li></ul><p><strong> 以上说的都是单线程，  多线程  又是如何实现的呢？ </strong></p><p>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心  。  由于<br>给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此<br>便完成了多线程的复制工作，也解决了线程安全问题。</p><p>private  transient  volatile  Node<k,v>[]  nextTable  ;  //仅仅在扩容使用，并且此时非空</k,v></p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// 将table每一个bin（桶位）的Node移动或复制到nextTable </li><li>// 只在addCount(long x, int check)、helpTransfer、tryPresize中调用 </li><li>private  final  void  transfer(Node<k,v>[] tab, Node<k,v>[] nextTab) { </k,v></k,v></li><li>int  n = tab.length, stride; </li><li>// 每核处理的量小于16，则强制赋值16 </li><li>if  ((stride = (NCPU &gt; 1  ) ? (n &gt;&gt;&gt; 3  ) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) </li><li>stride = MIN_TRANSFER_STRIDE;  // subdivide range </li><li>if  (nextTab ==  null  ) {  // initiating </li><li>try  { </li><li>@SuppressWarnings  (  “unchecked”  ) </li><li>Node<k,v>[] nt = (Node<k,v>[])  new  Node&lt;?,?&gt;[n &lt;&lt; 1  ];  //两倍 </k,v></k,v></li><li>nextTab = nt; </li><li>}  catch  (Throwable ex) {  // try to cope with OOME </li><li>sizeCtl = Integer.MAX_VALUE; </li><li>return  ; </li><li>} </li><li>nextTable = nextTab; </li><li>transferIndex = n; </li><li>} </li><li>int  nextn = nextTab.length; </li><li>//连节点指针,标志位，fwd的hash值为-1，fwd.nextTable=nextTab。 </li><li>ForwardingNode<k,v> fwd=  new  ForwardingNode<k,v>(nextTab); </k,v></k,v></li><li>boolean  advance=  true  ;  //并发扩容的关键属性,等于true,说明此节点已经处理过 </li><li>boolean  finishing =  false  ;  // to ensure sweep before committing nextTab </li><li>for  (  int  i =  0  , bound =  0  ;;) {  // 死循环 </li><li>Node<k,v> f;  int  fh; </k,v></li><li>while  (advance) {  // 控制–i，遍历原hash表中的节点 </li><li>int  nextIndex, nextBound; </li><li>if  (–i &gt;= bound || finishing) </li><li>advance =  false  ; </li><li>else  if  ((nextIndex = transferIndex) &lt;=  0  ) { </li><li>i = -  1  ; </li><li>advance =  false  ; </li><li>}  //TRANSFERINDEX 即用CAS计算得到的transferIndex </li><li>else  if  (U.compareAndSwapInt </li><li>(  this  , TRANSFERINDEX, nextIndex, </li><li>nextBound = (nextIndex &gt; stride ? </li><li>nextIndex - stride :  0  ))) { </li><li>bound = nextBound; </li><li>i = nextIndex -  1  ; </li><li>advance =  false  ; </li><li>} </li><li>} </li><li>if  (i &lt; 0  || i &gt;= n || i + n &gt;= nextn) { </li><li>int  sc; </li><li>if  (finishing) {  // 所有节点复制完毕 </li><li>nextTable =  null  ; </li><li>table = nextTab; </li><li>sizeCtl = (n &lt;&lt; 1  ) - (n &gt;&gt;&gt; 1  );  //扩容阀值设为原来的1.5倍，即现在的0.75倍 </li><li>return  ;  // 仅有的2个跳出死循环出口之一 </li><li>}  //CAS更新扩容阈值,sc-1表明新加入一个线程参与扩容 </li><li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc = sizeCtl, sc -  1  )) { </li><li>if  ((sc -  2  ) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) </li><li>return  ;  // 仅有的2个跳出死循环出口之一 </li><li>finishing = advance =  true  ; </li><li>i = n;  // recheck before commit </li><li>} </li><li>} </li><li>else  if  ((f = tabAt(tab, i)) ==  null  )  //该节点为空，则插入ForwardingNode </li><li>advance = casTabAt(tab, i,  null  , fwd); </li><li>//遍历到ForwardingNode节点，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 </li><li>else  if  ((fh = f.hash) == MOVED)  // MOVED=-1，hash for fwd </li><li>advance =  true  ;  // already processed </li><li>else  { </li><li>synchronized  (f) {  //上锁 </li><li>if  (tabAt(tab, i) == f) { </li><li>Node<k,v> ln, hn;  //ln原位置节点，hn新位置节点 </k,v></li><li>if  (fh &gt;=  0  ) {  // 链表 </li><li>int  runBit = fh &amp; n;  // f.hash &amp; n </li><li>Node<k,v> lastRun = f;  // lastRun和p两个链表，逆序？？ </k,v></li><li>for  (Node<k,v> p = f.next; p !=  null  ; p = p.next) { </k,v></li><li>int  b = p.hash &amp; n;  // f.next.hash &amp; n </li><li>if  (b != runBit) { </li><li>runBit = b; </li><li>lastRun = p; </li><li>} </li><li>} </li><li>if  (runBit ==  0  ) { </li><li>ln = lastRun; </li><li>hn =  null  ; </li><li>} </li><li>else  { </li><li>hn = lastRun; </li><li>ln =  null  ; </li><li>} </li><li>for  (Node<k,v> p = f; p != lastRun; p = p.next) { </k,v></li><li>int  ph = p.hash; K pk = p.key; V pv = p.val; </li><li>if  ((ph &amp; n) ==  0  )  // 和HashMap确定扩容后的节点位置一样 </li><li>ln =  new  Node<k,v>(ph, pk, pv, ln); </k,v></li><li>else </li><li>hn =  new  Node<k,v>(ph, pk, pv, hn);  //新位置节点 </k,v></li><li>}  //类似HashMap，为何i+n？参见HashMap的笔记 </li><li>setTabAt(nextTab, i, ln);  //在nextTable[i]插入原节点 </li><li>setTabAt(nextTab, i + n, hn);  //在nextTable[i+n]插入新节点 </li><li>//在nextTable[i]插入forwardNode节点，表示已经处理过该节点 </li><li>setTabAt(tab, i, fwd); </li><li>//设置advance为true 返回到上面的while循环中 就可以执行–i操作 </li><li>advance =  true  ; </li><li>} </li><li>else  if  (f  instanceof  TreeBin) {  //树 </li><li>TreeBin<k,v> t = (TreeBin<k,v>)f; </k,v></k,v></li><li>TreeNode<k,v> lo =  null  , loTail =  null  ; </k,v></li><li>TreeNode<k,v> hi =  null  , hiTail =  null  ; </k,v></li><li>//lc、hc=0两计数器分别++记录原、新bin中TreeNode数量 </li><li>int  lc =  0  , hc =  0  ; </li><li>for  (Node<k,v> e = t.first; e !=  null  ; e = e.next) { </k,v></li><li>int  h = e.hash; </li><li>TreeNode<k,v> p =  new  TreeNode<k,v></k,v></k,v></li><li>(h, e.key, e.val,  null  ,  null  ); </li><li>if  ((h &amp; n) ==  0  ) { </li><li>if  ((p.prev = loTail) ==  null  ) </li><li>lo = p; </li><li>else </li><li>loTail.next = p; </li><li>loTail = p; </li><li>++lc; </li><li>} </li><li>else  { </li><li>if  ((p.prev = hiTail) ==  null  ) </li><li>hi = p; </li><li>else </li><li>hiTail.next = p; </li><li>hiTail = p; </li><li>++hc; </li><li>} </li><li>}  //扩容后树节点个数若&lt;=6，将树转链表 </li><li>ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : </li><li>(hc !=  0  ) ?  new  TreeBin<k,v>(lo) : t; </k,v></li><li>hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : </li><li>(lc !=  0  ) ?  new  TreeBin<k,v>(hi) : t; </k,v></li><li>setTabAt(nextTab, i, ln); </li><li>setTabAt(nextTab, i + n, hn); </li><li>setTabAt(tab, i, fwd); </li><li>advance =  true  ; </li><li>} </li><li>} </li><li>} </li><li>} </li><li>} </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// 协助扩容方法。多线程下，当前线程检测到其他线程正进行扩容操作，则协助其一起扩容；（只有这种情况会被调用）从某种程度上说，其“优先级”很高，只要检测到扩容，就会放下其他工作，先扩容。 </li><li>// 调用之前，nextTable一定已存在。 </li><li>final  Node<k,v>[] helpTransfer(Node<k,v>[] tab, Node<k,v> f) { </k,v></k,v></k,v></li><li>Node<k,v>[] nextTab; intsc; </k,v></li><li>if  (tab !=  null  &amp;&amp; (finstanceof ForwardingNode) &amp;&amp;</li><li>(nextTab = ((ForwardingNode<k,v>)f).nextTable) !=  null  ) { </k,v></li><li>intrs = resizeStamp(tab.length);  //标志位 </li><li>while  (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</li><li>(sc = sizeCtl) &lt; 0  ) { </li><li>if  ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs +  1  || </li><li>sc == rs + MAX_RESIZERS || transferIndex &lt;=  0  ) </li><li>break  ; </li><li>if  (U.compareAndSwapInt(  this  , SIZECTL, sc, sc +  1  )) { </li><li>transfer(tab, nextTab);  //调用扩容方法，直接进入复制阶段 </li><li>break  ; </li><li>} </li><li>} </li><li>return  nextTab; </li><li>} </li><li>return  table; </li><li>} </li></ol><p>2、 put相关：</p><p>理一下put的流程：</p><p>① <strong> 判空 </strong> ：null直接抛空指针异常；</p><p>② <strong> hash </strong> ：计算h=key.hashcode；调用spread计算hash=  (  h  ^  (  h  &gt;&gt;&gt; 16  ))  &amp;<br>HASH_BITS；</p><p>③ <strong> 遍历table </strong></p><ul><li>若table为空，则初始化，仅设置相关参数； </li><li>@@@计算当前key存放位置，即table的下标i=(n - 1) &amp; hash； </li><li>若待存放位置为null，casTabAt  无锁  插入； </li><li>若是forwarding nodes（检测到正在扩容），则helpTransfer（帮助其扩容）； </li><li>else（待插入位置非空且不是forward节点，即碰撞了），将头节点上锁（保证了线程安全）：区分链表节点和树节点，分别插入（遇到hash值与key值都与新节点一致的情况，只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点）； </li><li>若链表长度&gt;8，则treeifyBin转树（Note：若length&lt;64,直接tryPresize,两倍table.length;不转树）。 </li></ul><p>④ <strong> addCount(1L, binCount)。 </strong></p><p><strong> Note： </strong></p><p>1、put操作共计两次hash操作，再利用“与&amp;”操作计算Node的存放位置。</p><p>2、ConcurrentHashMap不允许key或value为null。</p><p>3、 <strong> addCount  (  long  x  ,  int  check  )  方法： </strong></p><p>①利用CAS快速更新baseCount的值；</p><p>②check&gt;=0.则检验是否需要扩容；  if  sizeCtl&lt;0（正在进行初始化或扩容操作）【nexttable<br>null等情况break；如果有线程正在扩容，则协助扩容】；  else if  仅当前线程在扩容，调用协助扩容函数，注其参数nextTable为null。</p><p>public  V put(K  key  , V  value  ) {</p><p>return  putVal  (  key  ,  value  ,  false  );</p><p>}</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>final  V <span style="background-color: rgb(255, 255, 51);">putVal</span>(K key, V value,  boolean  onlyIfAbsent) { </li><li>// 不允许key、value为空 </li><li>if  (key ==  null  || value ==  null  )  throw  new  NullPointerException(); </li><li>int  hash = spread(key.hashCode());  //返回(h^(h&gt;&gt;&gt;16))&amp;HASH_BITS </li><li>int  binCount =  0  ; </li><li>for  (Node<k,v>[] tab = table;;) {  // 死循环，直到插入成功 </k,v></li><li>Node<k,v> f;  int  n, i, fh; </k,v></li><li>if  (tab ==  null  || (n = tab.length) ==  0  ) </li><li>tab = initTable();  // table为空，初始化table </li><li>else  if  ((f = tabAt(tab, i = (n -  1  ) &amp; hash)) ==  null  ) {  // 索引处无值 </li><li>if  (casTabAt(tab, i,  null  , </li><li>new  Node<k,v>(hash, key, value,  null  ))) </k,v></li><li>break  ;  // no lock when adding to empty bin </li><li>} </li><li>else  if  ((fh = f.hash) == MOVED)  // MOVED=-1;//hash for forwarding nodes </li><li>tab = helpTransfer(tab, f);  //检测到正在扩容，则帮助其扩容 </li><li>else  { </li><li>V oldVal =  null  ; </li><li>synchronized  (f) {  // 节点上锁（hash值相同的链表的头节点） </li><li>if  (tabAt(tab, i) == f) { </li><li>if  (fh &gt;=  0  ) {  // 链表节点 </li><li>binCount =  1  ; </li><li>for  (Node<k,v> e = f;; ++binCount) { </k,v></li><li>K ek;  // hash和key相同，则修改value </li><li>if  (e.hash == hash &amp;&amp;</li><li>((ek = e.key) == key ||(ek !=  null  &amp;&amp; key.equals(ek)))) { </li><li>oldVal = e.val; </li><li>if  (!onlyIfAbsent)  //仅putIfAbsent()方法中onlyIfAbsent为true </li><li>e.val = value;  //putIfAbsent()包含key则返回get，否则put并返回 </li><li>break  ; </li><li>} </li><li>Node<k,v> pred = e; </k,v></li><li>if  ((e = e.next) ==  null  ) {  //已遍历到链表尾部，直接插入 </li><li>pred.next =  new  Node<k,v>(hash, key, value,  null  ); </k,v></li><li>break  ; </li><li>} </li><li>} </li><li>} </li><li>else  if  (f  instanceof  TreeBin) {  // 树节点 </li><li>Node<k,v> p; </k,v></li><li>binCount =  2  ; </li><li>if  ((p = ((TreeBin<k,v>)f).putTreeVal(hash, key,value)) !=  null  ) { </k,v></li><li>oldVal = p.val; </li><li>if  (!onlyIfAbsent) </li><li>p.val = value; </li><li>} </li><li>} </li><li>} </li><li>} </li><li>if  (binCount !=  0  ) { </li><li>if  (binCount &gt;= TREEIFY_THRESHOLD)  //实则是&gt;8,执行else,说明该桶位本就有Node </li><li>treeifyBin(tab, i);  //若length&lt;64,直接tryPresize,两倍table.length;不转树 </li><li>if  (oldVal !=  null  ) </li><li>return  oldVal; </li><li>break  ; </li><li>} </li><li>} </li><li>} </li><li>addCount(1L, binCount); </li><li>return  null  ; </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// Initializes table, using the size recorded in sizeCtl. </li><li>private  final  Node<k,v>[] <span style="background-color: rgb(255, 255, 51);">initTable</span>() {  // 仅仅设置参数，并未实质初始化 </k,v></li><li>Node<k,v>[] tab; intsc; </k,v></li><li>while  ((tab = table) ==  null  || tab.length ==  0  ) { </li><li>if  ((sc = sizeCtl) &lt; 0  )  // 其他线程正在初始化，此线程挂起 </li><li>Thread.yield();  // lost initialization race; just spin </li><li>//CAS方法把sizectl置为-1，表示本线程正在进行初始化 </li><li>elseif (U.compareAndSwapInt(  this  , SIZECTL, sc, -  1  )) { </li><li>try  { </li><li>if  ((tab = table) ==  null  || tab.length ==  0  ) { </li><li>intn = (sc &gt; 0  ) ? sc : DEFAULT_CAPACITY;  //DEFAULT_CAPACITY=16 </li><li>@SuppressWarnings  (  “unchecked”  ) </li><li>Node<k,v>[] nt = (Node<k,v>[])  new  Node&lt;?,?&gt;[n]; </k,v></k,v></li><li>table = tab = nt; </li><li>sc = n - (n &gt;&gt;&gt; 2  );  // 扩容阀值，0.75*n </li><li>} </li><li>}  finally  { </li><li>sizeCtl = sc; </li><li>} </li><li>break  ; </li><li>} </li><li>} </li><li>return  tab; </li><li>} </li></ol><p>3、 get、contains相关</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  V <span style="background-color: rgb(255, 255, 51);">get</span>(Object key) { </li><li>Node<k,v>[] tab; Node<k,v> e, p; intn, eh; K ek; </k,v></k,v></li><li>inth = spread(key.hashCode()); </li><li>if  ((tab = table) !=  null  &amp;&amp; (n = tab.length) &gt; 0  &amp;&amp;</li><li>(e = tabAt(tab, (n -  1  ) &amp; h)) !=  null  ) {  //tabAt(i),获取索引i处Node </li><li>if  ((eh = e.hash) == h) { </li><li>if  ((ek = e.key) == key || (ek !=  null  &amp;&amp; key.equals(ek))) </li><li>returne.val; </li><li>} </li><li>elseif (eh &lt; 0  )  // 树 </li><li>return  (p = e.find(h, key)) !=  null  ? p.val :  null  ; </li><li>while  ((e = e.next) !=  null  ) {  // 链表 </li><li>if  (e.hash == h &amp;&amp;</li><li>((ek = e.key) == key || (ek !=  null  &amp;&amp; key.equals(ek)))) </li><li>returne.val; </li><li>} </li><li>} </li><li>return  null  ; </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  boolean  containsKey(Object key) {  return  get(key) !=  null  ;} </li><li>public  boolean  containsValue(Object value) {} </li></ol><p>理一下get的流程：</p><p>①spread计算hash值；</p><p>②table不为空；</p><p>③tabAt(i)处桶位不为空；</p><p>④check first，是则返回当前Node的value；否则分别根据树、链表查询。</p><p>4、 Size相关：</p><p>由于ConcurrentHashMap在统计size时  可能正被  多个线程操作，而我们又不可能让他停下来让我们计算，所以只能计量一个估计值。</p><p>计数辅助：</p><p>//  Table of counter cells. When non-null, size is a power of 2</p><p>private  transient  volatile  CounterCell[]  counterCells  ;</p><p>@  sun.misc.  Contended  static  final  class  CounterCell  {</p><p>volatile  long  value  ;</p><p>CounterCell(  long  x  ) {  value  =  x  ; }</p><p>}</p><p>final  long  sumCount  (){</p><p>CounterCell  as  [] =  counterCells  ;</p><p>long  sum  =  baseCount  ;</p><p>if  (  as  !=  null  ){</p><p>for  (  int  i  = 0;  i  &lt; as  .  length  ;  i  ++){</p><p>CounterCell  a  ;</p><p>if  ((  a  =  as  [  i  ]) !=  null  )</p><p>sum  +=  a  .  value  ;</p><p>}</p><p>}</p><p>return  sum  ;</p><p>}</p><p>private  final  void  full  AddCount  (  long  x  ,  boolean  wasUncontended<br>) {}</p><p>public  int  size() {  // 旧版本方法，和推荐的mappingCount返回的值基本无区别</p><p>long  n  = sumCount();</p><p>return  ((  n  &lt; 0L) ? 0 :</p><p>(  n  &gt; (  long  )Integer.  MAX_VALUE  ) ? Integer.  MAX_VALUE  :</p><p>(  int  )  n  );</p><p>}</p><p>// 返回Mappings中的元素个数，官方建议用来  替代size  。此方法返回的是一个估计值；如果sumCount时有线程插入或删除，实际数量是和<br>mappingCount  不同的。since 1.8</p><p>public  long  mappingCount  () {</p><p>long  n  = sumCount();</p><p>return  (  n  &lt; 0L) ? 0L :  n  ;  // ignore transient negative values</p><p>}</p><p>private  transient  volatile  long  baseCount  ;</p><p>//ConcurrentHashMap中元素个数,基于CAS无锁更新,但返回的不一定是当前Map的真实元素个数。</p><p>5、remove、clear相关：</p><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  void  clear() {  // 移除所有元素 </li><li>long  delta = 0L;  // negative number of deletions </li><li>inti =  0  ; </li><li>Node<k,v>[] tab = table; </k,v></li><li>while  (tab !=  null  &amp;&amp; i &lt; tab.length) { </li><li>intfh; </li><li>Node<k,v> f = tabAt(tab, i); </k,v></li><li>if  (f ==  null  )  // 为空，直接跳过 </li><li>++i; </li><li>else  if  ((fh = f.hash) == MOVED) {  //检测到其他线程正对其扩容 </li><li>//则协助其扩容，然后重置计数器，重新挨个删除元素，避免删除了元素，其他线程又新增元素。 </li><li>tab = helpTransfer(tab, f); </li><li>i =  0  ;  // restart </li><li>} </li><li>else  { </li><li>synchronized  (f) {  // 上锁 </li><li>if  (tabAt(tab, i) == f) {  // 其他线程没有在此期间操作f </li><li>Node<k,v> p = (fh &gt;=  0  ? f : </k,v></li><li>(finstanceof TreeBin) ? </li><li>((TreeBin<k,v>)f).first :  null  ); </k,v></li><li>while  (p !=  null  ) {  // 首先删除链、树的末尾元素，避免产生大量垃圾 </li><li>--delta; </li><li>p = p.next; </li><li>} </li><li>setTabAt(tab, i++,  null  );  // 利用CAS无锁置null </li><li>} </li><li>} </li><li>} </li><li>} </li><li>if  (delta != 0L) </li><li>addCount(delta, -  1  );  // 无实际意义，参数check&lt;=1，直接return。 </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  V remove(Object key) {  // key为null，将在计算hashCode时报空指针异常 </li><li>return  replaceNode(key,  null  ,  null  ); </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  boolean  remove(Object key, Object value) { </li><li>if  (key ==  null  ) </li><li>thrownew NullPointerException(); </li><li>returnvalue !=  null  &amp;&amp; replaceNode(key,  null  , value) !=  null  ; </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>// remove核心方法，注意，这里的cv才是key-value中的value！ </li><li>final  V replaceNode(Object key, V value, Object cv) { </li><li>inthash = spread(key.hashCode()); </li><li>for  (Node<k,v>[] tab = table;;) { </k,v></li><li>Node<k,v> f; intn, i, fh; </k,v></li><li>if  (tab ==  null  || (n = tab.length) ==  0  || </li><li>(f = tabAt(tab, i = (n -  1  ) &amp; hash)) ==  null  ) </li><li>break  ;  // 该桶位第一个元素为空，直接跳过 </li><li>elseif ((fh = f.hash) == MOVED) </li><li>tab = helpTransfer(tab, f);  // 先协助扩容再说 </li><li>else  { </li><li>V oldVal =  null  ; </li><li>booleanvalidated =  false  ; </li><li>synchronized  (f) { </li><li>if  (tabAt(tab, i) == f) { </li><li>if  (fh &gt;=  0  ) { </li><li>validated =  true  ; </li><li>//pred没看出来有什么用，全是别人赋值给他，他却不影响其他参数 </li><li>for  (Node<k,v> e = f, pred =  null  ;;) { </k,v></li><li>K ek; </li><li>if  (e.hash == hash &amp;&amp;((ek = e.key) == key || </li><li>(ek !=  null  &amp;&amp; key.equals(ek)))){  //hash且可以相等 </li><li>V ev = e.val; </li><li>// value为null或value和查到的值相等 </li><li>if  (cv ==  null  || cv == ev || </li><li>(ev !=  null  &amp;&amp; cv.equals(ev))) { </li><li>oldVal = ev; </li><li>if  (value !=  null  )  // replace中调用 </li><li>e.val = value; </li><li>elseif (pred !=  null  ) </li><li>pred.next = e.next; </li><li>else </li><li>setTabAt(tab, i, e.next); </li><li>} </li><li>break  ; </li><li>} </li><li>pred = e; </li><li>if  ((e = e.next) ==  null  ) </li><li>break  ; </li><li>} </li><li>} </li><li>elseif (finstanceof TreeBin) {  // 以树的方式find、remove </li><li>validated =  true  ; </li><li>TreeBin<k,v> t = (TreeBin<k,v>)f; </k,v></k,v></li><li>TreeNode<k,v> r, p; </k,v></li><li>if  ((r = t.root) !=  null  &amp;&amp;</li><li>(p = r.findTreeNode(hash, key,  null  )) !=  null  ) { </li><li>V pv = p.val; </li><li>if  (cv ==  null  || cv == pv || </li><li>(pv !=  null  &amp;&amp; cv.equals(pv))) { </li><li>oldVal = pv; </li><li>if  (value !=  null  ) </li><li>p.val = value; </li><li>elseif (t.removeTreeNode(p)) </li><li>setTabAt(tab, i, untreeify(t.first)); </li><li>} </li><li>} </li><li>} </li><li>} </li><li>} </li><li>if  (validated) { </li><li>if  (oldVal !=  null  ) { </li><li>if  (value ==  null  ) </li><li>addCount(-1L, -  1  ); </li><li>returnoldVal; </li><li>} </li><li>break  ; </li><li>} </li><li>} </li><li>} </li><li>return  null  ; </li><li>} </li></ol><p><strong> [java] </strong> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> view plain </a> <a href="http://blog.csdn.net/u010887744/article/details/50637030#" target="_blank" rel="noopener"> copy </a></p><p><a href="https://code.csdn.net/snippets/1574859" target="_blank" rel="noopener"> <img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片"></a> <a href="https://code.csdn.net/snippets/1574859/fork" target="_blank" rel="noopener"><br><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片"></a></p><ol><li>public  boolean  replace(K key, V oldValue, V newValue) {} </li></ol><p>6、其他函数：</p><p>public  boolean  isEmpty  () {</p><p>return  sumCount() &lt;= 0L;  // ignore transient negative values</p><p>}</p><p>参考资料:</p><p><a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener"> http://ifeve.com/concurrenthashmap/  </a></p><p><a href="http://ifeve.com/java-concurrent-hashmap-2/" target="_blank" rel="noopener"> http://ifeve.com/java-concurrent-hashmap-2/ </a></p><p>、、、、、、、、、</p><p><a href="http://ashkrit.blogspot.com/2014/12/what-is-new-in-java8-concurrenthashmap.html" target="_blank" rel="noopener"> http://ashkrit.blogspot.com/2014/12/what-is-new-in-<br>java8-concurrenthashmap.html  </a></p><p><a href="http://blog.csdn.net/u010723709/article/details/48007881" target="_blank" rel="noopener"> http://blog.csdn.net/u010723709/article/details/48007881</a></p><p><a href="http://yucchi.jp/blog/?p=2048" target="_blank" rel="noopener"> http://yucchi.jp/blog/?p=2048  </a></p><p><a href="http://blog.csdn.net/q291611265/article/details/47985145" target="_blank" rel="noopener"> http://blog.csdn.net/q291611265/article/details/47985145</a></p><p>、、、、、、、、、、</p><p>SynchronizedMap： <a href="http://blog.sina.com.cn/s/blog_5157093c0100hm3y.html" target="_blank" rel="noopener"> http://blog.sina.com.cn/s/blog_5157093c0100hm3y.html</a></p><p><a href="http://blog.csdn.net/yangfanend/article/details/7165742" target="_blank" rel="noopener"> http://blog.csdn.net/yangfanend/article/details/7165742</a></p><p><a href="http://blog.csdn.net/xuefeng0707/article/details/40797085" target="_blank" rel="noopener"> http://blog.csdn.net/xuefeng0707/article/details/40797085</a></p><pre><code>&lt;a target=_blank id=&quot;L1&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L1&quot; rel=&quot;#L1&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  1&lt;/a&gt;&lt;a target=_blank id=&quot;L2&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L2&quot; rel=&quot;#L2&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  2&lt;/a&gt;&lt;a target=_blank id=&quot;L3&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L3&quot; rel=&quot;#L3&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  3&lt;/a&gt;&lt;a target=_blank id=&quot;L4&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L4&quot; rel=&quot;#L4&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  4&lt;/a&gt;&lt;a target=_blank id=&quot;L5&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L5&quot; rel=&quot;#L5&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  5&lt;/a&gt;&lt;a target=_blank id=&quot;L6&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L6&quot; rel=&quot;#L6&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  6&lt;/a&gt;&lt;a target=_blank id=&quot;L7&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L7&quot; rel=&quot;#L7&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  7&lt;/a&gt;&lt;a target=_blank id=&quot;L8&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L8&quot; rel=&quot;#L8&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  8&lt;/a&gt;&lt;a target=_blank id=&quot;L9&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L9&quot; rel=&quot;#L9&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  9&lt;/a&gt;&lt;a target=_blank id=&quot;L10&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L10&quot; rel=&quot;#L10&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt; 10&lt;/a&gt;&lt;a target=_blank id=&quot;L11&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L11&quot; rel=&quot;#L11&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt; 11&lt;/a&gt;ArrayList源码分析（jdk1.8）：http://blog.csdn.net/u010887744/article/details/49496093HashMap源码分析（jdk1.8）：http://write.blog.csdn.net/postedit/50346257ConcurrentHashMap源码分析--Java8：http://blog.csdn.net/u010887744/article/details/50637030每篇文章都包含 有道云笔记地址，可直接保存。在线查阅JDK源码：JDK8：https://github.com/zxiaofan/JDK1.8-SrcJDK7：https://github.com/zxiaofan/JDK_Src_1.7史上最全Java集合关系图：http://blog.csdn.net/u010887744/article/details/50575735</code></pre><h5 id="来自CODE的代码片"><a href="#来自CODE的代码片" class="headerlink" title=" 来自CODE的代码片 "></a><a href="https://code.csdn.net/snippets/1574871" target="_blank" rel="noopener"> 来自CODE的代码片 </a></h5><p>SourceCode</p><pre><code>&lt;a target=_blank id=&quot;L1&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L1&quot; rel=&quot;#L1&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  1&lt;/a&gt;&lt;a target=_blank id=&quot;L2&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L2&quot; rel=&quot;#L2&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  2&lt;/a&gt;&lt;a target=_blank id=&quot;L3&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L3&quot; rel=&quot;#L3&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  3&lt;/a&gt;&lt;a target=_blank id=&quot;L4&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L4&quot; rel=&quot;#L4&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  4&lt;/a&gt;&lt;a target=_blank id=&quot;L5&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L5&quot; rel=&quot;#L5&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  5&lt;/a&gt;&lt;a target=_blank id=&quot;L6&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L6&quot; rel=&quot;#L6&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  6&lt;/a&gt;&lt;a target=_blank id=&quot;L7&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L7&quot; rel=&quot;#L7&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  7&lt;/a&gt;&lt;a target=_blank id=&quot;L8&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L8&quot; rel=&quot;#L8&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  8&lt;/a&gt;&lt;a target=_blank id=&quot;L9&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L9&quot; rel=&quot;#L9&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt;  9&lt;/a&gt;&lt;a target=_blank id=&quot;L10&quot; href=&quot;http://blog.csdn.net/u010887744/article/details/50637030#L10&quot; rel=&quot;#L10&quot; style=&quot;color: rgb(102, 102, 102); text-decoration: none;&quot;&gt; 10&lt;/a&gt;转载请注明出处，谢谢。【 CSDN 】：csdn.zxiaofan.cn【GitHub】：github.zxiaofan.cn域名备案中，上述网址极不稳定，GitHub请直接访问【github.com/zxiaofan】如有任何问题，欢迎留言。祝君好运！Life is all about choices！ 将来的你一定会感激现在拼命的自己！</code></pre><h5 id="来自CODE的代码片-1"><a href="#来自CODE的代码片-1" class="headerlink" title=" 来自CODE的代码片 "></a><a href="https://code.csdn.net/snippets/637064" target="_blank" rel="noopener"> 来自CODE的代码片 </a></h5><p>txt</p>]]></content>
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：集合框架</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9A%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <content type="html"><![CDATA[<p>Java集合源码位于Java.util包下，主要包括List、Set、Map、Iterator以及工具类Arrays和Collections。Java集合框<br>架的顶级接口包括Collection和Map两个，其中Collection的子接口包括List、Set和Queue。具体结构如下：<br><img src="http://img.blog.csdn.net/20160218204126299" alt="Java集合框架"></p><h2 id="1-Collection接口"><a href="#1-Collection接口" class="headerlink" title="1 Collection接口"></a>1 Collection接口</h2><p>Collection是集合的顶级接口之一，他继承了Iterable接口，并声明了集合中一些常用的方法，例如size()，contains(Object<br>o)等方法。Java SDK提供了继承与Collection的子接口List、Set或者Queue，并通过实现子接口实现了具体集合类。所有实现Collect<br>ion接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个<br>Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后<br>一个构造函数允许用户复制一个Collection。<br><!--阅读全文--></p><h3 id="1-1-List接口"><a href="#1-1-List接口" class="headerlink" title="1.1 List接口"></a>1.1 List接口</h3><p>List接口继承与Collection接口，它是一个允许有重复元素的的列表，能够控制元素的插入位置，通过索引来访问List中的元素。常见的List的实现有L<br>inkedList，ArrayList，Vector和Stack。</p><h3 id="1-2-Set接口"><a href="#1-2-Set接口" class="headerlink" title="1.2 Set接口"></a>1.2 Set接口</h3><p>Set接口同样继承与Collection接口，它不允许有重复的元素。常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap<br>实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合。</p><h3 id="1-3-Queue接口"><a href="#1-3-Queue接口" class="headerlink" title="1.3 Queue接口"></a>1.3 Queue接口</h3><p>Queue接口继承与Collection接口，提供一种先进先出的机制，常见的实现类有ArrayBlockingQueue、ConcurrentLinkedQ<br>ueue等，这些实现类都处于concurrent包下，用于线程同步机制的实现。</p><h2 id="2-Map接口"><a href="#2-Map接口" class="headerlink" title="2 Map接口"></a>2 Map接口</h2><p>Map接口是和Collection接口并行的顶级集合接口，他提供key-<br>value映射机制。Map接口常见的实现类有HashTable、Hashmap以及Weakhashmap等。</p><p>参考：<br>[1] <a href="http://blog.csdn.net/softwave/article/details/4166598" target="_blank" rel="noopener"> http://blog.csdn.net/softwave/article/details/4166598</a><br>[2] <a href="http://blog.csdn.net/mazhimazh/article/details/17730517" target="_blank" rel="noopener"> http://blog.csdn.net/mazhimazh/article/details/17730517</a><br>[3] <a href="http://blog.csdn.net/ns_code/article/details/35564663" target="_blank" rel="noopener"> http://blog.csdn.net/ns_code/article/details/35564663</a></p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：LinkedList使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9ALinkedList%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>LinkedList基于双端链表实现，可以作为栈、队列或者双端队列使用。</p><pre><code>public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><p>LinkedList继承了AbstractSequentialList，实现了get等方法；<br>LinkedList实现了Deque接口，可以作为双端队列使用；<br>LinkedList实现Cloneable接口重写了接口定义的clone()方法，可以使用clone()复制链表。<br>LinkedList实现 java.io.Serializable接口使LinkedList支持序列化。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>LinkedList提供了增加，弹出，获取元素等操作，具体提供的方法如下：</p><pre><code>boolean       add(E object)  //在末尾增加一个元素void          add(int location, E object) //在指定位置增加元素boolean       addAll(Collection&lt;? extends E&gt; collection) //在末尾加入一组元素boolean       addAll(int location, Collection&lt;? extends E&gt; collection) //从指定位置开始加一组元素void          addFirst(E object) //在表头增加一个元素void          addLast(E object) //在表尾增加一个元素void          clear() //清空链表Object        clone() //复制一个元素boolean       contains(Object object) //判断是否包含objectIterator&lt;E&gt;   descendingIterator() //逆序迭代器E             element() //获取链表第一个元素,不存在会抛出异常E             get(int location) //获取location位置的元素,不存在会抛出异常E             getFirst() //获取链表第一个元素,不存在会抛出异常E             getLast() //获取链表最后一个元素,不存在会抛出异常int           indexOf(Object object) //获取object第一次出现的位置int           lastIndexOf(Object object) //获取object最后一次出现的位置ListIterator&lt;E&gt;     listIterator(int location) //从location开始的迭代器boolean       offer(E o) //在末尾增加一个元素boolean       offerFirst(E e) //在表头增加一个元素boolean       offerLast(E e) //在表尾增加一个元素E             peek() //获取表头元素,不存在不会抛出异常E             peekFirst() //获取表头元素,不存在不会抛出异常E             peekLast() //获取表尾元素,不存在不会抛出异常E             poll() //弹出表头元素E             pollFirst() //弹出表头元素E             pollLast() //弹出表尾元素E             pop() //弹出表头元素,不存在会抛异常void          push(E e) //在表头增加一个元素E             remove() //删除最后一个元素E             remove(int location) //删除location位置的元素boolean       remove(Object object) //删除第一个出现的objectE             removeFirst() //删除第一个元素boolean       removeFirstOccurrence(Object o) //删除第一个出现的oE             removeLast() //删除最后一个元素boolean       removeLastOccurrence(Object o) //删除最后一个出现的oE             set(int location, E object) //将location位置设置为objectint           size() //链表大小&lt;T&gt; T[]       toArray(T[] contents) //转换为T类型的数组Object[]     toArray() //转换为Object类型的数组</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public class TestLinkedList {    public void testLinkedList() throws Exception {        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;String&gt;();        linkedList.add(&quot;a&quot;); //在表尾增加元素        linkedList.add(&quot;b&quot;);        printLinkedList(linkedList);        linkedList.addFirst(&quot;pre-a&quot;); //在表头增加元素        System.out.println(&quot;链表中包含 &apos;a&apos; 元素:&quot; + linkedList.contains(&quot;a&quot;)); //包含元素判断        System.out.println(&quot;链表的第一个元素: &quot; + linkedList.peek());        System.out.println(&quot;链表的最后一个元素: &quot; + linkedList.peekLast());        printLinkedList(linkedList);        System.out.println(&quot;获取删除链表的第一个元素: &quot; + linkedList.poll());        printLinkedList(linkedList);        System.out.println(&quot;获取并弹出链表的最后一个元素&quot; + linkedList.pollLast());        printLinkedList(linkedList);        linkedList.offer(&quot;d&quot;);        linkedList.offer(&quot;e&quot;);        linkedList.offer(&quot;f&quot;);        printLinkedList(linkedList);        System.out.println(&quot;第三个元素为: &quot; + linkedList.get(2)); //获取第三个元素        System.out.println(&quot;将第四个元素设置为g: &quot; + linkedList.set(3, &quot;g&quot;));        printLinkedList(linkedList);        //转换成数组        String[] arr = (String[]) linkedList.toArray(new String[0]);        for (String e: arr) {            System.out.print(e + &quot; &quot;);        }    }    protected void printLinkedList(LinkedList&lt;String&gt; linkedList) {        Iterator&lt;String&gt; iterator = linkedList.iterator();        System.out.print(&quot;linkList包含的元素有: &quot;);        while (iterator.hasNext()) {            System.out.print(iterator.next() + &quot; &quot;);        }        System.out.println(&quot;\n&quot;);    }}</code></pre><p>运行结果如下：</p><pre><code>linkList包含的元素有: a b链表中包含 &apos;a&apos; 元素:true链表的第一个元素: pre-a链表的最后一个元素: blinkList包含的元素有: pre-a a b获取删除链表的第一个元素: pre-alinkList包含的元素有: a b获取并弹出链表的最后一个元素blinkList包含的元素有: alinkList包含的元素有: a d e f第三个元素为: e将第四个元素设置为g: flinkList包含的元素有: a d e ga d e g </code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1-add方法"><a href="#2-1-add方法" class="headerlink" title="2.1 add方法"></a>2.1 add方法</h3><pre><code>public boolean add(E e) { //在末尾增加一个元素    linkLast(e);    return true;}void linkLast(E e) {    final Node&lt;E&gt; l = last; //末尾元素    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //申请一个值为e的元素,前一个元素为l,后一个为null    last = newNode; //新元素为最后一个元素    if (l == null) //空链表        first = newNode;    else        l.next = newNode;    size++; //链表长度增加    modCount++;}</code></pre><h3 id="2-2-addFirst方法"><a href="#2-2-addFirst方法" class="headerlink" title="2.2 addFirst方法"></a>2.2 addFirst方法</h3><pre><code>public void addFirst(E e) { //在表头增加元素    linkFirst(e);}private void linkFirst(E e) {    final Node&lt;E&gt; f = first; //表头元素    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //申请一个值为e的元素,前一个元素为null,后一个元素为f    first = newNode; //新元素为表头元素    if (f == null) //空链表        last = newNode;    else        f.prev = newNode;    size++; //长度增加    modCount++;}</code></pre><h3 id="2-3-peek方法"><a href="#2-3-peek方法" class="headerlink" title="2.3 peek方法"></a>2.3 peek方法</h3><pre><code>public E peek() {        final Node&lt;E&gt; f = first; //获取表头元素        return (f == null) ? null : f.item; //返回null或者表头元素的值}</code></pre><h3 id="2-4-poll方法"><a href="#2-4-poll方法" class="headerlink" title="2.4 poll方法"></a>2.4 poll方法</h3><pre><code>public E poll() {    final Node&lt;E&gt; f = first;    return (f == null) ? null : unlinkFirst(f);}private E unlinkFirst(Node&lt;E&gt; f) {    // assert f == first &amp;&amp; f != null;    final E element = f.item; //获取第一个元素的值    final Node&lt;E&gt; next = f.next; //获取第二个元素    f.item = null; //将第一个元素置为null    f.next = null; // help GC,    first = next; //将原有的第二个元素设为头元素    if (next == null) //原链表只有一个元素,此时链表为空        last = null;    else        next.prev = null; //头元素的前置元素为null    size--;    modCount++;    return element;}</code></pre><h3 id="2-5-toArray-T-contents-方法"><a href="#2-5-toArray-T-contents-方法" class="headerlink" title="2.5 toArray(T[] contents) 方法"></a>2.5 toArray(T[] contents) 方法</h3><pre><code>public &lt;T&gt; T[] toArray(T[] a) {    if (a.length &lt; size) //a长度小于链表长度,则重新申请一个长度为size的数组        a = (T[])java.lang.reflect.Array.newInstance(                a.getClass().getComponentType(), size);    int i = 0;    Object[] result = a;    for (Node&lt;E&gt; x = first; x != null; x = x.next) //为数组赋值        result[i++] = x.item;    if (a.length &gt; size) //如果长度大于链表长度,最后一个元素后一个设为null,表示数组结束        a[size] = null;    return a;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://blog.csdn.net/crave_shy/article/details/17440835" target="_blank" rel="noopener"> http://blog.csdn.net/crave_shy/article/details/17440835</a><br>[2] <a href="http://blog.csdn.net/wanghao109/article/details/13287877" target="_blank" rel="noopener"> http://blog.csdn.net/wanghao109/article/details/13287877</a><br>[3] <a href="http://fjohnny.iteye.com/blog/696750" target="_blank" rel="noopener"> http://fjohnny.iteye.com/blog/696750</a></p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合：Vector使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9AVector%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>Vector和ArrayList类似，是数组队列，可以实现容量的动态增长。Vector类继承了AbstractList抽象类并且实现了List、Random<br>Access，Cloneable以及java.io.Serializable接口。<br>public class ArrayList extends AbstractList implements List, RandomAccess,<br>Cloneable, java.io.Serializable<br>AbstractList类继承了AbstractCollection类并实现了List接口。<br>实现RandomAccess接口使Vector拥有随机访问的能力，即通过下表索引访问数组元素。<br>实现Cloneable接口重写了接口定义的clone()方法，Vector可以使用clone()复制数组。<br>实现 java.io.Serializable接口使Vector支持序列化。<br><strong> Vector和ArrayList的最大不同是Vector是线程安全的而ArrayList不是。Vector几乎所有的方法都使用synchronized关键字是来保证线程安全使它的性能比不上ArrayList。 </strong><br><strong> Vector和ArrayList不同还体现在动态增长的策略上。ArrayList的基本增长策略是oldCapacity<em>1.5+1，如果还不够则容量为实际需要容量；Vector的基本增长策略是oldCapacity+设定好的增长幅度，如果没设定则新容量增长为oldCapacity</em>2，如果还不够则为实际需要的容量。 </strong><br>现在很少使用Vector。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>ArrayList提供了增加、删除、判空等操作，具体提供的方法如下：</p><pre><code>synchronized boolean        add(E object) //增加元素void                        add(int location, E object) //指定位置增加元素synchronized boolean        addAll(Collection&lt;? extends E&gt; collection) //将集合中的元素加入到数组的最后synchronized boolean        addAll(int location, Collection&lt;? extends E&gt; collection) //指定位置增加一盒中所有元素synchronized void           addElement(E object) //增加元素synchronized int            capacity() //数组容量void                        clear() //清空数组synchronized Object         clone() //复制元素boolean                     contains(Object object) //判断是否包含元素synchronized boolean        containsAll(Collection&lt;?&gt; collection) //判断是否包含集合中所有元素synchronized void           copyInto(Object[] elements) //将数组中的元素复制到element中synchronized E              elementAt(int location) //获取location位置的元素Enumeration&lt;E&gt;              elements() //返回一个包含数组元素的枚举synchronized void           ensureCapacity(int minimumCapacity) //增加数组空间synchronized boolean        equals(Object object) //比较元素synchronized E              firstElement() //获取第一个元素E                           get(int location) //获取location下标的元素synchronized int            hashCode() //获取对象的hashCodesynchronized int            indexOf(Object object, int location) //从location开始第一次出现object的位置int                         indexOf(Object object) //第一次出现object的位置synchronized void           insertElementAt(E object, int location) //在location位置插入objectsynchronized boolean        isEmpty() //判空synchronized E              lastElement() //获取最后元素synchronized int            lastIndexOf(Object object, int location) //location之前最后出现object的位置synchronized int            lastIndexOf(Object object) //最后一次出现object的位置synchronized E              remove(int location) //删除location位置的元素boolean                     remove(Object object) //删除第一次出现的objectsynchronized boolean        removeAll(Collection&lt;?&gt; collection) //删除collection出现的所有元素synchronized void           removeAllElements() //将所有元素置为nullsynchronized boolean        removeElement(Object object) //同removesynchronized void           removeElementAt(int location) //同removesynchronized boolean        retainAll(Collection&lt;?&gt; collection) //删除除了collection中元素之外的所有元素synchronized E              set(int location, E object) //设置location位置的元素为objectsynchronized void           setElementAt(E object, int location) //同setsynchronized void           setSize(int length) //设置数组大小,若length大于实际长度则空余元素置为nullsynchronized int            size() //获取实际大小synchronized List&lt;E&gt;        subList(int start, int end) //获取子串synchronized &lt;T&gt; T[]        toArray(T[] contents) //转换成数组synchronized Object[]       toArray() //synchronized void           trimToSize() //将数组容量改为实际数组大小</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public class TestVector {    public void testVector() {        Vector vector = new Vector&lt;&gt;(10); //申请一个初始容量大小为10的Vector        for (int i = 0; i &lt; 5; i++) { //初始化元素为            vector.add(i);        }        System.out.println(&quot;此时数组实际大小为: &quot; + vector.size());        printVector(&quot;Vector此时元素有&quot;, vector);        vector.set(4,44); //设置第5个元素为44        vector.add(2,22); //在第3个元素位置增加22        printVector(&quot;Vector此时元素有&quot;, vector);        vector.add(2);        System.out.println(&quot;第1次出现2的位置为: &quot; + vector.indexOf(2));        vector.remove(2); //删除第3个元素        vector.remove((Object)44); //删除第一次出现的44        printVector(&quot;Vector此时元素有&quot;, vector);        int size = vector.size();        for (int i = size; i &lt; size + 6; i++) {            vector.add(i);        }        printVector(&quot;Vector此时元素有&quot;, vector);        System.out.println(&quot;Vector此时大小为: &quot; +  vector.size());        System.out.println(&quot;Vector此时的容量为: &quot; + vector.capacity()); //原有容量为10, 超出容量后新容量为2倍        //转为数组        Integer [] arr = (Integer[]) vector.toArray(new Integer[0]);        System.out.print(&quot;遍历数组结果: &quot;);        for (Integer i:arr) {            System.out.print(i + &quot; &quot;);        }    }    /**     * 打印Vector     * @param vector     */    protected void printVector(String comment, List vector) {        System.out.print(comment + &quot;: &quot;);        for (int i = 0; i &lt; vector.size(); i++) {            System.out.print(vector.get(i) + &quot; &quot;);        }        System.out.println(&quot;&quot;);    }}</code></pre><p>运行结果如下：</p><pre><code>此时数组实际大小为: 5Vector此时元素有: 0 1 2 3 4Vector此时元素有: 0 1 22 2 3 44第1次出现2的位置为: 3Vector此时元素有: 0 1 2 3 2Vector此时元素有: 0 1 2 3 2 5 6 7 8 9 10Vector此时大小为: 11Vector此时的容量为: 20遍历数组结果: 0 1 2 3 2 5 6 7 8 9 10</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><pre><code>/** * 构造一个初始容量为initialCapacity,动态增长为capacityIncrement的Vector * @param initialCapacity * @param capacityIncrement */public Vector(int initialCapacity, int capacityIncrement) {    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;}/** * 初始容量为initialCapacity,动态增长容量为0 * @param initialCapacity */public Vector(int initialCapacity) {    this(initialCapacity, 0);}/** * 初始容量为10,动态增长为0 */public Vector() {    this(10);}/** * 申请一个Vector,并用c初始化 * @param c */public Vector(Collection&lt;? extends E&gt; c) {    elementData = c.toArray();    elementCount = elementData.length;    // c.toArray might (incorrectly) not return Object[] (see 6260652)    if (elementData.getClass() != Object[].class) //bug 6260652,toArray可能不会返回Object数组,这是重新复制        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);}</code></pre><h3 id="2-2-add方法"><a href="#2-2-add方法" class="headerlink" title="2.2 add方法"></a>2.2 add方法</h3><pre><code>/** * 添加e到Vector末尾 * @param e * @return */public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1); //增加容量    elementData[elementCount++] = e;    return true;}/** * 在index位置插入element * @param index * @param element */public void add(int index, E element) {    insertElementAt(element, index);}/** * 在index位置插入obj * @param obj * @param index */public synchronized void insertElementAt(E obj, int index) {    modCount++;    if (index &gt; elementCount) {        throw new ArrayIndexOutOfBoundsException(index                + &quot; &gt; &quot; + elementCount);    }    ensureCapacityHelper(elementCount + 1);     //将elementData元素从index开始，复制到elementData的index+1开始，总共          elementCount - index长度，即后移1位    System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);    elementData[index] = obj;    elementCount++;}</code></pre><h3 id="2-3-set方法"><a href="#2-3-set方法" class="headerlink" title="2.3 set方法"></a>2.3 set方法</h3><pre><code>/** * 将index位置的元素置为element * @param index * @param element * @return */public synchronized E set(int index, E element) {    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index);    elementData[index] = element;    return oldValue;}</code></pre><h3 id="2-4-remove方法"><a href="#2-4-remove方法" class="headerlink" title="2.4 remove方法"></a>2.4 remove方法</h3><pre><code>/** * 删除index位置的元素 * @param index * @return */public synchronized E remove(int index) {    modCount++;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index); //获取元素    int numMoved = elementCount - index - 1;    if (numMoved &gt; 0) //不是删除最后一个元素,则所有元素前移1位        System.arraycopy(elementData, index+1, elementData, index,                numMoved);    elementData[--elementCount] = null; // Let gc do its work    return oldValue;}</code></pre><h3 id="2-5-toArray方法"><a href="#2-5-toArray方法" class="headerlink" title="2.5 toArray方法"></a>2.5 toArray方法</h3><pre><code>/** * 返回T类型的数组,参数不能是基本类型 * @param a * @param &lt;T&gt; * @return */public synchronized &lt;T&gt; T[] toArray(T[] a) {    if (a.length &lt; elementCount) //a长度小于Vector已有的元素个数,重新申请一个数组        return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());    System.arraycopy(elementData, 0, a, 0, elementCount); //将元素复制到a中    if (a.length &gt; elementCount)        a[elementCount] = null;    return a;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/3308833.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/3308833.html</a><br>[2] <a href="http://blog.csdn.net/ns_code/article/details/35793865" target="_blank" rel="noopener"> http://blog.csdn.net/ns_code/article/details/35793865</a><br>[3] <a href="http://blog.csdn.net/mazhimazh/article/details/19568867" target="_blank" rel="noopener"> http://blog.csdn.net/mazhimazh/article/details/19568867</a></p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode:Increasing_Triplet_Subsequence</title>
      <link href="/2017/11/11/LeetCode:Increasing_Triplet_Subsequence/"/>
      <content type="html"><![CDATA[<p>Given an unsorted array return whether an increasing subsequence of length 3<br>exists or not in the array.</p><p>Formally the function should:</p><p>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return<br>false.</p><p>Your algorithm should run in O(n) time complexity and O(1) space complexity.</p><p>Examples:<br>Given [1, 2, 3, 4, 5],<br>return true.</p><p>Given [5, 4, 3, 2, 1],<br>return false.</p><p>题干的意思是给定未排序数组，从中找到三个满足arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤<br>n-1递增数字时返回true，找不到返回false。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>设定两个数字min和middle，min保存已发现的最小值，middle保存仅比min大的第二小值。</p><pre><code>if num &lt;= min 则 min = numelse if num &lt;= middle 则 middle = numelse 则return true；原因是 此时的num 肯定比min,middle都大，有min &lt; middle &lt; num</code></pre><p>源码如下：</p><pre><code>/** * Increasing Triplet Subsequence * @param nums * @return */public boolean increasingTriplet(int[] nums) {    int min = Integer.MAX_VALUE;    int middle = Integer.MAX_VALUE;    for (int num : nums) {        if (num &lt;= min) {            min = num;        } else if (num &lt;= middle) {            middle = num;        } else {            return true;        }    }    return false;}</code></pre>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode:Fraction_to_Recurring_Decimal</title>
      <link href="/2017/11/11/LeetCode:Fraction_to_Recurring_Decimal/"/>
      <content type="html"><![CDATA[<h2 id="1、题干"><a href="#1、题干" class="headerlink" title="1、题干"></a>1、题干</h2><p>Given two integers representing the numerator and denominator of a fraction,<br>return the fraction in string format.</p><p>If the fractional part is repeating, enclose the repeating part in<br>parentheses.</p><p>For example,</p><ul><li>Given numerator = 1, denominator = 2, return “0.5”. </li><li>Given numerator = 2, denominator = 1, return “2”. </li><li>Given numerator = 2, denominator = 3, return “0.(6)”. </li></ul><p>题干的意思是，给两个整数numerator，denominator，分别作为分子和分母，现在需要计算他的小数形式，并返回String类型，如果是循环小数，将<br>循环部分用小括号包起来。</p><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>本题的难点在小数部分计算，具体思路如下：<br>1）设两个变量分别存放每次计算完成的余数（remainder）和商（integer）,并将余数加入到一个数组中。<br>2）每次计算后先到数组中查是否有相同的余数，如果有则说明出现循环小数。<br>3）计算循环小数循环的位数，循环的位数是余数数组的长度减去重复余数上一次（也只会出现一次）出现的下标。</p><h2 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h2><p>1）负数情况<br>2）Math.abs()处理Integer.MIN_VALUE返回的还是负值，整形衣橱</p><h2 id="4、源码及注释"><a href="#4、源码及注释" class="headerlink" title="4、源码及注释"></a>4、源码及注释</h2><pre><code>/** * Fraction to Recurring Decimal * @param numerator * @param denominator * @return */public String fractionToDecimal(int numerator, int denominator) {    if (numerator == 0) { //分子为0        return &quot;0&quot;;    }    if (denominator == 0) { //分母为0,返回空        return &quot;&quot;;    }    String result = &quot;&quot;; //存放最终结果    if (numerator &lt; 0 ^ denominator &lt; 0) { //有一个是负数        result += &quot;-&quot;;    }    long first = Math.abs(Long.valueOf(numerator)); //分子    long second = Math.abs(Long.valueOf(denominator)); //分母    long integer = first / second; //整数部分    long remainder = first % second; //余数    if (remainder == 0) { //能够整除        result += String.valueOf(integer);        return result;    } else { //有小数        result = result + String.valueOf(integer) + &quot;.&quot;;    }    List list = new ArrayList&lt;&gt;(); //存放余数, 下表即是余数出现的位置    list.add(remainder);    while (remainder != 0) {        integer = remainder * 10 / second; //小数部分的结果        remainder = remainder * 10 % second; //余数        if (list.contains(remainder)) { //余数存在则说明出现了循环小数            result += String.valueOf(integer);            int position = list.size() - list.indexOf(remainder); //&quot;(&quot;需要添加的位置,从后向前数            int length = result.length(); //字符串长度            String repeatNum = &quot;(&quot; + result.substring(length - position, length) + &quot;)&quot;;            String notRepeatNum = result.substring(0,length - position);            result = notRepeatNum.concat(repeatNum);            return result;        }        result += String.valueOf(integer); //正常计算        list.add(remainder); //余数存入map    }    return result;}</code></pre>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL中的两种临时表</title>
      <link href="/2017/11/11/MySQL%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%B4%E6%97%B6%E8%A1%A8/"/>
      <content type="html"><![CDATA[<p>转自： <a href="http://mysql.taobao.org/monthly/2016/06/07/" target="_blank" rel="noopener"> http://mysql.taobao.org/monthly/2016/06/07/</a></p><h2 id="外部临时表"><a href="#外部临时表" class="headerlink" title="外部临时表"></a>外部临时表</h2><p><strong> 通过CREATE TEMPORARY TABLE </strong><br>创建的临时表，这种临时表称为外部临时表。这种临时表只对当前用户可见，当前会话结束的时候，该临时表会自动关闭。这种临时表的命名与非临时表可以同名（同名后非临时<br>表将对当前会话不可见，直到临时表被删除）。</p><h2 id="内部临时表"><a href="#内部临时表" class="headerlink" title="内部临时表"></a>内部临时表</h2><p>内部临时表是一种特殊轻量级的临时表，用来进行性能优化。这种临时表会被MySQL自动创建并用来存储某些操作的中间结果。这些操作可能包括在优化阶段或者执行阶段。<br>这种内部表对用户来说是不可见的，但是通过EXPLAIN或者SHOW<br>STATUS可以查看MYSQL是否使用了内部临时表用来帮助完成某个操作。内部临时表在SQL语句的优化过程中扮演着非常重要的角色， MySQL中的很多操作都要<br>依赖于内部临时表来进行优化。但是使用内部临时表需要创建表以及中间数据的存取代价，所以用户在写SQL语句的时候应该尽量的去避免使用临时表。</p><p>内部临时表有两种类型：一种是 <strong> HEAP临时表 </strong> ，这种临时表的所有数据都会存在内存中，对于这种表的操作不需要IO操作。另一种是 <strong><br>OnDisk临时表 </strong> ，顾名思义，这种临时表会将数据存储在磁盘上。OnDisk临时表用来处理 <strong> 中间结果比较大的操作 </strong> 。如果HEAP临时表存储<br>的数据大于MAX_HEAP_TABLE_SIZE（详情请参考MySQL手册中系统变量部分），HEAP临时表将会被自动转换成OnDisk临时表。OnDisk临<br>时表在5.7中可以通过INTERNAL_TMP_DISK_STORAGE_ENGINE系统变量选择使用MyISAM引擎或者InnoDB引擎。</p><p>本篇文章主要介绍哪些操作可能会利用到内部临时表。如果用户在书写SQL语句的时候能够尽量少的使用内部临时表进行查询优化，将有效的提高查询执行的效率。</p><p>首先我们定义一个表t1，</p><pre><code>CREATE TABLE t1( a int, b int); INSERT INTO t1 VALUES(1,2),(3,4);</code></pre><p>下面所有的操作都是基于表t1进行举例的。</p><p>在SQL语句中使用SQL_BUFFER_RESULT hint<br>SQL_BUFFER_RESULT主要用来让MySQL尽早的释放表上的锁。因为如果数据量很大的话，需要较长时间将数据发送到客户端，通过将数据缓冲到临时表中可<br>以有效的减少读锁对表的占用时间。<br>例如：</p><pre><code>mysql&gt; explain format=json select SQL_BUFFER_RESULT * from t1;EXPLAIN{  &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;2.00&quot;    },    &quot;buffer_result&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;table&quot;: {        &quot;table_name&quot;: &quot;t1&quot;,        &quot;access_type&quot;: &quot;ALL&quot;,    ...</code></pre><p>如果SQL语句中包含了DERIVED_TABLE。<br>在5.7中，由于采用了新的优化方式，我们需要使用 set optimizer_switch=’derived_merge=off’来禁止derived<br>table合并到外层的Query中。<br>例如：</p><pre><code>mysql&gt; explain format=json select * from (select * from t1) as tt;EXPLAIN{  &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;2.40&quot;    },    &quot;table&quot;: {      &quot;table_name&quot;: &quot;tt&quot;,      &quot;access_type&quot;: &quot;ALL&quot;,      ...      &quot;materialized_from_subquery&quot;: {        &quot;using_temporary_table&quot;: true,    ...</code></pre><p>如果我们查询系统表的话，系统表的数据将被存储到内部临时表中。<br>我们当前不能使用EXPLAIN来查看是否读取系统表数据需要利用到内部临时表，但是可以通过SHOW STATUS来查看是否利用到了内部临时表。<br>例如：</p><pre><code>mysql&gt; select * from information_schema.character_sets;mysql&gt; show status like &apos;CREATE%&apos;;</code></pre><p>如果DISTINCT语句没有被优化掉，即DISTINCT语句被优化转换为GROUP BY操作或者利用UNIQUE INDEX消除DISTINCT,<br>内部临时表将会被使用。</p><pre><code>mysql&gt; explain format=json select distinct a from t1;EXPLAIN{{  &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;1.60&quot;    },    &quot;duplicates_removal&quot;: {      &quot;using_temporary_table&quot;: true,    ...</code></pre><p>如果查询带有ORDER BY语句，并且不能被优化掉。下面几种情况会利用到内部临时表缓存中间数据，然后对中间数据进行排序。<br>1）如果连接表使用BNL（Batched Nestloop）/BKA(Batched Key Access)<br>例如：</p><p>1))BNL默认是打开的</p><pre><code>mysql&gt; explain format=json select * from t1, t1 as t2 order by t1.a;EXPLAIN{  &quot;query_block&quot;: {  &quot;select_id&quot;: 1,  &quot;cost_info&quot;: {    &quot;query_cost&quot;: &quot;22.00&quot;  },  &quot;ordering_operation&quot;: {    &quot;using_temporary_table&quot;: true,  ...</code></pre><p>2))关掉BNL后，ORDER BY将直接使用filesort。</p><pre><code>mysql&gt; set optimizer_switch=&apos;block_nested_loop=off&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; explain format=json select * from t1, t1 as t2 order by t1.a;EXPLAIN{   &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;25.00&quot;    },    &quot;ordering_operation&quot;: {      &quot;using_filesort&quot;: true,    ...</code></pre><p>2）ORDER BY的列不属于执行计划中第一个连接表的列。<br>例如：</p><pre><code>mysql&gt; explain format=json select * from t as t1, t as t2 order by t2.a;EXPLAIN{   &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;25.00&quot;    },    &quot;ordering_operation&quot;: {      &quot;using_temporary_table&quot;: true,    ...</code></pre><p>3）如果ORDER BY的表达式是个复杂表达式。</p><p>那么什么样的ORDER BY表达式，MySQL认为是复杂表达式呢？</p><p>1))如果排序表达式是SP或者UDF。<br>例如：</p><pre><code>drop function if exists func1;delimiter |create function func1(x int)returns int deterministicbegindeclare z1, z2 int;set z1 = x;set z2 = z1+2;return z2;end|delimiter ;explain format=json select * from t1 order by func1(a);{    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;2.20&quot;    },    &quot;ordering_operation&quot;: {      &quot;using_temporary_table&quot;: true,    ..</code></pre><p>2))ORDER BY的列包含聚集函数</p><p>为了简化执行计划，我们利用INDEX来优化GROUP BY语句。<br>例如：</p><pre><code>create index idx1 on t1(a);explain format=json SELECt a FROM t1 group by a order by sum(a);| {     &quot;query_block&quot;: {      &quot;select_id&quot;: 1,      &quot;cost_info&quot;: {        &quot;query_cost&quot;: &quot;1.20&quot;      },      &quot;ordering_operation&quot;: {        &quot;using_temporary_table&quot;: true,        &quot;using_filesort&quot;: true,        &quot;grouping_operation&quot;: {          &quot;using_filesort&quot;: false,      ...drop index idx1 on t1;</code></pre><p>3))ORDER BY的列中包含有SCALAR SUBQUERY,当然该SCALAR SUBQUERY没有被优化掉。<br>例如：</p><pre><code>explain format=json select (select rand() from t1 limit 1) as a from t1 order by a;     | {      &quot;query_block&quot;: {        &quot;select_id&quot;: 1,        &quot;cost_info&quot;: {          &quot;query_cost&quot;: &quot;1.20&quot;        },        &quot;ordering_operation&quot;: {          &quot;using_temporary_table&quot;: true,          &quot;using_filesort&quot;: true,            ...</code></pre><p>4) 如果查询既带有ORDER BY同时也有GROUP BY语句，但是两个语句使用的列不相同。</p><p>注意: 如果是5.7，我们需要将sql_mode设置为非only_full_group_by模式，否则会报错。</p><p>同样为了简化执行计划，我们利用INDEX来优化GROUP BY语句。<br>例如：</p><pre><code>set sql_mode=&apos;&apos;;create index idx1 on t1(b);explain format=json select t1.a from t1 group by t1.b order by 1;| {     &quot;query_block&quot;: {        &quot;select_id&quot;: 1,        &quot;cost_info&quot;: {          &quot;query_cost&quot;: &quot;1.40&quot;        },    &quot;ordering_operation&quot;: {          &quot;using_temporary_table&quot;: true,          &quot;using_filesort&quot;: true,          &quot;grouping_operation&quot;: {            &quot;using_filesort&quot;: false,    ...drop index idx1 on t1;</code></pre><p>如果查询带有GROUP BY语句，并且不能被优化掉。下面几种情况会利用到内部临时表缓存中间数据，然后对中间数据进行GROUP BY。<br>1）如果连接表使用BNL（Batched Nestloop）/BKA(Batched Key Access)。<br>例如：</p><pre><code>explain format=json select t2.a from t1, t1 as t2 group by t1.a;| {    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;8.20&quot;    },    &quot;grouping_operation&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;using_filesort&quot;: true,      &quot;cost_info&quot;: {        &quot;sort_cost&quot;: &quot;4.00&quot;    ...</code></pre><p>2) 如果GROUP BY的列不属于执行计划中的第一个连接表。<br>例如：</p><pre><code>explain format=json select t2.a from t1, t1 as t2 group by t2.a;| {    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;8.20&quot;    },    &quot;grouping_operation&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;using_filesort&quot;: true,      &quot;nested_loop&quot;: [    ...</code></pre><p>3) 如果GROUP BY语句使用的列与ORDER BY语句使用的列不同。<br>例如：</p><pre><code>set sql_mode=&apos;&apos;;explain format=json select t1.a from t1 group by t1.b order by t1.a;| {   &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;1.40&quot;    },    &quot;ordering_operation&quot;: {      &quot;using_filesort&quot;: true,      &quot;grouping_operation&quot;: {        &quot;using_temporary_table&quot;: true,        &quot;using_filesort&quot;: false,    ...</code></pre><p>4) 如果GROUP BY带有ROLLUP并且是基于多表外连接。<br>例如：</p><pre><code>explain format=json select sum(t1.a) from t1 left join t1 as t2 on true group by t1.a with rollup;| {    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;7.20&quot;    },    &quot;grouping_operation&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;using_filesort&quot;: true,      &quot;cost_info&quot;: {        &quot;sort_cost&quot;: &quot;4.00&quot;      },    ...</code></pre><p>5) 如果GROUP BY语句使用的列来自于SCALAR SUBQUERY，并且没有被优化掉。<br>例如：</p><pre><code>explain format=json select (select avg(a) from t1) as a from t1 group by a;| {    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;3.40&quot;    },    &quot;grouping_operation&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;using_filesort&quot;: true,      &quot;cost_info&quot;: {        &quot;sort_cost&quot;: &quot;2.00&quot;      },    ...</code></pre><p>IN表达式转换为semi-join进行优化<br>1) 如果semi-join执行方式为Materialization<br>例如：</p><pre><code>set optimizer_switch=&apos;firstmatch=off,duplicateweedout=off&apos;;explain format=json select * from t1 where a in (select b from t1);| {    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;5.60&quot;    },    &quot;nested_loop&quot;: [      {         &quot;rows_examined_per_scan&quot;: 1,              &quot;materialized_from_subquery&quot;: {                &quot;using_temporary_table&quot;: true,                &quot;query_block&quot;: {                  &quot;table&quot;: {                    &quot;table_name&quot;: &quot;t1&quot;,                    &quot;access_type&quot;: &quot;ALL&quot;,    ... </code></pre><p>2) 如果semi-join执行方式为Duplicate Weedout<br>例如：</p><pre><code>set optimizer_switch=&apos;firstmatch=off&apos;;explain format=json select * from t1 where a in (select b from t1); | {    &quot;query_block&quot;: {    &quot;select_id&quot;: 1,    &quot;cost_info&quot;: {      &quot;query_cost&quot;: &quot;4.80&quot;    },    &quot;duplicates_removal&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;nested_loop&quot;: [            {    ...</code></pre><p>如果查询语句带有UNION，MySQL将利用内部临时表帮助UNION操作消除重复。<br>例如：</p><pre><code>explain format=json select * from t1 union select * from t1;| {    &quot;query_block&quot;: {    &quot;union_result&quot;: {      &quot;using_temporary_table&quot;: true,      &quot;table_name&quot;: &quot;&lt;union1,2&gt;&quot;,    ...</code></pre><p>如果查询语句使用多表更新。<br>这里Explain不能看到内部临时表被利用，所以需要查看status。<br>例如：</p><pre><code>update t1, t1 as t2 set t1.a=3;show status like &apos;CREATE%&apos;;</code></pre><p>如果聚集函数中包含如下函数，内部临时表也会被利用。<br>1) count(distinct *)<br>例如：</p><pre><code>explain format=json select count(distinct a) from t1;</code></pre><p>2) group_concat<br>例如：</p><pre><code>explain format=json select group_concat(b) from t1;</code></pre><p>总之，上面列出了10种情况，MySQL将利用内部临时表进行中间结果缓存，如果数据量比较大的话，内部临时表将会把数据存储在磁盘上，这样显然会对性能有所影响。<br><strong> 为了尽可能的减少性能损失，我们需要尽量避免上述情况的出现 </strong> 。</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL事务介绍及原理</title>
      <link href="/2017/11/11/MySQL%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <content type="html"><![CDATA[<h2 id="1-为什么要事务"><a href="#1-为什么要事务" class="headerlink" title="1 为什么要事务"></a>1 为什么要事务</h2><p>事务是一组不可被分割执行的SQL语句集合，如果有必要，可以撤销。银行转账是经典的解释事务的例子。用户A给用户B转账5000元主要步骤可以概括为如下两步。<br>第一，账户A账户减去5000元；<br>第二，账户B账户增加5000元；<br>这两步要么成功，要么全不成功，否则都会导致数据不一致。这就可以用到事务来保证，如果是不同银行之间的转账还需要用到分布式事务。</p><h2 id="2-事务的性质"><a href="#2-事务的性质" class="headerlink" title="2 事务的性质"></a>2 事务的性质</h2><p>事务的机制通常被概括为“ACID”原则即原子性（A）、稳定性（C）、隔离性（I）和持久性（D）。<br>原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。<br>稳定性：数据库在事务执行前后状态都必须是稳定的。<br>隔离性：事务之间不会相互影响。<br>持久性：事务执行成功后必须全部写入磁盘。</p><h2 id="3-事务隔离性实现原理"><a href="#3-事务隔离性实现原理" class="headerlink" title="3 事务隔离性实现原理"></a>3 事务隔离性实现原理</h2><p>数据库事务会导致脏读、不可重复读和幻影读等问题。<br>脏读：事务还没提交，他的修改已经被其他事务看到。<br>不可重复读：同一事务中两个相同SQL读取的内容可能不同。两次读取之间其他事务提交了修改可能会造成读取数据不一致。<br>幻影数据：同一个事务突然发现他以前没发现的数据。和不可重复读很类似，不过修改数据改成增加数据。<br>针对可能的问题，InnoDB提供了四种不同级别的机制保证数据隔离性。<br><strong> 事务的隔离用是通过锁机制实现的，不同于MyISAM使用表级别的锁，InnoDB采用更细粒度的行级别锁，提高了数据表的性能。InnoDB的锁通过锁定索引来实现，如果查询条件中有主键则锁定主键，如果有索引则先锁定对应索引然后再锁定对应的主键（可能造成死锁），如果连索引都没有则会锁定整个数据表。 </strong></p><h3 id="3-1-READ-UNCOMMIT"><a href="#3-1-READ-UNCOMMIT" class="headerlink" title="3.1 READ UNCOMMIT"></a>3.1 READ UNCOMMIT</h3><p>READ UNCOMMIT允许某个事务看到其他事务并没有提交的数据。可能会导致脏读、不可重复读、幻影数据。<br>原理：READ UNCOMMIT不会采用任何锁。</p><h3 id="3-2-READ-COMMIT"><a href="#3-2-READ-COMMIT" class="headerlink" title="3.2 READ COMMIT"></a>3.2 READ COMMIT</h3><pre><code>**可能有误，学习时没看到多版本并发控制（MVCC），学习后更新**</code></pre><p>READ COMMIT允许某个事务看到其他事务已经提交的数据。可能会导致不可重复读和幻影数据。<br>原理：数据的读是不加锁的，但是数据的写入、修改、删除加锁，避免了脏读。</p><h3 id="3-3-REPEATABLE-READ"><a href="#3-3-REPEATABLE-READ" class="headerlink" title="3.3 REPEATABLE READ"></a>3.3 REPEATABLE READ</h3><pre><code>**可能有误，学习时没看到多版本并发控制（MVCC），学习后更新**InnoDB中REPEATABLE READ级别同一个事务的两次相同读取肯定是一样的，其他事务的提交不会对本次事务有影响。</code></pre><p>原理：数据的读、写都会加锁，当前事务如果占据了锁，其他事务必须等待本次事务提交完成释放锁后才能对相同的数据行进行操作。</p><h3 id="3-4-SERIALIZABLE"><a href="#3-4-SERIALIZABLE" class="headerlink" title="3.4 SERIALIZABLE"></a>3.4 SERIALIZABLE</h3><pre><code>**可能有误，学习时没看到多版本并发控制（MVCC），学习后更新**</code></pre><p>SERIALIZABLE 级别在InnoDB中和REPEATABLE READ采用相同的实现。</p><h2 id="4-原子性、稳定性和持久性实现原理"><a href="#4-原子性、稳定性和持久性实现原理" class="headerlink" title="4 原子性、稳定性和持久性实现原理"></a>4 原子性、稳定性和持久性实现原理</h2><p>原子性、稳定性和持久性是通过redo 和 undo<br>日志文件实现的，不管是redo还是undo文件都会有一个缓存我们称之为redo_buf和undo_buf。同样，数据库文件也会有缓存称之为data_buf。</p><h3 id="4-1-undo-日志文件"><a href="#4-1-undo-日志文件" class="headerlink" title="4.1 undo 日志文件"></a>4.1 undo 日志文件</h3><p>undo记录了数据在事务开始之前的值，当事务执行失败或者ROLLBACK时可以通过undo记录的值来恢复数据。例如 AA和BB的初始值分别为3，5。</p><pre><code>A 事务开始B 记录AA=3到undo_bufC 修改AA=1D 记录BB=5到undo_bufE 修改BB=7F 将undo_buf写到undo(磁盘)G 将data_buf写到datafile(磁盘)H 事务提交</code></pre><p>通过undo可以保证原子性、稳定性和持久性<br><strong> 如果事务在F之前崩溃由于数据还没写入磁盘，所以数据不会被破坏。 </strong><br><strong> 如果事务在G之前崩溃或者回滚则可以根据undo恢复到初始状态。 </strong><br>数据在任务提交之前写到磁盘保证了持久性。<br>但是单纯使用undo保证原子性和持久性需要在事务提交之前将数据写到磁盘，浪费大量I/O。</p><h3 id="4-2-redo-undo-日志文件"><a href="#4-2-redo-undo-日志文件" class="headerlink" title="4.2 redo/undo 日志文件"></a>4.2 redo/undo 日志文件</h3><p>引入redo日志记录数据修改后的值，可以避免数据在事务提交之前必须写入到磁盘的需求，减少I/O。</p><pre><code>A 事务开始B 记录AA=3到undo_bufC 修改AA=1 记录redo_bufD 记录BB=5到undo_bufE 修改BB=7 记录redo_bufF 将redo_buf写到redo（磁盘）G 事务提交</code></pre><p><strong> 通过undo保证事务的原子性，redo保证持久性。 </strong><br><strong> F之前崩溃由于所有数据都在内存，恢复后重新冲磁盘载入之前的数据，数据没有被破坏。 </strong><br><strong> FG之间的崩溃可以使用redo来恢复。 </strong><br><strong> G之前的回滚都可以使用undo来完成。 </strong></p><h2 id="5-事务操作命令"><a href="#5-事务操作命令" class="headerlink" title="5 事务操作命令"></a>5 事务操作命令</h2><p>如果需要使用事务就必须选用支持事务的数据库引擎如InnoDB和Falcon，MyISAM并不支持事务。<br>在默认情况下MySQL开启的是autocommit模式，也就是隐含的将每条语句当做一个事务处理，每条SQL都会被自动提交。当我们使用BEGIN或者START<br>TRANSCATION时会把自动提交挂起，直到显示的调用COMMIT。使用事务可以有如下两种方法：</p><pre><code>BEGIN; //开始事务，挂起自动提交insert into t_cart_shopcart (user_id, sku_id, amount, shop_id,  status) values(10001, 10001, 1, 10001, 0);insert into t_cart_shopcart (user_id, sku_id, amount, shop_id,  status) values(10001, 10002, 1, 10001, 0);COMMIT; //提交事务，恢复自动提交set autocommit = 0; //挂起自动提交insert into t_cart_shopcart (user_id, sku_id, amount, shop_id,  status) values(10001, 10001, 1, 10001, 0);insert into t_cart_shopcart (user_id, sku_id, amount, shop_id,  status) values(10001, 10002, 1, 10001, 0);COMMIT; //提交事务set autocommit = 1; //恢复自动提交</code></pre><p>这两种方式效果相同。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="http://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html" target="_blank" rel="noopener"> http://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html</a><br>[2] <a href="http://www.letiantian.me/2014-06-18-db-undo-redo-checkpoint/" target="_blank" rel="noopener"> http://www.letiantian.me/2014-06-18-db-undo-redo-checkpoint/</a><br>[3] <a href="http://blog.csdn.net/mchdba/article/details/12242685" target="_blank" rel="noopener"> http://blog.csdn.net/mchdba/article/details/12242685</a><br>[4] 《MySQL技术内幕》<br>[5] <a href="http://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener"> http://tech.meituan.com/innodb-lock.html </a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL主从复制原理</title>
      <link href="/2017/11/11/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
      <content type="html"><![CDATA[<p>MySQL主从复制原理</p><p>当一台MySQL服务器无法满足现有的访问量时，一般会采用主从服务器模式，通过数据库代理做到读写分离。主服务器负责处理写入请求，从服务器服务器负责处理读取请求<br>。大部分情况是读取量远大于写入量，一般会配置多个从服务器。参考《高性能MySQL》，本文介绍了MySQL主从复制的原理和常见的拓扑结构。</p><h2 id="1-MySQL主从复制的过程"><a href="#1-MySQL主从复制的过程" class="headerlink" title="1 MySQL主从复制的过程"></a>1 MySQL主从复制的过程</h2><p>MySQL主从负责依赖binlog，要想实现复制必须打开binlog。主从复制的过程中由主服务器（Master）的IO进程配合从服务器（Slave）的IO进<br>程和SQL进程共同完成，具体不知如下：<br>1）Slave的IO进程向Master请求指定日志文件指定位置后的日志内容；<br>2）Master收到请求后，通过Master的IO进程读取Slave请求的数据并返回给Slave的IO进程，除了请求的内容还会给Slave返回本次读取到的b<br>inlog文件名称和位置；<br>3）Slave的IO进程收到返回内容后将日志内容添加到relay-log后面，并将文件位置信息保存到master-info中；<br>4）Slave的SQL进程发现relay-log有新内容后就会取出relay-log中的语句执行。<br><img src="http://img.blog.csdn.net/20160217195636237" alt="mysql主从复制过程"></p><h2 id="2-MySQL主从复制级别"><a href="#2-MySQL主从复制级别" class="headerlink" title="2 MySQL主从复制级别"></a>2 MySQL主从复制级别</h2><p>MySQL主从复制分为基于语句复制、基于行复制和混合复制三种。</p><h3 id="2-1-基于语句复制"><a href="#2-1-基于语句复制" class="headerlink" title="2.1 基于语句复制"></a>2.1 基于语句复制</h3><p>基于语句复制是MySQL根据binlog中的语句在Slave上重做这些操作，MySQL默认级别。优点是快速简单binlog文件小，缺点是使用到UUID()、<br>USER()以及部分UPDATE操作时没法正确的复制等。</p><h3 id="2-2-基于行复制"><a href="#2-2-基于行复制" class="headerlink" title="2.2 基于行复制"></a>2.2 基于行复制</h3><p>采用行复制时，binlog中记录的将不再是操作语句而是记录每一行的修改，这样避免了基于语句复制的缺点，保证每条修改都能被正确复制。但是行复制的binlog可<br>能会很大，比如说alter操作会在日志中记录所有行的变化，binlog就会过大。</p><h3 id="2-3-混合复制"><a href="#2-3-混合复制" class="headerlink" title="2.3 混合复制"></a>2.3 混合复制</h3><p>混合复制是前两种复制方式的结合，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在语句复制和行复制之间选择一种。当使用语句复制无<br>法准确复制会自动切换到行复制，如下几种情况会自动切换。<br>1）当函数中包含 UUID() 时；<br>2）2个及以上包含 AUTO_INCREMENT 字段的表被更新时；<br>3）执行 INSERT DELAYED 语句时；<br>4）用 UDF 时；<br>5）视图中必须要求运用 row 时，例如建立视图时使用了 UUID() 函数；<br>6）当 DML 语句更新一个 NDB 表时；</p><h2 id="3-主从复制常见的拓扑结构"><a href="#3-主从复制常见的拓扑结构" class="headerlink" title="3 主从复制常见的拓扑结构"></a>3 主从复制常见的拓扑结构</h2><p>常见的主从复制拓扑结构有一主多从、主动、级联等模式</p><h3 id="3-1-一主多从模式"><a href="#3-1-一主多从模式" class="headerlink" title="3.1 一主多从模式"></a>3.1 一主多从模式</h3><p>一主多从模式中有且只有一个Master有一组Slave，当前大部分主从复制采用这种模式。这种模式扩展方便，主从延时少。当写操作较少而读操作较多时采用这种方式<br>较合适，但是当Slave过多时会导致Master负载较重以及消耗较多带宽的问题。</p><h3 id="3-2-主动模式"><a href="#3-2-主动模式" class="headerlink" title="3.2 主动模式"></a>3.2 主动模式</h3><p>主动模式的两台服务器，既是master，又是另一台服务器的slave。这样，任何一方所做的变更，都会通过复制应用到另外一方的数据库中。</p><h3 id="3-3-级联模式"><a href="#3-3-级联模式" class="headerlink" title="3.3 级联模式"></a>3.3 级联模式</h3><p>当读压力较大时，连接到Master上的Slave较多，会给Master带来较大压力。采用级联的方式即Master只连接一定数量的Slave，这些Slave又<br>充当其他Slave的Master。级联模式减少了Master的压力但是也会带来主从复制延时较大的问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://blog.csdn.net/hguisu/article/details/7325124" target="_blank" rel="noopener"> http://blog.csdn.net/hguisu/article/details/7325124</a><br>[2] <a href="http://database.51cto.com/art/200906/128162.htm" target="_blank" rel="noopener"> http://database.51cto.com/art/200906/128162.htm</a><br>[3] <a href="http://wangwei007.blog.51cto.com/68019/965575" target="_blank" rel="noopener"> http://wangwei007.blog.51cto.com/68019/965575</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis主从同步原理-SYNC</title>
      <link href="/2017/11/11/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86-SYNC/"/>
      <content type="html"><![CDATA[<p>和MySQL主从复制的原因一样，Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。为了分担读压力，Redis支持主从复制，Redis的主<br>从结构可以采用一主多从或者级联结构，下图为级联结构。<br><img src="http://img.blog.csdn.net/20160223183441769" alt="Redis主从结构"><br>Redis主从复制可以根据是否是全量分为全量同步和增量同步。</p><h2 id="1-全量同步"><a href="#1-全量同步" class="headerlink" title="1 全量同步"></a>1 全量同步</h2><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br>1）从服务器连接主服务器，发送SYNC命令；<br>2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；<br><img src="http://img.blog.csdn.net/20160223183521160" alt="Redis全量同步过程"><br>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p><h2 id="2-增量同步"><a href="#2-增量同步" class="headerlink" title="2 增量同步"></a>2 增量同步</h2><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><h2 id="3-Redis主从同步策略"><a href="#3-Redis主从同步策略" class="headerlink" title="3 Redis主从同步策略"></a>3 Redis主从同步策略</h2><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis<br>策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><p>Redis 2.8以后提供了PSYNC优化了断线重连的效率<br><a href="http://blog.csdn.net/sk199048/article/details/77922589" target="_blank" rel="noopener"> http://blog.csdn.net/sk199048/article/details/77922589</a></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] 《Redis IN ACTION》<br>[2] <a href="http://blog.csdn.net/houjixin/article/details/27680183" target="_blank" rel="noopener"> http://blog.csdn.net/houjixin/article/details/27680183</a><br>[3] <a href="http://daoluan.net/blog/2014/04/22/decode-redis-replication/" target="_blank" rel="noopener"> http://daoluan.net/blog/2014/04/22/decode-redis-replication/</a></p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis主从同步原理-PSYNC</title>
      <link href="/2017/11/11/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86-PSYNC/"/>
      <content type="html"><![CDATA[<p>之前写过一篇博客（ <a href="http://blog.csdn.net/sk199048/article/details/50725369" target="_blank" rel="noopener"> http://blog.csdn.net/sk199048/article/details/50725369</a><br>）来介绍了Redis主从同步的过程，里面主要介绍从服务器使用SYNC命令复制数据的过程。Reids复制数据主要有2种场景：<br>1. 从服务器从来第一次和当前主服务器连接，即初次复制<br>2. 从服务器断线后重新和之前连接的主服务器恢复连接，即断线后重复制<br>对于初次复制来说使用SYNC命令进行全量复制是合适高效的，但是对于 <strong> 断线后重复制 </strong> 来说效率就不太能接受了。举例来说：<br><img src="http://img.blog.csdn.net/20170910141439297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2sxOTkwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Redis断线重连"><br>如图所示，Master在断开连接期间只传播了3个写入命令，但是重新连接之后却要全量复制，显然这是低效并且不太必要的。</p><h3 id="PSYNC概念"><a href="#PSYNC概念" class="headerlink" title="PSYNC概念"></a>PSYNC概念</h3><p>为了应对这种情况，Redis在2.8版本提供了PSYNC命令来带代替SYNC命令，为Redis主从复制提供了部分复制的能力。PSYNC命令格式是：</p><pre><code>PSYNC &lt;runid&gt; &lt;offset&gt;runid:主服务器IDoffset:从服务器最后接收命令的偏移量</code></pre><p>PSYNC执行过程中比较重要的概念有3个：runid、offset（复制偏移量）以及复制积压缓冲区。</p><h4 id="runid"><a href="#runid" class="headerlink" title="runid"></a>runid</h4><p>每个Redis服务器都会有一个表明自己身份的ID。在PSYNC中发送的这个ID是指之前连接的Master的ID，如果没保存这个ID，PSYNC的命令会使用”<br>PSYNC ? -1” 这种形式发送给Master，表示需要全量复制。</p><h4 id="offset（复制偏移量）"><a href="#offset（复制偏移量）" class="headerlink" title="offset（复制偏移量）"></a>offset（复制偏移量）</h4><p>在主从复制的Master和Slave双方都会各自维持一个offset。Master成功发送N个字节的命令后会将Master的offset加上N，Slave在<br>接收到N个字节命令后同样会将Slave的offset增加N。Master和Slave如果状态是一致的那么它的的offset也应该是一致的。</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由Master维护的一个固定长度的FIFO队列，它的作用是缓存已经传播出去的命令。当Master进行命令传播时，不仅将命令发送给所有Slav<br>e，还会将命令写入到复制积压缓冲区里面。</p><h3 id="PSYNC执行过程"><a href="#PSYNC执行过程" class="headerlink" title="PSYNC执行过程"></a>PSYNC执行过程</h3><p>理解了上面三个基本概念，PSYNC的执行过程就好理解了。<br><img src="http://img.blog.csdn.net/20170910152114918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2sxOTkwNDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="PSYNC执行过程"><br>1 客户端向服务器发送SLAVEOF命令，让当前服务器成为Slave；<br>2 当前服务器根据自己是否保存Master runid来判断是否是第一次复制，如果是第一次同步则跳转到3，否则跳转到4；<br>3 向Master发送PSYNC ? -1 命令来进行完整同步；<br>4 向Master发送PSYNC runid offset；<br>5 Master接收到PSYNC 命令后首先判断runid是否和本机的id一致，如果一致则会再次判断offset偏移量和本机的偏移量相差有没有超过复制积压缓<br>冲区大小，如果没有那么就给Slave发送CONTINUE，此时Slave只需要等待Master传回失去连接期间丢失的命令；<br>6 如果runid和本机id不一致或者双方offset差距超过了复制积压缓冲区大小，那么就会返回FULLRESYNC runid<br>offset，Slave将runid保存起来，并进行完整同步。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>上面内容大多数是《Redis设计与实现》这本书中的内容，接下来会仔细看下这部分实现的源码，将实现细节理出来。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>《Redis设计与实现》黄健宏</p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis事务介绍</title>
      <link href="/2017/11/11/Redis%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
      <content type="html"><![CDATA[<h2 id="1-什么是Redis事务"><a href="#1-什么是Redis事务" class="headerlink" title="1 什么是Redis事务"></a>1 什么是Redis事务</h2><p>Redis通过MULTI、EXEC、DISCARD以及WATCH命令提供事务功能。Redis的事务提供一次性、按顺序执行命令的机制，并且不会中断事务去执行其<br>他命令。Redis事务和我们常理解的事务还是有些区别的，即事务中的部分命令执行失败不会导致事务回滚。Redis事务的核心思想是维护一个事务命令队列，将事务中<br>的所有命令先预存到队列中，等待EXEC一起执行或者DISCARD清空队列。</p><h2 id="2-Redis事务命令"><a href="#2-Redis事务命令" class="headerlink" title="2 Redis事务命令"></a>2 Redis事务命令</h2><p>事务的执行分为三个步骤，事务开始、命令入队列以及事务执行。</p><h3 id="2-1-MULTI（事务开始）"><a href="#2-1-MULTI（事务开始）" class="headerlink" title="2.1 MULTI（事务开始）"></a>2.1 MULTI（事务开始）</h3><p>当Redis服务器接收到某个客户端发送过来的MULTI命令后就会将这个客户端的状态标志为事务状态（REDIS_MULTI），事务状态的客户端会将除了MULT<br>I、EXEC、DISCARD以及WATCH命令都加入到命令队列中。如果有错误命令，会导致事务取消。例如：</p><pre><code>127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set name &quot;shi ke&quot;QUEUED127.0.0.1:6379&gt; set firstName &quot;shi&quot;QUEUED127.0.0.1:6379&gt; err set(error) ERR unknown command &apos;err&apos;127.0.0.1:6379&gt; get nameQUEUED127.0.0.1:6379&gt; get firstNameQUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.</code></pre><h3 id="2-2-EXEC-（事务执行）"><a href="#2-2-EXEC-（事务执行）" class="headerlink" title="2.2 EXEC （事务执行）"></a>2.2 EXEC （事务执行）</h3><p>当Redis服务器接收到客户端的EXEC命令后会遍历这个服务器的所有事务命令并且依次执行，返回结果，将客户端状态改回非事务。需要注意的是Redis服务器不保<br>证每个命令都能执行成功，已经执行成功的会改变数据库库状态，不提供回滚功能。</p><h3 id="2-3-DISCARD-（事务取消）"><a href="#2-3-DISCARD-（事务取消）" class="headerlink" title="2.3 DISCARD （事务取消）"></a>2.3 DISCARD （事务取消）</h3><p>当Redis服务器收到DISCARD命令后会清空该客户端的事务命令队列并且将客户端状态修改成非事务。例如：</p><pre><code>127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set name &quot;keshi&quot;QUEUED127.0.0.1:6379&gt; DISCARDOK127.0.0.1:6379&gt; EXEC(error) ERR EXEC without MULTI</code></pre><h3 id="2-4-WATCH-（监控）"><a href="#2-4-WATCH-（监控）" class="headerlink" title="2.4 WATCH （监控）"></a>2.4 WATCH （监控）</h3><p>在事务开始之前可以用WATCH命令监控特定的键，当有其他客户端修改了监控的键，那么服务器将拒绝执行这个客户端接下来的一个事务。例如：</p><pre><code>redis-cli-1                          redis-cli-2127.0.0.1:6379&gt; WATCH nameOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; get nameQUEUED127.0.0.1:6379&gt; set firstName &quot;Yang&quot;  127.0.0.1:6379&gt; set name &quot;Yang Li&quot;QUEUED127.0.0.1:6379&gt; EXEC(nil)127.0.0.1:6379&gt; get firstName&quot;shike&quot;127.0.0.1:6379&gt; get name&quot;Yang Li&quot;</code></pre><h2 id="3-Redis事务的ACID原则"><a href="#3-Redis事务的ACID原则" class="headerlink" title="3 Redis事务的ACID原则"></a>3 Redis事务的ACID原则</h2><p>事务的ACID即事务的原子性、一致性、隔离性、持久性，Redis事务能够保证原子性、一致性、隔离性但是不会保证持久性。</p><h3 id="3-1-原子性"><a href="#3-1-原子性" class="headerlink" title="3.1 原子性"></a>3.1 原子性</h3><p>事务的原子性是指一组操作要么全部执行，要么全不执行。Redis可以保证一组数据同时执行或者不执行。 <strong><br>但是不同于MySQL等关系数据库事务操作，Redis不提供回滚操作即部分操作失败不会引起整个事务回滚。 </strong></p><h3 id="3-2-一致性"><a href="#3-2-一致性" class="headerlink" title="3.2 一致性"></a>3.2 一致性</h3><p>事务的一致性指数据库中的数据全部符合数据库的规范，不会出现不符合规范的数据存在。Redis通过严格的错误检测保证事务的一致性。<br>第一、入队时的错误回直接导致整个事务失败，保证一致性。<br>第二、执行时错误会跳过错误命令，继续执行其他命令。<br>第三、服务器重启，如果有持久化则通过RDB、AOF文件恢复数据，否则数据库为空。</p><h3 id="3-3-隔离性"><a href="#3-3-隔离性" class="headerlink" title="3.3 隔离性"></a>3.3 隔离性</h3><p>Redis事务在执行之前只是将命令存在操作队列中，不会真正去操作数据库，所有事务之间不会相互影响。</p><h3 id="3-4-持久性"><a href="#3-4-持久性" class="headerlink" title="3.4 持久性"></a>3.4 持久性</h3><p>Redis事务是否具有持久性是由他的持久化策略决定的，当且仅当采用AOF模式并且appendfsync设为always时才具有持久性，具体原因请看Redis<br>持久化介绍（ <a href="http://blog.csdn.net/sk199048/article/details/50589491" target="_blank" rel="noopener"> http://blog.csdn.net/sk199048/article/details/50589491</a> ）</p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis持久化方式介绍</title>
      <link href="/2017/11/11/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
      <content type="html"><![CDATA[<p>Redis的持久化方法持久化方法有RDB文件和AOF文件两种。下面主要介绍两种持久化方法的原理缺点以及我在做交易系统异步化改造项目时用到redis的场景。</p><h2 id="1-RDB文件"><a href="#1-RDB文件" class="headerlink" title="1 RDB文件"></a>1 RDB文件</h2><p>RDB文件是一个经过压缩的二进制文件，通过这个文件可以还原生成RDB文件时的数据库状态。RDB文件是直接保存在硬盘中的，所以即使Redis宕机也可以通过RD<br>B文件恢复。生成RDB文件的Redis命令有SAVE和BGSAVE两个。</p><h3 id="1-1-SAVE命令"><a href="#1-1-SAVE命令" class="headerlink" title="1.1 SAVE命令"></a>1.1 SAVE命令</h3><p>Redis是单进程工作的，SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完成之前，服务器不能接受任何处理命令。</p><h3 id="1-2-BGSAVE命令"><a href="#1-2-BGSAVE命令" class="headerlink" title="1.2 BGSAVE命令"></a>1.2 BGSAVE命令</h3><p>不同于SAVE命令，BGSAVE通过子进程创建RDB文件。当接收到BGSAVE命令后，Redis主进程会fork一个子进程负责创建RDB文件，Redis此时<br>还可以继续处理客户端命令。BGSAVE执行期间如果客户端再次发送BGSAVE时会被拒绝，防止争用rdbSave。同样客户端发送SAVE也会被拒绝。</p><h3 id="1-3-RDB文件载入"><a href="#1-3-RDB文件载入" class="headerlink" title="1.3 RDB文件载入"></a>1.3 RDB文件载入</h3><p>当RDB文件载入时，Redis会被阻塞，直到文件载入完成。</p><h2 id="2-AOF文件"><a href="#2-AOF文件" class="headerlink" title="2 AOF文件"></a>2 AOF文件</h2><p>AOF文件文件是Redis提供的另一种持久化方案，他记录Redis服务器的执行命令还记录数据库的状态（和MySQL的Binlog有点类似）。AOF命令中记录<br>的是纯文本格式的命令。AOF持久化的过程分为命令追加、文件写入和文件同步三个过程。</p><h3 id="2-1-命令追加"><a href="#2-1-命令追加" class="headerlink" title="2.1 命令追加"></a>2.1 命令追加</h3><p>当AOF持久化功能打开时，服务器在执行完一条命令后会以协议格式将执行完的命令追加到aof_buf缓冲区的末尾。</p><h3 id="2-2-文件写入与同步"><a href="#2-2-文件写入与同步" class="headerlink" title="2.2 文件写入与同步"></a>2.2 文件写入与同步</h3><p>Redis服务进程是个事件循环，服务器每次在执行完一次事件之前都会调用flushAppendOnlyFile决定是否将aof缓冲区中的内容保存到AOF文件中<br>。Redis服务器根据配置appendfsync决定同步策略，Redis为appendfsync提供了三种配置，分别为always、everysec、no。<br>当配置为always时，服务器每次事件循环都会将缓冲区中的所有内容都写到文件中，速度最慢但是最安全。<br>当配置为everysec时，服务器每隔1秒回将缓存中数据写到文件中，速度够快，最多丢失1秒的数据。<br>当配置为no时，由操作系统决定什么时间将缓存中内容写入到AOF文件中。</p><h3 id="2-3-数据还原"><a href="#2-3-数据还原" class="headerlink" title="2.3 数据还原"></a>2.3 数据还原</h3><p>Redis服务器利用AOF还原的原理是创建一个不带网络连接的伪客户端执行AOF中保存的命令即可。</p><h3 id="2-4-缺点"><a href="#2-4-缺点" class="headerlink" title="2.4 缺点"></a>2.4 缺点</h3><p>AOF文件持久化得缺点是AOF文件往往会过大，虽然Redis提供了文件重写机制，但是在操作较多的时候AOF文件仍会很大。</p><h2 id="3-交易系统场景Redis使用"><a href="#3-交易系统场景Redis使用" class="headerlink" title="3 交易系统场景Redis使用"></a>3 交易系统场景Redis使用</h2><p>我们交易系统Redis只当缓存用，并且不开启持久化功能，redis中的数据通过消息队列（kafka）同步到MySQL中，通过MySQL保证数据完整性、一致性<br>。交易是个高频写入、峰值写入会特别大的系统，由上面分析的Redis两种持久化方案都会导致系统性能剧烈下降。</p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql_explain_解释器中的字段含义</title>
      <link href="/2017/11/11/mysql_explain_%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89/"/>
      <content type="html"><![CDATA[<p>explain是mysql常用的分析select的查询行为的分析器，解析的内容如下：</p><p>id | select_type | table        | type | possible_keys | key  | key_len | ref<br>| rows    | Extra       |<br>+—-+————-+————–+——+—————+——+———+—<br>—+———+————-+<br>|  1 | SIMPLE      | TradeBalance | ALL  | NULL          | NULL | NULL    |<br>NULL | 3418948 | Using where |  </p><p>接下来就着重分析下每一个字段的含义：</p><p>type 字段包含：执行计划包含的信息</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117000267.png" alt=""></p><h2 id="id"><a href="#id" class="headerlink" title=" id  "></a><strong> id  </strong></h2><p>包含一组数字，表示查询中执行select子句或操作表的顺序</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116184696.png" alt=""></p><p>id相同，执行顺序由上至下</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116211146.png" alt=""></p><p>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116243320.png" alt=""></p><p>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p><h2 id="select-type"><a href="#select-type" class="headerlink" title=" select_type  "></a><strong> select_type  </strong></h2><p>表示查询中每个select子句的类型（简单 OR复杂）</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116514450.png" alt=""></p><p>a.SIMPLE：查询中不包含子查询或者UNION</p><p>b.查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY</p><p>c.在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY</p><p>d.在FROM列表中包含的子查询被标记为：DERIVED（衍生）</p><p>e.若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在  FROM子句的子查询中，外层SELECT将被标记为：DERIVED</p><p>f.从UNION表获取结果的SELECT被标记为：UNION RESULT</p><h2 id="type"><a href="#type" class="headerlink" title=" type  "></a><strong> type  </strong></h2><p>表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下：</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116263147.png" alt=""></p><p>由左至右，由最差到最好</p><p>a.ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116293337.png" alt=""></p><p>b.index：Full Index Scan，index与ALL区别为index类型只遍历索引树</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116302815.png" alt=""></p><p>c.range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117005638.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116330793.png" alt=""></p><p>range访问类型的不同形式的索引访问性能差异</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111116345790.png" alt=""></p><p>d.ref：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117044259.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117021262.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117071015.png" alt=""></p><p>e.eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117082458.png" alt=""></p><p>f.const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转<br>换为一个常量</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117100041.png" alt=""></p><p>system是const类型的特例，当查询的表只有一行的情况下， 使用system</p><p>g.NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117105768.png" alt=""></p><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title=" possible_keys  "></a><strong> possible_keys  </strong></h2><p>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p><h2 id="key"><a href="#key" class="headerlink" title=" key  "></a><strong> key  </strong></h2><p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</p><p>TIPS：查询中若使用了覆盖索引，则该索引仅出现在key列表中</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117131391.png" alt=""></p><h2 id="key-len"><a href="#key-len" class="headerlink" title=" key_len  "></a><strong> key_len  </strong></h2><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117150784.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117165474.png" alt=""></p><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p><h2 id="ref"><a href="#ref" class="headerlink" title=" ref  "></a><strong> ref  </strong></h2><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117181192.png" alt=""></p><p>本例中，由key_len可知t1表的idx_col1_col2被充分使用，col1匹配t2表的col1，col2匹配了一个常量，即 ’ac’</p><p>rows</p><p>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117190265.png" alt=""></p><h2 id="Extra"><a href="#Extra" class="headerlink" title=" Extra  "></a><strong> Extra  </strong></h2><p>包含不适合在其他列中显示但十分重要的额外信息</p><p>a.Using index</p><p>该值表示相应的select操作中使用了覆盖索引（Covering Index）</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117202882.png" alt=""></p><p>TIPS：覆盖索引（Covering Index）</p><p>MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件</p><p>包含所有满足查询需要的数据的索引称为 <strong> 覆盖索引 </strong> （Covering Index）</p><p>注意：</p><p>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降</p><p>b.Using where</p><p>表示MySQL服务器在存储引擎受到记录后进行“后过滤”（Post-filter）,</p><p>如果查询未能使用索引，Using where的作用只是提醒我们MySQL将用where子句来过滤结果集</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117220955.png" alt=""></p><p>c.Using temporary</p><p>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117225748.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117230687.png" alt=""></p><p>d.Using filesort</p><p>MySQL中无法利用索引完成的排序操作称为“文件排序”</p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117235757.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117242290.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117244986.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2012/360373/2012111117245862.png" alt=""></p><h2 id="MySQL执行计划的局限"><a href="#MySQL执行计划的局限" class="headerlink" title=" MySQL执行计划的局限  "></a><strong> MySQL执行计划的局限  </strong></h2><p>•EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</p><p>•EXPLAIN不考虑各种Cache</p><p>•EXPLAIN不能显示MySQL在执行查询时所作的优化工作</p><p>•部分统计信息是估算的，并非精确值</p><p>•EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</p><h2 id="最后"><a href="#最后" class="headerlink" title=" 最后  "></a><strong> 最后  </strong></h2><p>本文是我从简朝阳推荐的ppt转换为网页版的，原ppt下载: <a href="http://files.cnblogs.com/ggjucheng/mysqlexplain.ppt" target="_blank" rel="noopener"> 下载地址</a></p><p>原文链接 <a href="http://isky000.com/database/mysql-explain-detail" target="_blank" rel="noopener">http://isky000.com/database/mysql-explain-detail</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java_IO：BufferedInputStream使用详解及源码分析</title>
      <link href="/2017/11/11/Java_IO%EF%BC%9ABufferedInputStream%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<p>Java IO：BufferedInputStream使用详解及源码分析</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>BufferedInputStream继承于FilterInputStream，提供缓冲输入流功能。缓冲输入流相对于普通输入流的优势是，它提供了一个缓冲数组<br>，每次调用read方法的时候，它首先尝试从缓冲区里读取数据，若读取失败（缓冲区无可读数据），则选择从物理数据源（譬如文件）读取新数据（这里会尝试尽可能读取多<br>的字节）放入到缓冲区中，最后再将缓冲区中的内容部分或全部返回给用户.由于从缓冲区里读取数据远比直接从物理数据源（譬如文件）读取速度快。</p><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>BufferedInputStream提供的API如下：</p><pre><code>//构造方法BufferedInputStream(InputStream in)BufferedInputStream(InputStream in, int size)//下一字节是否可读synchronized int     available()//关闭void     close()//标记, readlimit为mark后最多可读取的字节数synchronized void     mark(int readlimit)//是否支持mark, trueboolean     markSupported()//读取一个字节synchronized int     read()//读取多个字节到bsynchronized int     read(byte[] b, int off, int len)//重置会mark位置synchronized void     reset()//跳过n个字节synchronized long     skip(long n)</code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code>public void testBufferedInput() {    try {        /**         * 建立输入流 BufferedInputStream, 缓冲区大小为8         * buffer.txt内容为         * abcdefghij         */        InputStream in = new BufferedInputStream(new FileInputStream(new File(&quot;buff.txt&quot;)), 8);        /*从字节流中读取5个字节*/        byte [] tmp = new byte[5];        in.read(tmp, 0, 5);        System.out.println(&quot;字节流的前5个字节为: &quot; + new String(tmp));        /*标记测试*/        in.mark(6);        /*读取5个字节*/        in.read(tmp, 0, 5);        System.out.println(&quot;字节流中第6到10个字节为: &quot; +  new String(tmp));        /*reset*/        in.reset();        System.out.printf(&quot;reset后读取的第一个字节为: %c&quot; , in.read());    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>运行结果如下：</p><pre><code>字节流的前5个字节为: abcde字节流中第6到10个字节为: fghijreset后读取的第一个字节为: f</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>BufferedInputStream的构造方法有两个，区别是缓冲区大小设置。</p><pre><code>/** * Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt; * and saves its  argument, the input stream * &lt;code&gt;in&lt;/code&gt;, for later use. An internal * buffer array is created and  stored in &lt;code&gt;buf&lt;/code&gt;. * * @param   in   the underlying input stream. */public BufferedInputStream(InputStream in) {    this(in, DEFAULT_BUFFER_SIZE); //默认8192, 8M}/** * Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt; * with the specified buffer size, * and saves its  argument, the input stream * &lt;code&gt;in&lt;/code&gt;, for later use.  An internal * buffer array of length  &lt;code&gt;size&lt;/code&gt; * is created and stored in &lt;code&gt;buf&lt;/code&gt;. * * @param   in     the underlying input stream. * @param   size   the buffer size. * @exception IllegalArgumentException if {@code size &lt;= 0}. */public BufferedInputStream(InputStream in, int size) {    super(in);    if (size &lt;= 0) {        throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);    }    buf = new byte[size];}</code></pre><h3 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h3><p>read方法有每次读取一个字节和一次读取多个字节两种重载。下面主要分析读取多个字节的read方法。 <strong> <em> 重点在于fill()方法 </em> </strong> 。</p><pre><code>/** * Reads bytes from this byte-input stream into the specified byte array, * starting at the given offset. * * &lt;p&gt; This method implements the general contract of the corresponding * &lt;code&gt;{@link InputStream#read(byte[], int, int) read}&lt;/code&gt; method of * the &lt;code&gt;{@link InputStream}&lt;/code&gt; class.  As an additional * convenience, it attempts to read as many bytes as possible by repeatedly * invoking the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This * iterated &lt;code&gt;read&lt;/code&gt; continues until one of the following * conditions becomes true: &lt;ul&gt; * * @param      b     destination buffer. * @param      off   offset at which to start storing bytes. * @param      len   maximum number of bytes to read. * @return     the number of bytes read, or &lt;code&gt;-1&lt;/code&gt; if the end of the stream has been reached. * @exception  IOException  if this input stream has been closed by invoking its {@link #close()} method, *                   or an I/O error occurs. */public synchronized int read(byte b[], int off, int len)        throws IOException{    getBufIfOpen(); // Check for closed stream    if ((off | len | (off + len) | (b.length - (off + len))) &lt; 0) {        throw new IndexOutOfBoundsException();    } else if (len == 0) {        return 0;    }    int n = 0;    for (;;) {        int nread = read1(b, off + n, len - n); //读取len长度的字节到b中        if (nread &lt;= 0)            return (n == 0) ? nread : n;        n += nread;        if (n &gt;= len)            return n;        // if not closed but no bytes available, return        InputStream input = in;        if (input != null &amp;&amp; input.available() &lt;= 0)            return n;    }}/** * Check to make sure that buffer has not been nulled out due to * close; if not return it; */private byte[] getBufIfOpen() throws IOException {    byte[] buffer = buf;    if (buffer == null)        throw new IOException(&quot;Stream closed&quot;);    return buffer;}/** * Read characters into a portion of an array, reading from the underlying * stream at most once if necessary. */private int read1(byte[] b, int off, int len) throws IOException {    int avail = count - pos; //缓冲区中可读字节数    if (avail &lt;= 0) { //没可读字节        /* If the requested length is at least as large as the buffer, and           if there is no mark/reset activity, do not bother to copy the           bytes into the local buffer.  In this way buffered streams will           cascade harmlessly. */        if (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; 0) { //没mark并且请求长度大于buff长度            return getInIfOpen().read(b, off, len); //直接从文件中读取,不走缓冲区        }        fill(); //修改或者扩展缓冲区        avail = count - pos; //可读字节数        if (avail &lt;= 0) return -1;    }    int cnt = (avail &lt; len) ? avail : len; //取最小值, 缓冲区中可能没有足够可读的字节    System.arraycopy(getBufIfOpen(), pos, b, off, cnt); //复制    pos += cnt;    return cnt;}/** * Fills the buffer with more data, taking into account * shuffling and other tricks for dealing with marks. * Assumes that it is being called by a synchronized method. * This method also assumes that all data has already been read in, * hence pos &gt; count. */private void fill() throws IOException {    /**     * 填充字符时如果没有mark标记, 则直接清空缓冲区,然后将输入流的数据写入缓冲区     * 如果有mark标记,则分如下几种情况     * 1 普通mark,直接将标记以前的字符用标记以后的字符覆盖,剩余的空间读取输入流的内容填充     * 2 当前位置pos &gt;= buffer的长度 &gt;= marklimit,说明mark已经失效,直接清空缓冲区,然后读取输入流内容     * 3 buffer长度超出限制,抛出异常     * 4 marklimit比buffer的长度还大,此时mark还没失效,则扩大buffer空间     */    byte[] buffer = getBufIfOpen();    if (markpos &lt; 0)        pos = 0;            /* no mark: throw away the buffer */    else if (pos &gt;= buffer.length)  /* no room left in buffer */        if (markpos &gt; 0) {  /* can throw away early part of the buffer */            int sz = pos - markpos;            System.arraycopy(buffer, markpos, buffer, 0, sz);            pos = sz;            markpos = 0;        } else if (buffer.length &gt;= marklimit) {            markpos = -1;   /* buffer got too big, invalidate mark */            pos = 0;        /* drop buffer contents */        } else if (buffer.length &gt;= MAX_BUFFER_SIZE) {            throw new OutOfMemoryError(&quot;Required array size too large&quot;);        } else {            /* grow buffer */            int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos)                    pos * 2 : MAX_BUFFER_SIZE; //扩大后的大小            if (nsz &gt; marklimit)                nsz = marklimit;            byte nbuf[] = new byte[nsz];            System.arraycopy(buffer, 0, nbuf, 0, pos); //将buffer的数据复制到nbuf中            if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {                // Can&apos;t replace buf if there was an async close.                // Note: This would need to be changed if fill()                // is ever made accessible to multiple threads.                // But for now, the only way CAS can fail is via close.                // assert buf == null;                throw new IOException(&quot;Stream closed&quot;);            }            buffer = nbuf; //修改缓冲区        }    count = pos;    int n = getInIfOpen().read(buffer, pos, buffer.length - pos); //读取输入流中内容填充缓冲区    if (n &gt; 0)        count = n + pos;}</code></pre><h3 id="mark-reset方法"><a href="#mark-reset方法" class="headerlink" title="mark\reset方法"></a>mark\reset方法</h3><pre><code>/** * See the general contract of the &lt;code&gt;mark&lt;/code&gt; * method of &lt;code&gt;InputStream&lt;/code&gt;. * * @param   readlimit   the maximum limit of bytes that can be read before *                      the mark position becomes invalid. * @see     java.io.BufferedInputStream#reset() */public synchronized void mark(int readlimit) {    marklimit = readlimit;    markpos = pos;}/** * See the general contract of the &lt;code&gt;reset&lt;/code&gt; * method of &lt;code&gt;InputStream&lt;/code&gt;. * &lt;p&gt; * If &lt;code&gt;markpos&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; * (no mark has been set or the mark has been * invalidated), an &lt;code&gt;IOException&lt;/code&gt; * is thrown. Otherwise, &lt;code&gt;pos&lt;/code&gt; is * set equal to &lt;code&gt;markpos&lt;/code&gt;. * * @exception  IOException  if this stream has not been marked or, *                  if the mark has been invalidated, or the stream *                  has been closed by invoking its {@link #close()} *                  method, or an I/O error occurs. * @see        java.io.BufferedInputStream#mark(int) */public synchronized void reset() throws IOException {    getBufIfOpen(); // Cause exception if closed    if (markpos &lt; 0)        throw new IOException(&quot;Resetting to invalid mark&quot;);    pos = markpos;}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://zhhphappy.iteye.com/blog/1562427" target="_blank" rel="noopener"> http://zhhphappy.iteye.com/blog/1562427</a><br>[2] <a href="http://blog.sina.com.cn/s/blog_67f995260101huxz.html" target="_blank" rel="noopener"> http://blog.sina.com.cn/s/blog_67f995260101huxz.html</a><br>[3] <a href="http://www.cnblogs.com/skywang12345/p/io_12.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/io_12.html</a></p>]]></content>
      
      <categories>
          
          <category> Java_IO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql技术内幕学习笔记-查询优化器及索引（一）</title>
      <link href="/2017/11/11/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <content type="html"><![CDATA[<h3 id="1、查询优化器工作目标"><a href="#1、查询优化器工作目标" class="headerlink" title="1、查询优化器工作目标"></a>1、查询优化器工作目标</h3><p>查询优化器最主要的工作目标是尽可能的使用索引，并且要使用条件最严格的索引来尽可能多、尽可能快得排除不符合索引的数据行。<br>例如：要查询员工表中年龄为25的男性姓名。<br>SELECT  name FROM staff WHERE   sex = ‘M’ AND age = 25;<br>假设年龄为25的又100， 男性有600个，25岁的男性员工有10个。查询优化器会首先从age开始匹配，首先排除900人，然后再从100个25岁的员工中找出<br>男性。如果先从sex开始匹配，那么需要从600个男性员工中查找25岁的员工，查询效率低于先排除900个年龄不是25的员工。<br>mysql在将一个索引项中的值与常数进行比较，优化器会假设索引中的键值是均匀的，并且会检查估算查询会用到多少个索引项。</p><h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><h4 id="2-1、-为什么要索引"><a href="#2-1、-为什么要索引" class="headerlink" title="2.1、 为什么要索引"></a>2.1、 为什么要索引</h4><p>直接引用参考文献1的说法“除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出<br>最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范<br>围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能<br>把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250<br>条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具<br>有不错的查询性能。”</p><h4 id="2-2、-索引的数据结构"><a href="#2-2、-索引的数据结构" class="headerlink" title="2.2、 索引的数据结构"></a>2.2、 索引的数据结构</h4><p>目前大多数的数据库采用b数或者b+树。一般索引本身比较大，无法全部存储在内存中，在查询过程中就会产生I/O消耗。磁盘每次预读都会加载一个页大小的数据，数据库<br>设计者利用这个原理将节点大小也设置为1页，那么每个节点就只需要1次I/O。高度为h的的b树，最多只需要h次I/O就可以实现查找，由于数据库中根节点常驻内存<br>，所以只需要h-<br>1次即可完成查找。同样，我们可以使用红黑树等其他数据结构实现索引，但是由于相同节点数红黑树等树的高度较大等原因，导致I/O较多，效率没有b数高。</p><h4 id="2-3-MyISAM及InnoDB索引实现"><a href="#2-3-MyISAM及InnoDB索引实现" class="headerlink" title="2.3 MyISAM及InnoDB索引实现"></a>2.3 MyISAM及InnoDB索引实现</h4><h5 id="2-3-1-MyISAM索引"><a href="#2-3-1-MyISAM索引" class="headerlink" title="2.3.1 MyISAM索引"></a>2.3.1 MyISAM索引</h5><p>MyISAM索引为非聚簇索引，也就是索引和数据表不是同一文件。下图为b+数实现的MyISAM索引结构。</p><p><img src="http://img.blog.csdn.net/20151202134926444?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p><p>MyISAM索引结构</p><p>从图中可以看出，MyISAM索引的节点并没有存储真正的数据，它存储了真正数据航所在的地址，然后通过地址到数据表文件中取出数据。</p><h5 id="2-3-2-InnoDB索引"><a href="#2-3-2-InnoDB索引" class="headerlink" title="2.3.2 InnoDB索引"></a>2.3.2 InnoDB索引</h5><p><img src="http://img.blog.csdn.net/20151202141244540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p><p>InnoDB索引结构</p><p>InnoDB索引为聚簇索引，即索引和数据在同一个文件。下图为b+数实现的InnoDB索引结构。<br>从图中可以看出，InnoDB索引的节点存储了真正的数据，索引和数  据存  放在  一起。</p><h3 id="3、索引失效情况"><a href="#3、索引失效情况" class="headerlink" title="3、索引失效情况"></a>3、索引失效情况</h3><h4 id="3-1-带索引的数据列在表达式中应单独出现，不要在索引列进行运算"><a href="#3-1-带索引的数据列在表达式中应单独出现，不要在索引列进行运算" class="headerlink" title="3.1 带索引的数据列在表达式中应单独出现，不要在索引列进行运算"></a>3.1 带索引的数据列在表达式中应单独出现，不要在索引列进行运算</h4><p>例如 score 列为索引列</p><p>WHERE score * 1.2 &lt; 90    与      WHERE score &lt; 90 /<br>1.2表达的意思完全相同，但是查询效率完全不同。第一个语句会全表扫描，将所有数据乘以1.2然后和90比<br>较，无法使用索引；第二个语句将会通过索引查询score 小于 90/1.2的数据，查询效率较高。</p><h4 id="3-2-联合索引中范围查询导致索引失效"><a href="#3-2-联合索引中范围查询导致索引失效" class="headerlink" title="3.2 联合索引中范围查询导致索引失效"></a>3.2 联合索引中范围查询导致索引失效</h4><p>例如联合索引（a, b, c）</p><p>WHERE a BETWEEN 1 AND 10  AND b = 100;这个语句只会使用联合索引中的a部分，b部分无法使用。</p><h3 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考:"></a>4、参考:</h3><p>[1] <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">http://tech.meituan.com/mysql-index.html</a></p><p>[2] <a href="http://www.uml.org.cn/sjjm/201107145.asp#nav-2-1" target="_blank" rel="noopener"> http://www.uml.org.cn/sjjm/201107145.asp#nav-2-1</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/11/11/%E3%80%90LeetCode%E3%80%91%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98_gas_station/"/>
      <content type="html"><![CDATA[<p>【LeetCode】加油站问题 gas station</p><p>加油站问题解释和分析请看陈立人待字闺中博客 <a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=200400990&amp;idx=1&amp;sn=fad0aaa933a5fdf0f62dcead4a4cb877#rd" target="_blank" rel="noopener"> http://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=2<br>00400990&amp;idx=1&amp;sn=fad0aaa933a5fdf0f62dcead4a4cb877#rd </a></p><p>核心思想是：</p><p>1、总加油量要大于总消耗量。</p><p>2、如果在第 i 站无法到达第 i + 1 站，那么从 i-1，i-2……等第 i 站前面的站开始出发必然都到不了第 i+1<br>站。所以只有可能从第i+1站开始，才有可能走一圈。</p><p>3、如果低 i+1站能够到达第n站，并且总加油量大于总消耗量，那么从 i+1站到第n站结余的油量必然能够满足从0站到 i+1站的需求。（0和n是同一个站）。</p><p>下面是C++代码。</p><pre><code>/***************************************************INPUT*    gas[i]:第i站加油量*    cost:从i站到i+1站消耗量*    len:加油站个数*RETURN*    -1：失败*    start：从第i站出发可以走一圈****************************************************/int canCompleteCircuit(int* gas, int* cost, int len){    if(gas == NULL || cosr == NULL || len &lt;= 0)        return -1;    int tank = 0;    //邮箱油量    int total = 0;  //总加油量-消耗量    int start = 0;  //出发站    for(int i = 0; i &lt; len; i++)    {        tank = gas[i] - cost[i];        total = gas[i] - cost[i];        if(tank &lt; 0)        {            start = (i + 1) % len;            tank = 0        }    }    if(total &lt; 0)        return -1;    else        return start;}</code></pre><p>参考资料：</p><p><a href="http://blog.csdn.net/jellyyin/article/details/12245429" target="_blank" rel="noopener"> http://blog.csdn.net/jellyyin/article/details/12245429</a>  </p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=200400990&amp;idx=1&amp;sn=fad0aaa933a5fdf0f62dcead4a4cb877#rd" target="_blank" rel="noopener"> http://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=200400990&amp;idx=1&amp;sn=fad0<br>aaa933a5fdf0f62dcead4a4cb877#rd </a>  </p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java集合：TreeMap使用详解及源码分析</title>
      <link href="/2017/11/11/Java%E9%9B%86%E5%90%88%EF%BC%9ATreeMap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1 使用方法"></a>1 使用方法</h2><p>TreeMap和HashMap一样是散列表，但是他们内部实现完全不同，TreeMap基于红黑树实现，是一个有序的散列表，而HashMap使用数组加链表实现是<br>无序的。</p><pre><code>public class TreeMap&lt;K,V&gt;        extends AbstractMap&lt;K,V&gt;        implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable {}</code></pre><p>TreeMap继承了AbstractMap，储的是key-value键值对；<br>TreeMap实现了NavigableMap接口，支持多种导航方法，可以精准的获得键值对；<br>TreeMap和HashMap一样实现了Cloneable和Serializable接口，可以复制和序列化。</p><h2 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h2><p>TreeMap提供的API主要有如下：</p><pre><code>Entry&lt;K, V&gt;                ceilingEntry(K key) //返回键不小于key的最小键值对entryK                          ceilingKey(K key) //返回键不小于key的最小键void                       clear() //清空TreeMapObject                     clone() //克隆TreeMapComparator&lt;? super K&gt;      comparator() //比较器boolean                    containsKey(Object key) //是否包含键为key的键值对NavigableSet&lt;K&gt;            descendingKeySet() //获取降序排列key的Set集合NavigableMap&lt;K, V&gt;         descendingMap() //获取降序排列的MapSet&lt;Entry&lt;K, V&gt;&gt;           entrySet() //获取键值对entry的Set集合Entry&lt;K, V&gt;                firstEntry() //第一个entryK                          firstKey() //第一个keyEntry&lt;K, V&gt;                floorEntry(K key) //获取不大于key的最大键值对K                          floorKey(K key) //获取不大于key的最大KeyV                          get(Object key) //获取键为key的值valueNavigableMap&lt;K, V&gt;         headMap(K to, boolean inclusive) //获取从第一个节点开始到to的子Map, inclusive表示是否包含to节点SortedMap&lt;K, V&gt;            headMap(K toExclusive) //获取从第一个节点开始到to的子Map, 不包括toExclusiveEntry&lt;K, V&gt;                higherEntry(K key) //获取键大于key的最小键值对K                          higherKey(K key) //获取键大于key的最小键boolean                    isEmpty() //判空Set&lt;K&gt;                     keySet() //获取key的Set集合Entry&lt;K, V&gt;                lastEntry() //最后一个键值对K                          lastKey() //最后一个键Entry&lt;K, V&gt;                lowerEntry(K key) //键小于key的最大键值对K                          lowerKey(K key) //键小于key的最大键值对NavigableSet&lt;K&gt;            navigableKeySet() //返回key的Set集合Entry&lt;K, V&gt;                pollFirstEntry() //获取第一个节点,并删除Entry&lt;K, V&gt;                pollLastEntry() //获取最后一个节点并删除V                          put(K key, V value) //插入一个节点V                          remove(Object key) //删除键为key的节点int                        size() //Map大小SortedMap&lt;K, V&gt;            subMap(K fromInclusive, K toExclusive) //获取从fromInclusive到toExclusive子Map,前闭后开NavigableMap&lt;K, V&gt;         subMap(K from, boolean fromInclusive, K to, boolean toInclusive)NavigableMap&lt;K, V&gt;         tailMap(K from, boolean inclusive) //获取从from开始到最后的子Map,inclusive标志是否包含fromSortedMap&lt;K, V&gt;            tailMap(K fromInclusive)</code></pre><h3 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h3><pre><code>public void testTreeMap() {    //新建treeMap    TreeMap treeMap = new TreeMap();    //添加元素    treeMap.put(11, &quot;eleven&quot;);    treeMap.put(1, &quot;one&quot;);    treeMap.put(2, &quot;two&quot;);    treeMap.put(3, &quot;three&quot;);    treeMap.put(4, &quot;four&quot;);    //打印元素    this.printMapByEntrySet(treeMap);    //获取大小    System.out.println(&quot;treeMap的大小为: &quot; + treeMap.size());    //是否包含key为4的元素    System.out.println(&quot;treeMap是否包含key为4的元素: &quot; + treeMap.containsKey(4));    //是否包含值为5的元素    System.out.println(&quot;treeMap是否包含value为two的元素: &quot; + treeMap.containsValue(&quot;two&quot;));    treeMap.put(5, &quot;five&quot;);    treeMap.put(6, &quot;six&quot;);    treeMap.put(9, &quot;nine&quot;);    treeMap.put(11, &quot;eleven&quot;);    //获取treeMap中键不小于8最小的entry    System.out.println(&quot;treeMap中键不小于8的最小entry为: &quot; + treeMap.ceilingEntry(8));    //获取第一个entry    System.out.println(&quot;treeMap中第一个entry为: &quot; + treeMap.firstEntry());    //获取从from开始到to结束的子map,前闭后开    System.out.println(&quot;从2开始到9结束的子map为: &quot; + treeMap.subMap(2,9));    //删除元素    System.out.println(&quot;删除key为2的元素: &quot; + treeMap.remove(2));    //获取并删除最后一个元素    System.out.println(&quot;获取并删除最后一个元素&quot; + treeMap.pollLastEntry());    //打印元素    this.printMapByKeySet(treeMap);    //clone    TreeMap cloneMap = (TreeMap) treeMap.clone();    //打印克隆map    System.out.println(&quot;cloneMap的元素为: &quot; + cloneMap);    //清空map    treeMap.clear();    //判空    System.out.println(&quot;treeMap是否为空: &quot; + treeMap.isEmpty());}/** * 根据entrySet()获取Entry集合,然后遍历Set集合获取键值对 * @param map */private void printMapByEntrySet(TreeMap map) {    Integer key = null;    String value = null;    Iterator iterator = map.entrySet().iterator(); //    System.out.print(&quot;treeMap中含有的元素有: &quot;);    while (iterator.hasNext()) {        Map.Entry entry = (Map.Entry) iterator.next();        key = (Integer) entry.getKey();        value = (String) entry.getValue();        System.out.print(&quot;key/value : &quot; + key + &quot;/&quot; + value + &quot; &quot;);    }    System.out.println();}/** * 使用keySet获取key的Set集合,利用key获取值 * @param map */private void printMapByKeySet(TreeMap map) {    Integer key = null;    String value = null;    Iterator iterator = map.keySet().iterator();    System.out.print(&quot;treeMap中含有的元素有: &quot;);    while (iterator.hasNext()) {        key = (Integer) iterator.next();        value = (String) map.get(key);        System.out.print(&quot;key/value : &quot; + key + &quot;/&quot; + value + &quot; &quot;);    }    System.out.println();}</code></pre><p>运行结果如下：</p><pre><code>treeMap中含有的元素有: key/value : 1/one key/value : 2/two key/value : 3/three key/value : 4/four key/value : 11/eleventreeMap的大小为: 5treeMap是否包含key为4的元素: truetreeMap是否包含value为two的元素: truetreeMap中键不小于8的最小entry为: 9=ninetreeMap中第一个entry为: 1=one从2开始到9结束的子map为: {2=two, 3=three, 4=four, 5=five, 6=six}删除key为2的元素: two获取并删除最后一个元素11=eleventreeMap中含有的元素有: key/value : 1/one key/value : 3/three key/value : 4/four key/value : 5/five key/value : 6/six key/value : 9/ninecloneMap的元素为: {1=one, 3=three, 4=four, 5=five, 6=six, 9=nine}treeMap是否为空: true</code></pre><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><h3 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h3><p>TreeMap有四个构造函数，这四个构造函数的区别在于使用什么样的构造器，以及是否要初始化，源码中有注释解释。</p><pre><code>/** * Constructs a new, empty tree map, using the natural ordering of its * keys.  All keys inserted into the map must implement the {@link * Comparable} interface.  Furthermore, all such keys must be * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw * a {@code ClassCastException} for any keys {@code k1} and * {@code k2} in the map.  If the user attempts to put a key into the * map that violates this constraint (for example, the user attempts to * put a string key into a map whose keys are integers), the * {@code put(Object key, Object value)} call will throw a * {@code ClassCastException}. */public TreeMap() {    comparator = null;}/** * Constructs a new, empty tree map, ordered according to the given * comparator.  All keys inserted into the map must be &lt;em&gt;mutually * comparable&lt;/em&gt; by the given comparator: {@code comparator.compare(k1, * k2)} must not throw a {@code ClassCastException} for any keys * {@code k1} and {@code k2} in the map.  If the user attempts to put * a key into the map that violates this constraint, the {@code put(Object * key, Object value)} call will throw a * {@code ClassCastException}. * * @param comparator the comparator that will be used to order this map. *        If {@code null}, the {@linkplain Comparable natural *        ordering} of the keys will be used. */public TreeMap(Comparator&lt;? super K&gt; comparator) {    this.comparator = comparator;}/** * Constructs a new tree map containing the same mappings as the given * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys. * All keys inserted into the new map must implement the {@link * Comparable} interface.  Furthermore, all such keys must be * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw * a {@code ClassCastException} for any keys {@code k1} and * {@code k2} in the map.  This method runs in n*log(n) time. * * @param  m the map whose mappings are to be placed in this map * @throws ClassCastException if the keys in m are not {@link Comparable}, *         or are not mutually comparable * @throws NullPointerException if the specified map is null */public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {    comparator = null;    putAll(m);}/** * Constructs a new tree map containing the same mappings and * using the same ordering as the specified sorted map.  This * method runs in linear time. * * @param  m the sorted map whose mappings are to be placed in this map, *         and whose comparator is to be used to sort this map * @throws NullPointerException if the specified map is null */public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {    comparator = m.comparator();    try {        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);    } catch (java.io.IOException cannotHappen) {    } catch (ClassNotFoundException cannotHappen) {    }}###2.2 put方法/** Associates the specified value with the specified key in this map.* If the map previously contained a mapping for the key, the old* value is replaced.*        * @param key key with which the specified value is to be associated* @param value value to be associated with the specified key*        * @return the previous value associated with {@code key}, or*         {@code null} if there was no mapping for {@code key}.        *         (A {@code null} return can also indicate that the map*         previously associated {@code null} with {@code key}.)        * @throws ClassCastException if the specified key cannot be compared*         with the keys currently in the map* @throws NullPointerException if the specified key is null        *         and this map uses natural ordering, or its comparator*         does not permit null keys*/}public V put(K key, V value) {    Entry&lt;K,V&gt; t = root;    if (t == null) { //空树,插入根节点        compare(key, key); // type (and possibly null) check        root = new Entry&lt;&gt;(key, value, null);        size = 1;        modCount++;        return null;    }    int cmp;    Entry&lt;K,V&gt; parent; //父节点    // split comparator and comparable paths    Comparator&lt;? super K&gt; cpr = comparator;    if (cpr != null) { //如果有自定义的比较器则使用自定义比较器比较key        do {            parent = t;            cmp = cpr.compare(key, t.key); //首先比较父节点            if (cmp &lt; 0) //比父节点小,则比较左孩子                t = t.left;            else if (cmp &gt; 0) //比父节点大比较则比较右孩子                t = t.right;            else                return t.setValue(value); //键相同则替换原value        } while (t != null); //t==null时则找到要插入的节点    }    else {        if (key == null) //同上            throw new NullPointerException();        @SuppressWarnings(&quot;unchecked&quot;)        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;        do {            parent = t;            cmp = k.compareTo(t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        } while (t != null);    }    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //插入的节点    if (cmp &lt; 0) //比较为小于0,则将新节点设为上一个t的左孩子,反之右孩子        parent.left = e;    else        parent.right = e;    fixAfterInsertion(e); //恢复红黑数的特性    size++;    modCount++;    return null;}</code></pre><h3 id="2-3-get方法"><a href="#2-3-get方法" class="headerlink" title="2.3 get方法"></a>2.3 get方法</h3><pre><code>/** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code key} compares * equal to {@code k} according to the map&apos;s ordering, then this * method returns {@code v}; otherwise it returns {@code null}. * (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;em&gt;necessarily&lt;/em&gt; * indicate that the map contains no mapping for the key; it&apos;s also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @throws ClassCastException if the specified key cannot be compared *         with the keys currently in the map * @throws NullPointerException if the specified key is null *         and this map uses natural ordering, or its comparator *         does not permit null keys */public V get(Object key) {    Entry&lt;K,V&gt; p = getEntry(key);    return (p==null ? null : p.value);}final Entry&lt;K,V&gt; getEntry(Object key) {    // Offload comparator-based version for sake of performance    if (comparator != null)        return getEntryUsingComparator(key); //有比较器,大部分情况下都是没有比较器的,所以拆出来    if (key == null)        throw new NullPointerException();    @SuppressWarnings(&quot;unchecked&quot;)    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;    Entry&lt;K,V&gt; p = root;    while (p != null) {        int cmp = k.compareTo(p.key);        if (cmp &lt; 0)            p = p.left;        else if (cmp &gt; 0)            p = p.right;        else            return p;    }    return null;}/** * Version of getEntry using comparator. Split off from getEntry * for performance. (This is not worth doing for most methods, * that are less dependent on comparator performance, but is * worthwhile here.) */final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {    @SuppressWarnings(&quot;unchecked&quot;)    K k = (K) key;    Comparator&lt;? super K&gt; cpr = comparator;    if (cpr != null) {        Entry&lt;K,V&gt; p = root;        while (p != null) {            int cmp = cpr.compare(k, p.key);            if (cmp &lt; 0)                p = p.left;            else if (cmp &gt; 0)                p = p.right;            else                return p;        }    }    return null;}</code></pre><p>2.4 remove方法</p><pre><code>/** * Removes the mapping for this key from this TreeMap if present. * * @param  key key for which mapping should be removed * @return the previous value associated with {@code key}, or *         {@code null} if there was no mapping for {@code key}. *         (A {@code null} return can also indicate that the map *         previously associated {@code null} with {@code key}.) * @throws ClassCastException if the specified key cannot be compared *         with the keys currently in the map * @throws NullPointerException if the specified key is null *         and this map uses natural ordering, or its comparator *         does not permit null keys */public V remove(Object key) {    Entry&lt;K,V&gt; p = getEntry(key); //获取节点    if (p == null)        return null;    V oldValue = p.value;    deleteEntry(p); //删除节点    return oldValue;}/** * Delete node p, and then rebalance the tree. */private void deleteEntry(Entry&lt;K,V&gt; p) {    modCount++;    size--;    // If strictly internal, copy successor&apos;s element to p and then make p    // point to successor.    if (p.left != null &amp;&amp; p.right != null) { //有左右孩子, 则将后继节点的值复制给父节点,然后处理他的后继节点        Entry&lt;K,V&gt; s = successor(p); //获取后继节点        p.key = s.key;        p.value = s.value;        p = s;    } // p has 2 children    // Start fixup at replacement node, if it exists.    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);    if (replacement != null) { //后继节点有子节点        // Link replacement to parent        replacement.parent = p.parent; //将 后继节点的子节点的父节点 设置为后继节点的父节点        if (p.parent == null) //后继节点为根节点            root = replacement;        else if (p == p.parent.left)            p.parent.left  = replacement;        else            p.parent.right = replacement;        // Null out links so they are OK to use by fixAfterDeletion.        p.left = p.right = p.parent = null; //删除掉后继节点, help GC        // Fix replacement        if (p.color == BLACK) //如果后继节点的颜色为黑色            //根据红黑树的特性&quot;从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点&quot;, 删除的黑节点,会破坏平衡性            fixAfterDeletion(replacement); //重新染色, 平衡的红黑树    } else if (p.parent == null) { // return if we are the only node.        root = null;    } else { //  No children. Use self as phantom replacement and unlink.        if (p.color == BLACK)            fixAfterDeletion(p);        if (p.parent != null) {            if (p == p.parent.left)                p.parent.left = null;            else if (p == p.parent.right)                p.parent.right = null;            p.parent = null;        }    }}/** * 红黑树的后继节点为 * 1 如果有右孩子, 则为右孩子的最深左孩子 * 2 如果没有右孩子, 则为最浅的以t为右子树节点的节点 * Returns the successor of the specified Entry, or null if no such. */static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {    if (t == null)        return null;    else if (t.right != null) {        Entry&lt;K,V&gt; p = t.right;        while (p.left != null)            p = p.left;        return p;    } else {        Entry&lt;K,V&gt; p = t.parent;        Entry&lt;K,V&gt; ch = t;        while (p != null &amp;&amp; ch == p.right) {            ch = p;            p = p.parent;        }        return p;    }}</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener"> http://www.cnblogs.com/skywang12345/p/3310928.html</a></p><p>[2] <a href="http://blog.csdn.net/ns_code/article/details/36421085" target="_blank" rel="noopener"> http://blog.csdn.net/ns_code/article/details/36421085</a></p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>节约内存：Instagram的Redis实践</title>
      <link href="/2015/01/01/%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98%EF%BC%9AInstagram%E7%9A%84Redis%E5%AE%9E%E8%B7%B5/"/>
      <content type="html"><![CDATA[<p>Instagram  可以说是网拍App的始祖级应用，也是当前最火热的拍照App之一，Instagram的照片数量已经达到3亿，而在Instagram里，我们需要知道每一张照片的作者是谁，下面就是Instagram团队如何使用Redis来解决这个问题并进行内存优化的。</p><p>首先，这个通过图片ID反查用户UID的应用有以下几点需求：</p><ul><li>查询速度要足够快 </li><li>数据要能全部放到内存里，最好是一台EC2的 high-memory 机型就能存储（17GB或者34GB的，68GB的太浪费了） </li><li>要合适Instagram现有的架构（Instagram对  <a href="http://blog.nosqlfan.com/categories/redis" target="_blank" rel="noopener"> Redis </a> 有一定的使用经验，比如 <a href="http://blog.nosqlfan.com/html/2007.html" target="_blank" rel="noopener"> 这个应用 </a> ） </li><li>支持持久化，这样在服务器重启后不需要再预热 </li></ul><p>Instagram的开发者首先否定了数据库存储的方案，他们保持了KISS原则（Keep It Simple and<br>Stupid），因为这个应用根本用不到数据库的update功能，事务功能和关联查询等等牛X功能，所以不必为这些用不到的功能去选择维护一个数据库。</p><p>于是他们选择了Redis，Redis是一个支持持久化的内存数据库，所有的数据都被存储在内存中（忘掉VM吧<br>），而最简单的实现就是使用Redis的String结构来做一个key-value存储就行了。像这样：</p><pre><code>SET media:1155315 939GET media:1155315&gt; 939</code></pre><p>其中1155315是图片ID，939是用户ID，我们将每一张图片ID为作key，用户uid作为value来存成key-value对。然后他们进行了测试，将数<br>据按上面的方法存储，1,000,000数据会用掉70MB内存，300,000,000张照片就会用掉21GB的内存。对比预算的17GB还是超支了。</p><p>（  NoSQLFan：  其实这里我们可以看到一个优化点，我们可以将key值前面相同的media去掉，只存数字，这样key的长度就减少了，减少key值对内<br>存的开销【注：Redis的key值不会做字符串到数字的转换，所以这里节省的，仅仅是media:这6个字节的开销】。经过实验，  <a href="http://blog.nosqlfan.com/categories/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8" target="_blank" rel="noopener"> 内存占用</a><br>会降到50MB，总的内存占用是15GB，是满足需求的，但是Instagram后面的改进任然有必要  ）</p><p>于是Instagram的开发者向Redis的开发者之一 <a href="https://twitter.com/#!/pnoordhuis" target="_blank" rel="noopener"> Pieter Noordhuis</a> 询问优化方案，得到的回复是使用Hash结构。具体的做法就是将数据分段，每一段使用一<br>个Hash结构存储，由于Hash结构会在单个Hash元素在不足一定数量时进行压缩存储，所以可以大量  <a href="http://blog.nosqlfan.com/categories/%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98" target="_blank" rel="noopener"> 节约内存</a><br>。这一点在上面的String结构里是不存在的。而这个一定数量是由配置文件中的  <a href="http://blog.nosqlfan.com/categories/hash" target="_blank" rel="noopener"> hash</a> -zipmap-max-entries参数来控制的。经过开发者们的实验<br>，将hash-zipmap-max-entries设置为1000时，性能比较好，超过1000后HSET命令就会导致CPU消耗变得非常大。</p><p>于是他们改变了方案，将数据存成如下结构：</p><pre><code>HSET &quot;mediabucket:1155&quot; &quot;1155315&quot; &quot;939&quot;HGET &quot;mediabucket:1155&quot; &quot;1155315&quot;&gt; &quot;939&quot;</code></pre><p>通过取7位的图片ID的前四位为Hash结构的key值，保证了每个Hash内部只包含3位的key，也就是1000个。</p><p>再做一次实验，结果是每1,000,000个key只消耗了16MB的内存。总内存使用也降到了5GB，满足了应用需求。</p><p>（  NoSQLFan：同样的，这里我们还是可以再进行优化，首先是将Hash结构的key值变成纯数字，这样key长度减少了12个字节，其次是将Hash结构中<br>的subkey值变成三位数，这又减少了4个字节的开销，如下所示。经过实验，内存占用量会降到10MB，总内存占用为3GB  ）</p><pre><code>HSET &quot;1155&quot; &quot;315&quot; &quot;939&quot;HGET &quot;1155&quot; &quot;315&quot;&gt; &quot;939&quot;</code></pre><p>优化无止境，只要肯琢磨。希望你在使用存储产品时也能如此爱惜内存。</p><p>来源： <a href="http://instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value-pairs" target="_blank" rel="noopener"> instagram-engineering.tumblr.com </a></p><p>From: <a href="http://blog.nosqlfan.com/html/3379.html" target="_blank" rel="noopener">http://blog.nosqlfan.com/html/3379.html</a></p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则表达式DFA构造方法</title>
      <link href="/2015/01/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FDFA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>陈梓瀚 <a href="mailto:vczh@163.com" target="_blank" rel="noopener"> vczh@163.com </a> <a href="http://www.cppblog.com/vczh/" target="_blank" rel="noopener"> http://www.cppblog.com/vczh/</a></p><p><strong> 1、问题概述  </strong></p><hr><p>随着计算机语言的结构越来越复杂，为了开发优秀的编译器，人们已经渐渐感到将词法分析独立出来做研究的重要性。不过词法分析器的作用却不限于此。回想一下我们的老师刚<br>刚开始向我们讲述程序设计的时候，总是会出一道题目：给出一个填入了四则运算式子的字符串，写程序计算该式子的结果。除此之外，我们有时候建立了比较复杂的配置文件，<br>譬如XML的时候，分析器首先也要对该文件进行词法分析，把整个字符串断成了一个一个比较短小的记号(指的是具有某种属性的字符串)，之后才进行结构上的分析。再者，<br>在实现某种控制台应用程序的时候，程序需要分析用户打进屏幕的命令。如果该命令足够复杂的话，我们也首先要对这个命令进行词法分析，之后得到的结果会大大方便进行接下<br>去的工作。</p><p>当然，这些问题大部分已经得到了解决，而且历史上也有人做出了各种各样专门的或者通用的工具(Lex、正则表达式引擎等)来解决这一类问题。我们在使用这种工具的时候<br>，为了更加高效地书写配置，或者我们在某种特殊情况下需要自己制作类似的工具，就需要了解词法分析背后的原理。本文将给出一个构造通用词法分析工具所需要的原理。由于<br>实现的代码过长，本文将不附带实现。</p><p>究竟什么是“把一个字符串断成一些记号”呢？我们先从四则运算式子入手。一个四则运算式子是一个字符数列，可是我们关心的对象实际上是操作符、括号和数字。于是此法分<br>析的作用就是把一个字符串断开成我们关心的带有属性的记号。举个例子：(11+22)<em>(33+44)是一个合法的四则运算式子，如果输入是(左括号,”(“)<br>(数字,”11”) (一级操作符,”+”) (数字,”22”) (右括号,”)”) (二级操作符,”</em>”) (左括号,”(“) (数字,”33”)<br>(一级操作符,”+”) (数字,”44”) (右括号,”)”)的话，我们在检查结构的时候只需要关心这个记号的属性(也就是左括号、右括号、数字、操作符等)就行<br>了，具体计算的时候才需要关心这个记号实际上的内容。如果式子里边有空格的话，我们也仅仅需要把空格当成是一种记号类型，在词法分析得出结果之后，将具有空格属性的记<br>号丢弃掉就可以了，接下去的步骤不需变化。</p><p>但需要注意的是，词法分析得到的结果是没有层次结构的，所有的记号都是等价的对象。我们在计算表达式的时候把+和*看成了不同层次的操作符，类似的结构是具有嵌套的层<br>次的。词法分析不能得出嵌套层次结构的信息，最多只能得到关于重复结构的信息。</p><p><strong> 2、正则表达式  </strong></p><p>我们现在需要寻找一种可以描述记号类型的工具，在此之前我们首先研究一下常见的记号的结构。为了表示出具有某种共性的字符串的集合，我们需要书写出一些能代表字符串集<br>合的规则。这个集合中的所有成员都将被认为是一种特定类型的记号。</p><p><strong> 首先，规则可以把一个特定的字符或者是空字符串认为是一种类型的记号的全部。 </strong> 上文所说到的四则运算式子的例子，“左括号”这种类型的记号就仅仅对应着字符”(“，其他的字符或者字符串都不可能是“左括号”这个类型的记号。 </p><p><strong> 其次，规则可以进行串联。 </strong> 串联的意思是这样的，我们可以让一个字符串的前缀符合某一个指定的规则，剩下的部分的前缀符合第二个规则，剩下的部分的前缀符合第三个规则等等，一直到最后一个部分的全部要符合最后一个规则。如果我们把”function”这个字符串作为一个记号类型来处理的话，我们可以把”function”这个字符串替换成8个串联的规则：”f”,”u”,”n”,”c”,”t”,”i”,”o”,”n”。首先，字符串”function”的前缀”f”符合规则”f”，剩下的部分”unction”的前缀”u”符合规则”u”，等等，一直到最后一个部分”n”的全部符合规则”n”。 </p><p><strong> 第三，规则可以进行并联。 </strong> 并联的意思就是，如果一个字符串符合一系列规则中的其中一个的话，我们就说这个字符串符合这一些规则的并联。于是这些规则的并联就构成了一个新的规则。一个典型的例子就是判断一个字符串是否关键字。关键字可以是”if”，可以是”else”，可以是”while”等等。当然，一个关键字是不可能同时符合这些规则的，不过只要一个字符串符合这些规则的其中一个的话，我们就说这个字符串是关键字。于是，关键字这个规则就是”if”、”else”、”while”等规则的并联。 </p><p><strong> 第四，一个规则可以是可选的。 </strong> 可选的规则实际上是属于并联的一种特殊形式。加入我们需要规则”abc”和”abcde”并联，我们会发现这两个规则有着相同的前缀”abc”，而且这个前缀恰好就是其中的一个规则。于是我们可以把规则改写成”abc”与””和”de”的并联的串联。但是规则””指定的规则是空串，因此这个规则与”de”的并联就可以看成是一个可选的规则”de”。 </p><p><strong> 第五，规则可以被重复。 </strong> 有限次的重复可以使用串联表示，但是如果我们不想限制重复的次数的话，串联就没法表示这个规则了，于是我们引入了“重复”。一个典型的例子就是程序设计语言的标识符。标识符可以是一个变量的名字或者是其他东西。一门语言通常没有规定变量名的最大长度。因此为了表示这个规则，就需要将52个字母进行并联，然后对这个规则进行重复。 </p><p>上述的5种构造规则的方法中，后面的4个方法被用于把规则组合成为更大的规则。为了给出这种规则的形式化表示，我们引入了一种范式。这种范式有以下语法：</p><p>1：字符用双引号包围起来，空串使用ε代替。</p><p>2：两个规则头尾连接代表规则的串联。</p><p>3：两个规则使用 | 隔开代表规则的并联。</p><p>4：规则使用[]包围代表该规则是可选的，规则使用{}包围代表该规则是重复的。</p><p>5：规则使用()包围代表该规则是一个整体，通常用于改变操作符 | 的优先级。</p><p>举个例子，一个实数的规则书写如下：</p><p>{“0”|”1”|”2”|”3”|”4”|”5”|”6”|”7”|”8”|”9”}”.”[{“0”|”1”|”2”|”3”|”4”|”5”|”6”|”7”|<br>”8”|”9”}]。</p><p>但是，我们如何表示“不是数字的其他字符呢”？字符的数量是有限的，因此我们可以使用规则的并联来表示。但是所有的字符实在是太多（ASCII字符集有127个字符<br>，UTF-16字符集有65535个字符），因此后来人们想出了各种各样的简化规则书写的办法。比较著名的有BNF范式。BNF范式经常被用于理论研究，但是更加实用<br>的是正则表达式。</p><p>正则表达式的字符不需要用双引号括起来，但是如果需要表示一些被定义了的字符(如 “|” )的话，就使用转义字符的方法表示(如 “/|”)。其次，X?代表[X]<br>，X+代表{X}，X*代表[{X}]。字符集合可以用区间来表示，[0-9]可以表示“0”|”1”|”2”|”3”|”4”|”5”|”6”|”7”|”8”|”<br>9”，[^0-9]则表示“除了数字以外的其他字符”。正则表达式还有各种各样的其他规则来简化我们的书写，不过由于本文并不是“精通正则表达式”，因此我们只保留若<br>干比较本质的操作来进行词法分析原理的描述。</p><p>正则表达式的表达能力极强，小数的规则可以使用[0-9]+.[0-9]来表示，C语言的注释可以表示为//<em>([^/</em>]|/<em>+[^/</em>/])<em>/</em>+/来表示。</p><p>3、有穷状态自动机</p><p>人阅读正则表达式会比较简单，但是机器阅读正则表达式就是一件非常困难的事情了。而且，直接使用正则表达式进行匹配配的话，不仅工作量大，而且速度缓慢。因此我们还需<br>要另外一种专门为机器设计的表达方式。本文在以后的章节中会给出一种算法把正则表达式转换为机器可以阅读的形式，就是这一章节所描述的有穷状态自动机。</p><p>有穷状态自动机这个名字听起来比较可怕，不过实际上这种自动机并没有想象中的那么复杂。状态机的这种概念被广泛的应用在各种各样的领域中。软件工程的统一建模语言(U<br>ML)有状态图，数字逻辑中也有状态转移图。不过这些各种各样的图在本质上都跟状态机没有什么区别。我将会通过一个例子来讲述状态的实际意义。</p><p>假设我们现在需要检查一个字符串中a的数量和b的数量是否都是偶数。当然我们可以用一个正则表达式来描述它。不过对于这个问题来说，用正则表达式来描述远远不如构造状<br>态机方便。我们可以设计出一个状态的集合，然后指定集合中的某一个元素为“起始状态”。其实状态就是在工作还没开始的时候，分析器所处的状态。分析器在每一次进行一项<br>新的工作的时候，都要把状态重置为起始状态。分析器每读入一个字符就修改一次状态，修改的方法我们也可以指定。分析器在读完所有的字符以后，必然停留在一个确定的状态<br>中。如果这个状态跟我们所期望的状态一致的话，我们就说这个分析器接受了这个字符串，否则我们就说这个分析器拒绝了这个字符串。</p><p>如何通过设计状态及其转移方法来实现一个分析器呢？当然，如果一个字符串仅仅包含a或者b的话，那么分析器的状态只有四种：“奇数a奇数b”、“奇数a偶数b”、“偶<br>数a奇数b”、“偶数a偶数 b”。我们把这些状态依次命名为aa、aB、Ab、AB。大写代表偶数，小写代表奇数。当工作还没开始的时候，分析器已经读入的字符串是<br>空串，那么理所当然的起始状态应当是AB。当分析器读完所有字符的时候，我们期望读入的字符串的a和b的数量都是偶数，那么结束的状态也应该是AB。于是我们给出这样<br>的一个状态图：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image001_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image001_thumb.jpg" alt="clip_image001"> </a></p><p>图3.1</p><p>检查一个字符串是否由偶数个a和偶数个b组成的状态图</p><p>在这个状态图里，有一个短小的箭头指向了AB，代表AB这个状态是初始状态。AB状态有粗的边缘，代表AB这个状态是结束的可接受状态。一个状态图的结束状态可以是一<br>个或者多个。在这个例子里，起始状态和结束状态刚好是同一个状态。标有字符”a”的箭头从AB指向aB，代表如果分析器处于状态AB并且读入的字符是a的话，就转移到<br>状态aB上。</p><p>我们把这个状态图应用在两个字符串上，分别是”abaabbba”和”aababbaba”。其中，第一个字符串是可以接受的，第二个字符串是不可接受的(因为有5个<br>a和4个b)。</p><p>分析第一个字符串的时候，状态机所经过的状态是：</p><p><strong> AB </strong> [a]aB[b]ab[a]Ab[a]ab[b]aB[b]ab[b]aB[a] <strong> AB </strong></p><p>分析第二个字符串的时候，状态机所经过的状态是：</p><p><strong> AB </strong> [a]aB[a] <strong> AB </strong> [b]Ab[a]ab[b]aB[b]ab[a]Ab[b] <strong> AB </strong> [a]aB </p><p>第一个字符串”abaabbba”让状态机在状态AB上停了下来，于是这个字符串是可以接受的。第二个字符串”aababbaba”让状态机在状态aB上停了下来，于<br>是这个字符串是不可以接受的。</p><p>在机器内部表示这个状态图的话，我们可以使用一种比较简单的方法。这种方法仅仅把状态与状态之间的箭头、起始状态和结束状态集合记录下来。对应于这个状态图的话，我们<br>就可以把这个状态图表示成以下形式：</p><p>起始状态：AB</p><p>结束状态集合：AB</p><p>(AB,a,aB)</p><p>(AB,b,Ab)</p><p>(aB,a,AB)</p><p>(aB,b,ab)</p><p>(Ab,a,ab)</p><p>(Ab,b,AB)</p><p>(ab,a,Ab)</p><p>(ab,b,aB)</p><p>用一个状态图来表示状态机的时候有时候会遇到确定性与非确定性的问题。所谓的确定性就是指对于任何一个状态，输入一个字符都可以跳转到另一个确定的状态中去。确定性和<br>非确定性的区别有一个直观的描述：状态图的任何一个状态都可以有不定数量的边指向另一个状态，如果在这些边里面，存在两条边，它们所承载的字符如果相同，那么这个状态<br>输入这个就字符可以跳转到另外两个状态中去，于是该状态机就是不确定的。如图所示：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image002_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image002_thumb.jpg" alt="clip_image002"> </a></p><p>图3.2</p><p>正则表达式ba*b的一个确定的状态机表示</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image003_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image003_thumb.jpg" alt="clip_image003"> </a></p><p>图3.3</p><p>正则表达式ba*b的一个非确定的状态机表示</p><p>图3.3中的状态机的起始状态读入字符b后可以跳转到中间的两个状态里，因此这个状态机是非确定的。相反，图3.2中的状态机，虽然功能跟图3.3的状态机一致，但却<br>是确定的。我们还可以使用一种特殊的边来进行状态的转换。我们用ε边来表示一个状态可以 <strong> 不读入字符就跳转到另一个状态 </strong><br>上。下图给出了一个跟图3.3功能一致的包含ε边的非确定的状态机：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image005_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image005_thumb.jpg" alt="clip_image005"> </a></p><p>图3.4</p><p>正则表达式ba*b的一个带有ε边的非确定的状态机</p><p>在教科书中，通常把确定的有穷状态自动机(有穷状态自动机也就是本文讨论的这种状态机)称为DFA，把非确定的有穷状态自动机称为NFA<br>，把带有ε边的非确定的状态机称为ε-NFA。下文中也将采用这几个术语来指示各种类型的有穷状态自动机。</p><p>在刚刚接触到ε边的时候，一个通常的疑问就是这种边存在的理由。事实上如果是人直接画状态机的话，有时候也可以直接画出一个确定的状态机，复杂一点的话也可以画出一个<br>非确定的状态机，在有些极端的情况下我们需要使用ε边来更加简洁的表示我们的意图。不过ε边存在的最大的理由就是<br>：我们可以通过使用ε边来给出一个简洁的算法把一个正则表达式转换成ε-NFA。</p><p>4、从正则表达式到ε-NFA</p><p>通过第二节所描述的内容，我们知道一个正则表达式的基本元素就是字符集。通过对规则的串联、并联、重复、可选等操作，我们可以构造除更复杂的正则表达式。如果从正则表<br>达式构造状态机的时候也可以用这几种操作对状态图进行组合的话，那么方法将会变得很简单。接下来我们将一一对这5个构造正则表达式的方法进行讨论<br>。使用下文描述的算法构造出来的所有ε-NFA都 <strong> 有且只有一个结束状态 </strong> 。</p><p><strong> 1：字符集 </strong></p><p>字符集是正则表达式最基本的元素，因此反映到状态图上，字符集也会是构成状态图的基本元素。对于字符集C，如果有一个规则只接受C的话，这个规则对应的状态图将会被构<br>造成以下形式：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image006_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image006_thumb.jpg" alt="clip_image006"> </a></p><p>图4.1</p><p>这个状态图的初始状态是Start，结束状态是End。Start状态读入字符集C跳转到End状态，不接受其他字符集。</p><p><strong> 2：串联 </strong></p><p>如果我们使用A⊙B表示规则A和规则B的串联，我们可以很容易的知道串联这个操作具有结合性，也就是说(A⊙B)⊙C=A⊙(B⊙C)。因此对于n个规则的串联<br>，我们只需要先将前n-1个规则进行串连，然后把得到的规则看成一个整体，跟最后一个规则进行串联，那么就得到了所有规则的串联。如果我们知道如何将两个规则串联起来<br>的话，也就等于知道了如何把n个规则进行串联。</p><p>为了将两个串联的规则转换成一个状态图，我们只需要先将这两个规则转换成状态图，然后让第一个状态的结束状态跳转到第二个状态图的起始状态。这种跳转必须是不读入字符<br>的跳转，也就是令这两个状态等价。因此，第一个状态图跳转到了结束状态的时候，就可以当成第二个状态图的起始状态，继续第二个规则的检查。因此我们使用了ε边连接两个<br>状态图：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image007_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image007_thumb.jpg" alt="clip_image007"> </a></p><p>图4.2</p><p><strong> 3：并联 </strong></p><p>并联的方法跟串联类似。为了可以在起始状态读入一个字符的时候就知道这个字符可能走的是并联的哪一些分支并进行跳转，我们需要先把所有分支的状态图构造出来，然后把起<br>始状态连接到所有分支的起始状态上。而且，在某个分支成功接受了一段字符串之后，为了让那个状态图的结束状态反映在整个状态图的结束状态上，我们也把所有分支的结束状<br>态都连接到大规则的结束状态上。如下所示：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image009_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image009_thumb.jpg" alt="clip_image009"> </a></p><p>图4.3</p><p><strong> 4：重复 </strong></p><p>对于一个重复，我们可以设立两个状态。第一个状态是起始状态，第二个状态是结束状态。当状态走到结束状态的时候，如果遇到一个可以让规则接受的字符串，则再次回到结束<br>状态。这样的话就可以用一个状态图来表示重复了。于是对于重复，我们可以构造状态图如下所示：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image010_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image010_thumb.jpg" alt="clip_image010"> </a></p><p>图4.4</p><p><strong> 5：可选 </strong></p><p>为可选操作建立状态图比较简单。为了完成可选操作，我们需要在接受一个字符的时候，如果字符串的前缀被当前规则接受则走当前规则的状态图，如果可选规则的后续规则接受<br>了字符串则走后续规则的状态图，如果都接受的话就两个图都要走。为了达到这个目的，我们把规则的状态图的起始状态和结束状态连接起来，得到了如下状态图：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image011_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image011_thumb.jpg" alt="clip_image011"> </a></p><p>图4.5</p><p>如果重复使用的是0次以上重复，也就是原来的重复加上可选的结果，那么可以简单地把图4.4的Start状态去掉，让End状态同时拥有起始状态和结束状态两个角色，<br>[Start]和[End]则保持原状。</p><p>至此，我们已经将5种构造状态图的办法都对应到了5种构造规则的办法上了。对于任意的一个正则表达式，我们仅需要把这个表达式还原成那5种构造的嵌套，然后把每一步构<br>造都对应到一个状态图的构造上，就可以将一个正则表达式转换成一个ε-NFA了。举个例子，我们使用正则表达式来表达“一个字符串仅包含偶数个a和偶数个b<br>”，然后把它转换成ε-NFA。</p><p>我们先对这个问题进行分析。如果一个字符串仅包含偶数个a和偶数个b的话，那么这个字符串一定是偶数长度的。于是我们可以把这个字符串分割成两个两个的字符段。而且这<br>些字符段只有四种：aa、bb、ab和ba。对于aa和bb来说，无论出现多少次都不会影响字符串中a和b的数量的奇偶性(理由：在一个模2加法系统里，0是不变项，<br>也就是说对于任何属于模2加法的数X有X+0 = 0+X = X)。对于ab和ba的话，如果一个字符串的开始和结束是ab或者ba，中间的部分是aa或者bb的任<br>意组合，这个字符串也是具有偶数个a和偶数个b的。我们现在得到了两种构造偶数个a和偶数个b的字符串的方法。把串联、并联、可选、重复等操作应用在这些字符串上，仍<br>然会得到具有偶数个a和偶数个b的字符串。于是我们可以把正则表达式书写成以下形式：</p><p>((aa|bb)|((ab|ba)(aa|bb)<em>(ab|ba)))</em></p><p>根据上文提到的方法，我们可以把这个正则表达式转换成以下状态机：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image013_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image013_thumb.jpg" alt="clip_image013"> </a></p><p>图4.6</p><p>至此，我们已经得到了把一个正则表达式转换为ε-NFA的方法了。但是只得到ε-NFA还是不行的，因为ε-NFA的不确定性太大了，直接根据ε-<br>NFA跑的话，每一次都会得到大量的临时状态集合，会极大地降低效率。因此，我们还需要一个办法消除一个状态机的非确定性。</p><p>5、消除非确定性</p><p><strong> 消除ε边算法  </strong></p><p>我们见到的有穷状态自动机一共有三种：ε-NFA、NFA和DFA。现在我们需要将ε-NFA转换为DFA。一个DFA中不可能出现ε边，所以我们首先要消除ε边。消<br>除ε边算法基于一个很简单的想法：如果状态A通过ε边到达状态B的话，那么状态A无需读入字符就可以直达状态B。如果状态B需要读入字符x才可以到达状态C的话，那么<br>状态A读入x也可以到达状态C。因为从A到C的路径是A B C，其中A到B不需要读入字符。</p><p>于是我们会得到一个很自然的想法：消除从状态A出发的ε边，只需要寻找所有从A开始仅通过ε边就可以到达的状态，并把从这些状态触出发的非ε边复制到A上即可。剩下的<br>工作就是删除所有的ε边和一些因为消除ε边而变得不可到达的状态。为了更加形象地描述消除ε边算法，我们从正则表达式(ab|cd)*构造一个ε-<br>NFA，并在此状态机上应用消除ε边算法。</p><p>正则表达式(ab|cd)*的状态图如下所示：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image015_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image015_thumb.jpg" alt="clip_image015"> </a></p><p>图5.1</p><p><strong> 1：找到所有有效状态。 </strong></p><p>有效状态就是在完成了消除ε边算法之后仍然存在的状态。我们可以在开始整个算法之前就预先计算出所有有效状态。有效状态的特点是存在非ε边的输入。同时，起始状态也是<br>一个有效状态。结束状态不一定是有效状态，但是如果存在一个有效状态可以仅通过ε边到达结束状态的话，那么这个状态应该被标记为结束状态。因此对一个ε-<br>NFA应用消除ε边算法产生的NFA可能出现多个结束状态。不过起始状态仍然只有一个。</p><p>我们可以把“存在非ε边的输入或者起始状态”这个判断方法应用在图5.1每一个状态上，计算出图5.1中所有的有效状态。结果如下图所示。</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image017_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image017_thumb.jpg" alt="clip_image017"> </a></p><p>图5.2</p><p>所有非有效状态的标签都被删除</p><p>如果一个状态同时具有ε边和非ε边输入的话，那么这个状态仍然是有效状态。因为所有的有效状态在下一步的操作中，都会得到新的输出和新的输入。</p><p><strong> 2：添加所有必要的边 </strong></p><p>接下来我们要对所有的有效状态都应用一个算法。这个算法分成两步。第一步是寻找一个状态的ε闭包，第二步是把这个状态的ε闭包看成一个整体，把所有从这个闭包中输出的<br>边全部复制到当前状态上。从标记有效状态的结果我们得到了图5.1状态图的有效状态集合是{S/E 3 5 7<br>9}。我们依次对这些状态应用上述算法。第一步，计算S/E状态的ε闭包。 <strong> 所谓一个状态的ε闭包就是从这个状态出发，仅通过ε边就可以到达的所有状态的集合。</strong> 下图中标记出了状态S/E的ε闭包：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image019_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image019_thumb.jpg" alt="clip_image019"> </a></p><p>图5.3</p><p>现在，我们把状态S/E从状态S/E的ε闭包中排除出去。因为从状态A输出的非ε边都属于从状态A的ε闭包中输出的非ε边，复制这些边是没有任何价值的。接下来就是找<br>到从状态S/E的ε闭包中输出的非ε边。在图5.3我们可以很容易地发现，从状态1和状态6(见图5.1的状态标签)分别输出到状态3和状态7的标记了a或者b的边，<br>就是我们所要寻找的边。接下来我们把这些边复制到状态S/E上，边的目标状态仍然保持不变，可以得到下图：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image021_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image021_thumb.jpg" alt="clip_image021"> </a></p><p>图5.4</p><p>至此，这个算法在S/E上的应用就结束了，接下来我们分别对剩下的有效状态{3 5 7 9}分别应用此算法，可以得到下图：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image023_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image023_thumb.jpg" alt="clip_image023"> </a></p><p>图5.5</p><p>红色的边为新增加的边</p><p><strong> 3：删除所有ε边和无效状态 </strong></p><p>这一步操作是消除ε边算法的最后步骤。我们只需要删除所有的ε边和无效状态就完成了整个消除ε边算法。现在我们对图5.5的状态机应用第三步，得到如下状态图：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image024_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image024_thumb.jpg" alt="clip_image024"> </a></p><p>图5.6</p><p>不过并不是只有新增的边才不被删除。根据定义，所有从有效状态出发的非ε边都是不能删除的边。</p><p>我们通过把消除ε边算法应用在图5.1的状态机上，得到了图5.6这个DFA。但是 <strong> 并不是所有的消除ε边算法都可以直接从ε-NFA直接得到DFA </strong><br>，这个其实跟正则表达式本身有关。至于什么正则表达式可以达到这个效果这里就不深究了。但是因为有可能产生NFA，所以我们还需要一个算法把NFA转换成DFA。</p><p><strong> 从NFA到DFA </strong></p><p>NFA是非确定性的状态机，DFA是确定性的状态机。确定性和非确定性的最大区别就是：从一个状态读入一个字符，确定性的状态机得到一个状态，而非确定性的状态机得到<br>一个状态的集合。如果我们把NFA的起始状态S看成一个集合{S}的话，对于一个状态集合S’，给定一个输入，就可以用NFA计算出对应的状态集合T’。因此我们在构<br>造DFA的时候，只需要把起始状态对应到S’，并且找到所有可能在NFA同时出现的状态集合，把这些集合都转换成DFA的一个状态，那么任务就完成了。因为NFA的状<br>态是有限的，所以NFA所有状态的集合的幂集的元素个数也是有限的，因此使用这个方法构造DFA是完全可能的。</p><p>为了形象地表达出这个算法的过程，我们将构造一个正则表达式，然后给出该正则表达式转换成NFA的结果，并把构造DFA的算法应用在NFA上。假设一个字符串只有a、<br>b和c三种字符，判断一个字符串是不是以abc开始并且以cba结束正则表达式如下：</p><p>abc(a|b|c)*cba</p><p>通过上文的算法，可以得出如下图所示的NFA：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image026_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image026_thumb.jpg" alt="clip_image026"> </a></p><p>图5.7</p><p>现在我们开始构造DFA，具体算法如下：</p><p>1：把{S}放进队列L和集合D中。其中S是NFA的起始状态。队列L放置的是未被处理的已经创建了的DFA状态，集合D放置的是已经存在的DFA状态。根据上文的讨<br>论，DFA的每一个状态都对应着NFA的一些状态。</p><p>2：从队列L中取出一个状态，计算从这个状态输出的所有边所接受的字符集的并集，然后对该集合中的每一个字符寻找接受这个字符的边，把这些边的目标状态的并集T计算出<br>来。如果T∈D则代表当前字符指向了一个已知的DFA状态。否则则代表当前字符指向了一个未创建的DFA状态，这个时候就把T放进L和D中。在这个步骤里有两层循环：<br>第一层是 <strong> 遍历 </strong> 所有接受的字符的并集，第二层是对每一个可以接受的字符 <strong> 遍历 </strong> 所有输出的边计算目标DFA状态所包含的NFA状态的集合。</p><p>3：如果L非空则跳到2。</p><p>现在我们开始对图5.7的状态机应用DFA构造算法。</p><p>首先执行第一步，我们得到：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image028_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image028_thumb.jpg" alt="clip_image028"> </a></p><p>图5.8</p><p>从上到下分别是队列L、集合D和DFA的当前状态。就这样一直执行该算法直到状态3进入集合D，我们得到：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image030_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image030_thumb.jpg" alt="clip_image030"> </a></p><p>图5.9</p><p>现在从队列L中取出{3}，经过分析得到状态集合{3}接受的字符集合为{a b c}。{3}读入a到达{4}，读入b到达{5}，读入c到达{6<br>7}。因为{4}、{5}和{6 7}都不属于D，所以把它们都放入队列L和集合D：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image032_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image032_thumb.jpg" alt="clip_image032"> </a></p><p>图5.10</p><p>从队列中取出4进行计算，我们得到：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image034_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image034_thumb.jpg" alt="clip_image034"> </a></p><p>图5.11</p><p>显然，对于状态{4}的处理并没有发现新的DFA状态。于是处理{5}和{6 7}，我们可以得到：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image036_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image036_thumb.jpg" alt="clip_image036"> </a></p><p>图5.12</p><p>在处理状态{5}的时候没有发现新的DFA状态，处理{6 7}在输入{a c}之后的跳转也没有发现新的DFA状态，但是我们发现了{6<br>7}输入b却得到了新的DFA状态{5 8}。把算法执行完，我们得到一个DFA：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image038_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image038_thumb.jpg" alt="clip_image038"> </a></p><p>图5.13</p><p>至此，对图5.7的状态机应用DFA构造算法的流程就结束了，我们得到了图5.13的DFA，其功能与图5.7的NFA等价。在DFA中，起始状态是0，结束状态是4<br>E。凡是包含了NFA的结束状态的DFA状态都必须是结束状态。</p><p>6、使用正则表达式构造词法分析器</p><p>判断一个字符串是否属于某规则的算法介绍到这里就结束了。回到我们一开始的问题上，我们需要使用一些规则来吧一个长的字符串断开成记号，然后计算出每一个记号对应的规<br>则。在解决这个问题之前，我们先考察一下能够成功地被词法分析器接受的字符串应该是什么样子的。</p><p>假设我们现在有规则A、B、C和D，分别对应于四种记号类型，那么被词法分析器接受的字符串就是A、B、C和D的任意组合，也就是(A|B|C|D)*。如果规定了输<br>入的字符串不能为空的话，那么被词法分析器接受的字符串就是(A|B|C|D)+。但是单纯地使用(A|B|C|D)+作为一个规则去应用在输入的字符串的话，我们只<br>能够判断字符串是否是词法分析器能够接受的字符串。因此我们需要对这个方法进行修改。</p><p>首先按照上文的方法，把每一个记号类型对应的规则的正则表达式转换成DFA，然后使用并联的方法将他们组合起来，但是并不使用“重复”。但是这次我们要做一点修改，<br><strong> 我们要把新的DFA的每一个状态对应的规则的DFA状态集合记住 </strong> 。</p><p>这里给出一个例子，我们假设需要一个简单语言的词法分析器，规则如下：</p><p>I：[a-zA-Z_][a-zA-Z_0-9]*</p><p>N：[0-9]+</p><p>R：[0-9]+.[0-9]+</p><p>O：[=&gt;+-*/|&amp;]</p><p>按照规则构造出四个DFA并将它们组合起来：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image039_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image039_thumb.jpg" alt="clip_image039"> </a></p><p>图6.1</p><p>我们构造出了I|N|R|O的DFA，并且标识出了哪些状态包含了原DFA的结束状态。这样做的一个好处是，当我们把一个字符串放进这样的一个DFA之后，我们就一直<br>等待整个字符串被接受，或者失败。如果字符串被接受的话，我们就把当前的结束状态记下来。如果失败的话，我们就把这个状态机在分析字符串的时候经过的最后一个结束状态<br>记下来。这个时候，结束状态所代表的原DFA结束状态的相应记号类型就是我们所需要的信息了。如果得不到任何结束状态的话，输入的字符串就是不背词法分析其接受的。</p><p>举个例子，使用上述状态机分析”123.ABC”。</p><p>首先从状态0开始，依次经过状态N N N 2，然后宣告失败。最后一个N(结束状态)以及当时被接受的字符串”123”被识别，结果为(N，”123”)。然后从”<br>.ABC”开始，输入第一个记号就失败了，于是”.”被识别为不可接受字串。最后输入”ABC”，依次经过状态0 1 I<br>I，然后字符串结束并且被接受，于是输出(I，”ABC”)。</p><p>为什么我们在构造状态机的时候不使用“重复”呢？因为在每一个记号被识别出的时候，我们都要做一些额外的工作。如果我们使用“重复”来构造词法分析器的状态机，我们将<br>无从知道一个记号被识别出来的确切时间。</p><p>算法到这里基本上就结束了，不过还存在一些小问题需要在细节上解决。一般来说我们给出的一些构成词法分析器的规则很少有冲突，不过偶尔会出现两个规则所代表的字符串集<br>合存在交集的情况。有了DFA这个工具，我们可以很轻易地识别出规则冲突。</p><p>假如我们的词法分析器有A和B两个状态，那么我们构造词法分析器A|B的时候，将会得到一些包含DFA(A)和DFA(B)的结束状态的新状态。我们只需要检查这些状<br>态是否具有以下特征，就可以判断A和B的关系。我们假设DFA(A)为规则A的状态机，DFA(B)为规则B的状态机，DFA(L)为词法分析器A|B的状态机：</p><p>1：如果DFA(L)存在一个或多个状态同时包含了DFA(A)和DFA(B)的结束状态，那么A和B所代表的字符串存在交集。</p><p>2：如果DFA(L)不存在同时包含了DFA(A)和DFA(B)的结束状态的状态，那么A和B所代表的字符串不存在交集。</p><p>3：如果DFA(L)的某些状态包含了DFA(A)的结束状态，并且这些状态都无一例外地包含了DFA(B)的结束状态的话，那么A是B的子集。</p><p>4：如果DFA(L)的某些状态包含了DFA(A)的结束状态，但是这些状态并没有无一例外地包含DFA(B)的结束状态的话，那么A不是B的子集。</p><p>在图6.1的词法分析器中，我们可以很清楚地看出I、N、R和O四个规则两两之间都不存在交集。我们可以尝试构造一个冲突的规则，并看一看词法分析器的DFA是什么样<br>子的：</p><p>假设词法分析器包含以下规则：</p><p>A：”if”</p><p>B：[a-z]+</p><p>对A|B构造DFA，我们将会得到如下状态机：</p><p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image040_2.jpg" target="_blank" rel="noopener"> <img src="http://p.blog.csdn.net/images/p_blog_csdn_net/sealyao/594039/o_clip_image040_thumb.jpg" alt="clip_image040"> </a></p><p>图6.2</p><p>通过图6.2我们可以看出，这个状态图满足了上述的条件3：包含了状态A的结束状态的状态都包含了B的结束状态，因此A是B的子集。显然”if”是[a-z]+的一个<br>子集。在处理这种有冲突的规则的时候，既可以报错，也可以根据指定的优先级进行挑选。</p><p><strong> 7、尾声  </strong></p><p>使用DFA的方法完成的可配置词法分析器的性能是相当好的。笔者前不久曾经做过实验，首先使用本文提到的算法开发一个这样的词法分析器，然后在一份C++代码(这份代<br>码经过多次复制而成件，一共有3.12M)中抽取所有数字、标识符和注释，吞吐速度高达46万记号/秒（笔者的台式电脑配置是奔腾4的超线程2.99GHz处理器，1<br>G内存），其中抽取出来的记号一共有22万个。在分析的过程中，只有10%的时间花在了DFA上，90%的时间花在了处理结果的工作上。DFA本身造成的消耗是很小的<br>。不过词法分析的性能在很大程度上跟DFA的实现有很大关系。三个月前笔者也实现过一个同类的程序，但是吞吐速度仅有1.1万记号/秒。</p><p>一般来说，比较高性能的DFA的实现是一张二维的表。行代表字符，列代表DFA的状态，单元格代表该状态经输入某个字符之后进行转移的目标状态。此外还有一张表用来记<br>录哪些状态对应哪些规则的结束状态。笔者的词法分析器是基于UTF-16编码的字符串，一张表一共有65535行显然是不现实的，因此还有另一张表把字符转换成字符类<br>。字符类是这样定义的：假设现在已经存在了65535行的一张大表，如果在某个字符区间所对应的子表内，任意一列的单元格的数据都一样的话，那么这个区间内的所有字符<br>就可以被视为是等价的，这些字符就属于同一个字符类。于是仅需要另外一张65535个单元的表用来把一个字符映射到字符类。这种做法可以大大的压缩DFA所需要的空间<br>。在笔者的程序里，识别字符类的算法被融入了DFA的构造算法中</p>]]></content>
      
      <categories>
          
          <category> 以前 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
